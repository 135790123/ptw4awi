source,target,raw_preds
"@Deprecated
public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0,True
"@Deprecated
public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",0,True
"return constant_pool;
",0,False
"@Deprecated
public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",1,False
"@Deprecated
public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",1,True
"this.annotation_table = annotation_table;
",0,False
"this.interface_names = interface_names;
",0,False
"this.parameter_annotation_table = parameter_annotation_table;
",0,False
"this.annotation_table = annotation_table;
",0,False
"return byte_positions;
",0,False
"return requires_table;
",0,False
"@Deprecated
public static final short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",1,False
"return annotation_table;
",0,False
"i = ((ConstantClass) c).getNameIndex();
",0,False
"str = String.valueOf(((ConstantFloat) c).getBytes());
",0,False
"return attributes;
",0,False
"return fields;
",0,False
"return interface_names;
",0,False
"return line_number_table;
",0,False
"this.line_number_table = line_number_table;
",0,False
"this.local_variable_type_table = local_variable_table;
",0,False
"return parameterAnnotationEntries;
",0,False
"this.parameter_annotation_table = parameter_annotation_table;
",0,False
"return map;
",0,False
"return bytes;
",0,False
"ArrayType array = (ArrayType) type;
",0,False
"return addInteger(((ConstantInteger) c).getBytes());
",0,False
"return addDouble(((ConstantDouble) c).getBytes());
",0,False
"return new SimpleElementValueGen((SimpleElementValue) value, cpool,
",0,False
"return new EnumElementValueGen((EnumElementValue) value, cpool,
",0,False
"return new ArrayElementValueGen((ArrayElementValue) value, cpool,
",0,False
"return new Float(value);
",0,False
"return new Float(((org.apache.commons.bcel6.classfile.ConstantFloat) c).getBytes());
",0,False
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_attributes.html""));
",0,False
"class_name = java_class.getClassName(); 
",0,False
"new GraphicalVerifier();
",0,False
"contentPane = (JPanel) this.getContentPane();
",0,False
"objreftype.subclassOf(curr) ) ){
",0,False
"String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0,True
"String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0,False
"short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",0,True
"String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",0,False
"@Deprecated
Class<?>[] EXCS_ARRAY_EXCEPTION = { NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION };",0,False
"this.bootstrapArguments = bootstrapArguments;
",0,False
"this.bootstrapArguments = bootstrapArguments;
",0,False
"return bootstrapMethods;
",0,False
"return exceptionTable;
",0,False
"i = ((ConstantPackage) c).getNameIndex();
",0,False
"str = String.valueOf(((ConstantDouble) c).getBytes());
",0,False
"created++;
",0,False
"return bytes;
",0,False
"this.attributes = attributes;
",0,False
"this.localVariableTable = localVariableTable;
",0,False
"return providesTable;
",0,False
"return packageIndexTable;
",0,False
"return typesOfStackItems;
",0,False
"return typesOfLocals;
",0,False
"this.bytes = bytes;
",0,False
"this.bytes = bytes;
",0,False
"return bytes;
",0,False
"this.bytes = bytes;
",0,False
"return null;
",0,False
"final ConstantCP m = (ConstantCP) c;
",0,False
"return addFloat(((ConstantFloat) c).getBytes());
",0,False
"return new Double(value);
",0,False
"return new ClassElementValueGen((ClassElementValue) value, cpool,
",0,False
"return new Float(value);
",0,False
Instruction[] INSTRUCTIONS = new Instruction[256];,0,False
"this.argNames = arg_names;
",0,False
"return match;
",0,False
"final BranchHandle bh = (BranchHandle) branch_map.get(bi);
",0,False
"_out.println(""il.append(new IINC("" + i.getIndex() + "", "" + ((IINC) i).getIncrement()
",0,False
"class_name = java_class.getClassName(); 
",0,False
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_code.html""));
",0,False
"System.gc(); 
",0,False
"if ((obj.getAccessFlags() &
",0,False
"final OperandStack newstack = new OperandStack(this.maxStack);
@SuppressWarnings(""unchecked"") 
final ArrayList<Type> clone = (ArrayList<Type>) this.stack.clone();
newstack.stack = clone;
return newstack;
",0,False
"public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0,True
"public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"" };",0,True
"this.annotation_table = annotation_table;
",0,False
"this.annotation_table = annotation_table;
",0,False
"zip = new ZipFile(zip_file);
",0,False
"return new Double(bytes);
",0,False
"this.constant_pool = constant_pool;
",0,False
"str = ((ConstantUtf8) c).getBytes();
",0,False
"created++;
",0,False
"this.attributes = attributes;
",0,False
"return attributes;
",0,False
"this.line_number_table = line_number_table;
",0,False
"return local_variable_table;
",0,False
"this.local_variable_table = local_variable_table;
",0,False
"return local_variable_type_table;
",0,False
"this.local_variable_type_table = local_variable_table;
",0,False
"this.bytes = bytes;
",0,False
"System.exit(-1);
",0,False
"ConstantCP m = (ConstantCP) c;
",0,False
"return new AnnotationElementValueGen(
",0,False
"return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
",0,False
"return byte_positions;
",0,False
"this.arg_names = arg_names;
",0,False
"return targets;
",0,False
"BranchHandle bh = (BranchHandle) branch_map.get(bi);
",0,False
"for (int i = 0, pow = 1; pow <= Const.MAX_ACC_FLAG; i++) {
",0,False
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
",0,False
"new GraphicalVerifier();
",0,False
"return null;
",0,False
"SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return decodeHex(new String(array).toCharArray());
",0,True
"return md5(data.getBytes());
",0,True
"return null;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; 
buffer[pos++] = PAD;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"return null;
",0,False
"if (m == null || !m.find()) {
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return sha384(data.getBytes());
",0,True
"return sha256(data.getBytes());
",0,True
"return txt.toUpperCase() ;
",0,True
"return str.toUpperCase();
",0,True
"String replacedName = name.toUpperCase();
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
",0,False
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"validateTrailingCharacters();
case 2 : 
validateCharacter(MASK_2BITS, context);
",0,False
"k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
",0,False
"case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
",0,False
"switch(len) {
case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
",0,False
"modulus = (++modulus) % 3;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; 
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; 
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
",0,False
"switch (unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
",0,False
"switch (unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
",0,False
"switch(len) {
case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"return null;
",0,False
"return null;
",0,False
protected final String charset;,0,False
"return new String(encodeHex(array)).getBytes();
",0,True
"return md5(data.getBytes());
",0,True
"return null;
",0,False
"return null;
",0,False
"k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (modulus) {
case 2 : 
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5 : 
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6 : 
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7 : 
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0,False
"return null;
",0,False
"return null;
",0,False
"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
"h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
",0,False
"switch (unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
",0,False
"k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
",0,False
"final SomeLanguages someLanguages = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"if (m == null || !m.find()) {
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
",0,False
"return null;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; 
buffer[pos++] = PAD;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; 
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; 
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"for (int i = 0; i < phonemeText.length(); i++) {
if (i >= o.phonemeText.length()) {
return +1;
}
int c = phonemeText.charAt(i) - o.phonemeText.charAt(i);
if (c != 0) {
return c;
}
}
if (phonemeText.length() < o.phonemeText.length()) {
return -1;
}
return 0;
",0,False
"salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] +
",1,False
"switch (context.modulus) {
case 2 : 
context.ibitWorkArea = context.ibitWorkArea >> 4; 
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
case 3 : 
context.ibitWorkArea = context.ibitWorkArea >> 2; 
buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
",1,False
"return null;
",0,False
"modulus = (++modulus) % 3;
",0,False
"this.lineSeparator = lineSeparator;
",1,False
"sep = new String(lineSeparator);
",1,False
protected static byte ESCAPE_CHAR = '%';,0,True
"salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
",0,False
"SomeLanguages sl = (SomeLanguages) other;
",0,False
"switch(symb) {
case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
if (n == 0) {
code.append(symb);
}
break ; 
case 'B' :
if ( isPreviousChar(local, n, 'M') &&
isLastChar(wdsz, n) ) { 
break;
}
code.append(symb);
break;
case 'C' : 
if ( isPreviousChar(local, n, 'S') &&
!isLastChar(wdsz, n) &&
FRONTV.indexOf(local.charAt(n + 1)) >= 0 ) {
break;
}
if (regionMatch(local, n, ""CIA"")) { 
code.append('X');
break;
}
if (!isLastChar(wdsz, n) &&
FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
code.append('S');
break; 
}
if (isPreviousChar(local, n, 'S') &&
isNextChar(local, n, 'H') ) { 
code.append('K') ;
break ;
}
if (isNextChar(local, n, 'H')) { 
if (n == 0 &&
wdsz >= 3 &&
isVowel(local,2) ) { 
code.append('K');
} else {
code.append('X'); 
}
} else {
code.append('K');
}
break ;
case 'D' :
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'G') &&
FRONTV.indexOf(local.charAt(n + 2)) >= 0) { 
code.append('J'); n += 2 ;
} else {
code.append('T');
}
break ;
case 'G' : 
if (isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local,n,'H') &&
!isVowel(local,n+2)) {
break;
}
if (n > 0 &&
( regionMatch(local, n, ""GN"") ||
regionMatch(local, n, ""GNED"") ) ) {
break; 
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true ;
} else {
hard = false ;
}
if (!isLastChar(wdsz, n) &&
FRONTV.indexOf(local.charAt(n + 1)) >= 0 &&
!hard) {
code.append('J');
} else {
code.append('K');
}
break ;
case 'H':
if (isLastChar(wdsz, n)) {
break ; 
}
if (n > 0 &&
VARSON.indexOf(local.charAt(n - 1)) >= 0) {
break;
}
if (isVowel(local,n+1)) {
code.append('H'); 
}
break;
case 'F':
case 'J' :
case 'L' :
case 'M':
case 'N' :
case 'R' :
code.append(symb);
break;
case 'K' :
if (n > 0) { 
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb); 
}
break ;
case 'P' :
if (isNextChar(local,n,'H')) {
code.append('F');
} else {
code.append(symb);
}
break ;
case 'Q' :
code.append('K');
break;
case 'S' :
if (regionMatch(local,n,""SH"") ||
regionMatch(local,n,""SIO"") ||
regionMatch(local,n,""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T' :
if (regionMatch(local,n,""TIA"") ||
regionMatch(local,n,""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local,n,""TCH"")) {
break;
}
if (regionMatch(local,n,""TH"")) {
code.append('0');
} else {
code.append('T');
}
break ;
case 'V' :
code.append('F'); break ;
case 'W' : case 'Y' : 
if (!isLastChar(wdsz,n) &&
isVowel(local,n+1)) {
code.append(symb);
}
break ;
case 'X' :
code.append('K'); code.append('S');
break ;
case 'Z' :
code.append('S'); break ;
",1,False
"switch (modulus) {
case 2 : 
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5 : 
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6 : 
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7 : 
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0,False
"return String.format(""%s[%s]"", super.toString(), args);
",1,False
"return sha384(data.getBytes());
",1,True
"return getInitializedMac(algorithm, key);
",0,False
"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
"return sha(data.getBytes());
",1,True
"for (; salt.length() < 2; salt = salt + ""A"");
",0,False
"final byte[] bytes = text.getBytes();
",1,True
"return this.doEquals(obj, KEY);
",0,False
"protected final Transformer<? super E, ? extends E> transformer;",0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
private final Factory<? extends O> iFactory;,0,False
"return null;
",0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
"return this.array;
",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"Set<K> currentKeys = keySet();
",0,False
"if (BitMap.numberOfBitMaps(shape.getNumberOfBits()) * Long.BYTES < (long) shape.getNumberOfHashFunctions()
",0,False
private final Predicate<? super T> iPredicate2;,0,False
private final Closure<? super E>[] iClosures;,0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
private final Equator<T> equator;,0,False
private final Predicate<? super T> iPredicate;,0,False
private final Predicate<? super I>[] iPredicates;,0,False
"return this.array;
",0,False
"return (List<E>) super.decorated();
",0,False
"return (List<E>) decorated();
",0,False
"return (UnmodifiableMultiValuedMap<K, V>) map;
",0,False
"final Set<K> currentKeys = keySet();
",0,False
"return null;
",0,False
private final Comparator<? super E> nonNullComparator;,0,False
private transient Method iCloneMethod;,0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"return (List<E>) super.decorated();
",0,False
"return (List<E>) decorated();
",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"V currentValue, nextValue;",0,False
"return (SortedSet<E>) decorated();
",0,False
"return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
",0,False
private final Closure<? super E>[] iClosures;,0,False
"return null;
",0,False
private final Predicate<? super T> iPredicate;,0,False
private final Factory<? extends E> factory;,0,False
"if (((ReferenceEntry<K, V>) entry).purge(ref)) {
",0,False
"return hash;
",0,False
"total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
",0,False
"final ArrayList<V> list = (ArrayList<V>) coll;
",0,False
"return null;
",0,False
"return null;
",0,False
"private final Transformer<? super I, ? extends O> iFalseTransformer;",0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
"this.keys = keys;
",0,False
"V currentValue, nextValue;",0,False
"moveToMRU((LinkEntry<K, V>) entry);  
",0,False
protected K key;,0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"this.collectionFactory = new InstantiateFactory<C>(collectionClazz, new Class[] { Integer.TYPE },
",0,True
"Set<V> valueSet = (Set<V>) entry.getValue();
",0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"return (UnmodifiableMultiValuedMap<K, V>) map;
",0,False
"return (Set<E>) super.decorated();
",0,False
private final Predicate<? super T> iPredicate1;,0,False
private final Predicate<? super I> iPredicate;,0,False
private final Predicate<? super T> iPredicate2;,0,False
"return hash;
",0,False
"return hash;
",0,False
"buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
",0,False
"private final Transformer<? super K, ? extends K> keyTransformer;",0,False
"out.writeObject(comparator());
",0,False
"parent.remove(last.getKey());
",0,False
private final List<Comparator<E>> comparatorChain;,0,False
private final Comparator<? super E> comparator;,0,False
private final Factory<? extends O> iFactory;,0,False
private final Predicate<? super T> iPredicate;,0,False
private final Closure<? super E>[] iClosures;,0,False
private final Predicate<? super I>[] iPredicates;,0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
protected K key;,0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"if (listSize < 0) {
",0,False
"protected final Transformer<? super E, ? extends E> transformer;",0,False
"private final Transformer<? super I, ? extends O> transformer;",0,False
"return null;
",0,False
"private final Transformer<? super I, ? extends O>[] iTransformers;",0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"return this.array;
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = (List<V>) getMapping();
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"return (SortedSet<E>) decorated();
",0,False
"return this.doEquals(obj, KEY);
",0,False
"private final Transformer<C, K> keyTransformer;",0,False
"private final Transformer<? super I, ? extends O> transformer;",0,False
"return null;
",0,False
"private final Transformer<? super I, ? extends O> iFalseTransformer;",0,False
"this.array = array;
",0,False
"entry = entry.next();
",0,False
"List<V> list = (List<V>) getMapping();
",0,False
"List<V> list = (List<V>) createCollection();
",0,False
"final List<V> list = (List<V>) getMapping();
",0,False
"List<V> list = (List<V>) getMapping();
",0,False
private transient KeysBag keysBagView;,0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"Set<V> valueSet = (Set<V>) entry.getValue();
",0,False
"return (SortedSet<E>) decorated();
",0,False
"return null;
",0,False
"private final Transformer<? super I, ? extends O> transformer;",0,False
private transient Method iCloneMethod;,0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
"return this.array;
",0,False
"this.keys = keys;
",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"return (LinkEntry<K, V>) super.getEntry(key);
",0,False
"return hash;
",0,False
"buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
",0,False
"protected Node<K, V> next;",0,False
"List<V> valueList = (List<V>) entry.getValue();
",0,False
"return (Set<E>) super.decorated();
",0,False
"map.size();  
",0,False
"return null;
",0,False
"protected final Transformer<? super E, ? extends E> transformer;",0,False
private final Comparator<? super E> nonNullComparator;,0,False
"private final Transformer<? super I, ? extends O> transformer;",0,False
"return null;
",0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
"this.keys = keys;
",0,False
"total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
",0,False
"return (Set<E>) super.decorated();
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",1,False
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",1,False
"pstmt = conn.prepareStatement(query.toString());
",1,False
"value = array.length == 0 ? null : new Integer(array[0]);
",1,False
"catch (final Exception e)
",0,False
private ResultSet resultSet;,0,False
private final ConfigurationInterpolator localSubst;,0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
"if (fileName.startsWith(""."" + File.separator))
",0,False
"return new Double(n.doubleValue());
",0,False
"getConfiguration().addProperty(name, new Short(array[i]));
",1,False
"file = new File(fileName);
",0,False
"getLogger().debug(os.toString());
",0,False
"file = new File(fileName);
",0,False
"return getLong(key, new Long(defaultValue)).longValue();
",1,False
"if (fileName.startsWith(""."" + File.separator))
",0,False
"catch (final Exception ex)
",0,False
"return new Integer(n.intValue());
",1,False
"synchronized (listeners)
",0,False
"List lst = (List) namedNodes.remove(name);
",1,False
"return new Short(n.shortValue());
",1,False
"catch (final Exception e)
",0,False
"value = array.length == 0 ? null : new Short(array[0]);
",1,False
"if (fileName.startsWith(""."" + File.separator))
",0,False
"return configurations;
",1,False
"file = new File(fileName);
",0,False
"return getShort(key, new Short(defaultValue)).shortValue();
",1,False
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
private final EventListener<ConfigurationEvent> changeListener;,0,False
"return new Byte(n.byteValue());
",1,False
"if (fileName.startsWith(""."" + File.separator))
",0,False
"return (configuration.getURL() != null) ? fileFromURL(configuration
",0,False
"synchronized (getClass())
",0,False
"getConfiguration().addProperty(name, new Double(array[i]));
",1,False
"return new Double(n.doubleValue());
",1,False
"value = array.length == 0 ? null : new Long(array[0]);
",1,False
"dump(configuration, new PrintWriter(out));
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
private final ImmutableConfiguration configuration;,0,False
private ReloadingController reloadingController;,0,False
"catch (Exception e)
",0,False
"{
@Override
public String lookup(String key)
{
Object value = ip.resolve(key);
return (value != null) ? value.toString() : null;
",0,False
"catch (Exception e)
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0,False
private final Object reloadLock;,0,False
"configurationsMap.putIfAbsent(pattern, configuration);
",0,False
private ReloadingStrategy fileStrategy;,0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<?> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"if (init)
",0,False
"return new Long(n.longValue());
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
private final String protocol;,0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"staticCatalog = catalog;
",0,False
"result = namedNodes.get(name);
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
"// [ERROR] Medium: Class org.apache.commons.configuration2.builder.ConfigurationBuilderResultCreatedEvent defines
private final ImmutableConfiguration configuration;",0,False
"} catch (final Exception e) {
",0,False
"return sourceURL != null ? sourceURL.toExternalForm() : StringUtils.EMPTY;
",0,False
"} catch (final Exception ex) {
",0,False
private final String protocol;,0,False
"} catch (final Exception e) {
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"reader = new InputStreamReader(in);
",0,False
private List<ConfigData> configurations;,0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"parent.mkdirs();
",0,False
private final Object reloadLock;,0,False
"synchronized (counterLock)
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"if (init)
",0,False
"return new Byte(n.byteValue());
",0,False
"return new Double(n.doubleValue());
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"{
super(name);
setReference(elem);
}
@Override
public void setValue(Object value)
{
super.setValue(value);
if (getReference() != null && document != null)
{
if (isAttribute())
{
updateAttribute();
}
else
{
updateElement(value);
}
}
}
@Override
protected void removeReference()
{
if (getReference() != null)
{
Element element = (Element) getReference();
if (isAttribute())
{
updateAttribute();
}
else
{
org.w3c.dom.Node parentElem = element.getParentNode();
if (parentElem != null)
{
parentElem.removeChild(element);
}
}
}
}
private void updateElement(Object value)
{
Text txtNode = findTextNodeForUpdate();
if (value == null)
{
if (txtNode != null)
{
((Element) getReference()).removeChild(txtNode);
}
}
else
{
if (txtNode == null)
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode = document.createTextNode(newValue);
if (((Element) getReference()).getFirstChild() != null)
{
((Element) getReference()).insertBefore(txtNode,
((Element) getReference()).getFirstChild());
}
else
{
((Element) getReference()).appendChild(txtNode);
}
}
else
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode.setNodeValue(newValue);
}
}
}
private void updateAttribute()
{
XMLBuilderVisitor.updateAttribute(getParent(), getName(), getListDelimiter(),
isAttributeSplittingDisabled());
}
private Text findTextNodeForUpdate()
{
Text result = null;
Element elem = (Element) getReference();
NodeList children = elem.getChildNodes();
Collection<org.w3c.dom.Node> textNodes = new ArrayList<org.w3c.dom.Node>();
for (int i = 0; i < children.getLength(); i++)
{
org.w3c.dom.Node nd = children.item(i);
if (nd instanceof Text)
{
if (result == null)
{
result = (Text) nd;
}
else
{
textNodes.add(nd);
}
}
}
if (result instanceof CDATASection)
{
textNodes.add(result);
result = null;
}
for (org.w3c.dom.Node tn : textNodes)
{
elem.removeChild(tn);
}
return result;
",0,False
"catch (Exception e)
",0,False
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"staticCatalog = catalog;
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
"return getShort(key, new Short(defaultValue)).shortValue();
",0,False
"reader = new InputStreamReader(in);
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
private List<ConfigData> configurations;,0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0,False
private final Object reloadLock;,0,False
"if (init)
",0,False
"return new Float(n.floatValue());
",0,False
"return new Integer(n.intValue());
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
"catch (Exception e)
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",0,False
"if (name == null)
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0,False
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0,False
private ConfigurationNode node;,0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
private ConfigurationSourceData sourceData;,0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"staticCatalog = catalog;
",0,False
private ExpressionEngine conversionExpressionEngine;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"parent.mkdirs();
",0,False
"catch (Exception e)
",0,False
"if (configs != null)
",0,False
private final Object reloadLock;,0,False
"catch (Exception e)
",0,False
private DocumentBuilder documentBuilder;,0,False
"catch (Exception ex)
",0,False
"expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
",0,False
private boolean jj_semLA;,0,False
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"Token token = null;
String value = null;
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
{if (true) return unescapeQuotes(removeQuotes(token.image));}
break;
case STRING:
token = jj_consume_token(STRING);
{if (true) return token.image;}
break;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0,False
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (8 - (column & 07));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0,False
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0,False
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"List lst = (List) namedNodes.get(node.getName());
",0,False
".get(positionToIndex(getPosition())));
",0,False
"parent.mkdirs();
",0,False
"catch (Exception e)
",0,False
private NodeCombiner nodeCombiner;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"return bsCount % 2 == 1;
",0,False
"return new Long(n.longValue());
",0,False
"catch (Exception e)
",0,False
"throw new IllegalArgumentException(""No such property name=["" + name + ""]"");
",0,False
"expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
",0,False
"Token token = null;
String value = null;
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
{if (true) return unescapeQuotes(removeQuotes(token.image));}
break;
case STRING:
token = jj_consume_token(STRING);
{if (true) return token.image;}
break;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"token = jj_consume_token(DATE);
{if (true) return parseDate(token.image);}
",0,False
"jjCheckNAdd(jjnextStates[start]);
jjCheckNAdd(jjnextStates[start + 1]);
}
",0,False
"buffer = null;
bufline = null;
bufcolumn = null;
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
public Token specialToken;,0,False
"return(""Lexical error at line "" +
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"addValue(new Double(value));
",0,False
"private StringBuffer buffer = new StringBuffer();
private List stack = new ArrayList();
public XMLPropertyListHandler(Node root)
{
push(root);
}
private Node peek()
{
if (!stack.isEmpty())
{
return (Node) stack.get(stack.size() - 1);
}
else
{
return null;
}
}
private Node pop()
{
if (!stack.isEmpty())
{
return (Node) stack.remove(stack.size() - 1);
}
else
{
return null;
}
}
private void push(Node node)
{
stack.add(node);
}
public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException
{
if (""array"".equals(qName))
{
push(new ArrayNode());
}
else if (""dict"".equals(qName))
{
if (peek() instanceof ArrayNode)
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) peek();
node.addValue(config);
push(config.getRoot());
}
}
}
public void endElement(String uri, String localName, String qName) throws SAXException
{
if (""key"".equals(qName))
{
PListNode node = new PListNode();
node.setName(buffer.toString());
peek().addChild(node);
push(node);
}
else if (""dict"".equals(qName))
{
pop();
}
else
{
if (""string"".equals(qName))
{
((PListNode) peek()).addValue(buffer.toString());
}
else if (""integer"".equals(qName))
{
((PListNode) peek()).addIntegerValue(buffer.toString());
}
else if (""real"".equals(qName))
{
((PListNode) peek()).addRealValue(buffer.toString());
}
else if (""true"".equals(qName))
{
((PListNode) peek()).addTrueValue();
}
else if (""false"".equals(qName))
{
((PListNode) peek()).addFalseValue();
}
else if (""data"".equals(qName))
{
((PListNode) peek()).addDataValue(buffer.toString());
}
else if (""date"".equals(qName))
{
((PListNode) peek()).addDateValue(buffer.toString());
}
else if (""array"".equals(qName))
{
ArrayNode array = (ArrayNode) pop();
((PListNode) peek()).addList(array);
}
if (!(peek() instanceof ArrayNode))
{
pop();
}
}
buffer.setLength(0);
}
public void characters(char[] ch, int start, int length) throws SAXException
{
buffer.append(ch, start, length);
}
",0,False
"catch (Exception e)
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"return (configuration.getURL() != null) ? fileFromURL(configuration
",0,False
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"private Map<String, AbstractConfiguration> namedConfigurations;",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"instanceId = ++counter;
",0,False
"return new Double(n.doubleValue());
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"catch (Exception e)
",0,False
"result = namedNodes.get(name);
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
private final Configuration configuration;,0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
private FileLocator locator;,0,False
private AutoSaveListener autoSaveListener;,0,False
"return new Double(n.doubleValue());
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"catch (Exception e)
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"staticCatalog = catalog;
",0,False
"result = namedNodes.get(name);
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0,False
"catch (Exception ex)
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"catch (Exception e)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
private final QueryResult<T> attributeResult;,0,False
"writer = new OutputStreamWriter(out);
",0,False
"public class CombinedConfiguration extends HierarchicalReloadableConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private boolean ignoreReloadExceptions = true;
private boolean reloadRequired;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(NodeCombiner comb, Lock lock)
{
super(lock);
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(Lock lock)
{
this(null, lock);
}
public CombinedConfiguration()
{
this(null, null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Adding configuration "" + config + "" with name "" + name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public List getConfigurations()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getConfiguration());
}
return list;
}
public List getConfigurationNameList()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
reloadRequired = true;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
public ConfigurationNode getRootNode()
{
synchronized (getReloadLock())
{
if (reloadRequired || combinedRoot == null)
{
combinedRoot = constructCombinedNode();
reloadRequired = false;
}
return combinedRoot;
}
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator it = nodes.iterator();
Configuration source = findSourceConfiguration((ConfigurationNode) it
.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration((ConfigurationNode) it
.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected List fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
synchronized (getReloadLock())
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
}
return this;
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0,False
".get(positionToIndex(getPosition())));
",0,False
"reader = new InputStreamReader(in);
",0,False
"if (file != null && file.exists())
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
private ConfigurationNode rootNode;,0,False
"instanceId = ++counter;
",0,False
"configurationsMap.putIfAbsent(pattern, configuration);
",0,False
"return new Long(n.longValue());
",0,False
private final String protocol;,0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0,False
"String name = (url == null) ? fileName : url.toString();
",0,False
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0,False
"catch (final Exception e)
",0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"if (configs != null)
",0,False
"{
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"return new Integer(n.intValue());
",0,False
"T node2 = ((ConfigurationNodePointer<T>) pointer2).getConfigurationNode();
",0,False
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0,False
public int endLine;,0,False
"catch (Exception e)
",0,False
"synchronized (INIT_GATE)
",0,False
"synchronized (INIT_GATE)
",0,False
"result = namedNodes.get(name);
",0,False
"catch (Exception e)
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
"expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
",0,False
"Object value = null;
if (jj_2_1(2)) {
value = Array();
{if (true) return value;}
} else {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_BEGIN:
value = Dictionary();
{if (true) return value;}
break;
case STRING:
case QUOTED_STRING:
value = String();
{if (true) return value;}
break;
case DATA:
value = Data();
{if (true) return value;}
break;
case DATE:
value = Date();
{if (true) return value;}
break;
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_BEGIN:
case DICT_BEGIN:
case DATA:
case DATE:
case STRING:
case QUOTED_STRING:
element = Element();
list.add(element);
label_2:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(ARRAY_SEPARATOR);
element = Element();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
{if (true) return list;}
",0,False
"Token token = null;
String value = null;
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
{if (true) return unescapeQuotes(removeQuotes(token.image));}
break;
case STRING:
token = jj_consume_token(STRING);
{if (true) return token.image;}
break;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"if (lexState >= 1 || lexState < 0)
{
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
}
else
{
curLexState = lexState;
}
}
",0,False
"buffer = null;
bufline = null;
bufcolumn = null;
}
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"catch (Exception e)
",0,False
"result = (List) namedNodes.get(name);
",0,False
".get(positionToIndex(getPosition())));
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
private ConfigurationNode node;,0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
private final ImmutableConfiguration configuration;,0,False
private ConfigurationSourceData sourceData;,0,False
"reloadingController.resetReloadingState();
",0,False
"return new Float(n.floatValue());
",0,False
"catch (Exception e)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"staticCatalog = catalog;
",0,False
private final NodeHandler<T> handler;,0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"catch (Exception e)
",0,False
private ReloadingController reloadingController;,0,False
"return new Double(n.doubleValue());
",0,False
"return new Long(n.longValue());
",0,False
"return new Short(n.shortValue());
",0,False
"catch (Exception ex)
",0,False
"getLogger().debug(os.toString());
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"file = new File(fileName);
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"parent.mkdirs();
",0,False
private final Object reloadLock;,0,False
"synchronized (counterLock)
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final AbstractHierarchicalFileConfiguration config;
private final String path;
private final boolean trailing;
private boolean init;
public PatternSubtreeConfigurationWrapper(AbstractHierarchicalFileConfiguration config, String path)
{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
@Override
public Object getReloadLock()
{
return config.getReloadLock();
}
@Override
public void addProperty(String key, Object value)
{
config.addProperty(makePath(key), value);
}
@Override
public void clear()
{
getConfig().clear();
}
@Override
public void clearProperty(String key)
{
config.clearProperty(makePath(key));
}
@Override
public boolean containsKey(String key)
{
return config.containsKey(makePath(key));
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
@Override
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
@Override
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
@Override
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
@Override
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
@Override
public int getInt(String key)
{
return config.getInt(makePath(key));
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return config.getKeys(makePath());
}
@Override
public Iterator<String> getKeys(String prefix)
{
return config.getKeys(makePath(prefix));
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
@Override
public List<Object> getList(String key)
{
return config.getList(makePath(key));
}
@Override
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public long getLong(String key)
{
return config.getLong(makePath(key));
}
@Override
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
@Override
public Object getProperty(String key)
{
return config.getProperty(makePath(key));
}
@Override
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public short getShort(String key)
{
return config.getShort(makePath(key));
}
@Override
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
@Override
public String getString(String key)
{
return config.getString(makePath(key));
}
@Override
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
@Override
public boolean isEmpty()
{
return getConfig().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
getConfig().setProperty(key, value);
}
@Override
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
@Override
public Node getRoot()
{
return getConfig().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
getConfig().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
getConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
@Override
public void clearTree(String key)
{
config.clearTree(makePath(key));
}
@Override
public int getMaxIndex(String key)
{
return config.getMaxIndex(makePath(key));
}
@Override
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
config.save(writer);
}
public void load(Reader reader) throws ConfigurationException
{
config.load(reader);
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return getConfig().getErrorListeners();
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
private HierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return getSubstitutor().replace(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return getSubstitutor().replace(pathPattern) + item;
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"{
super(name);
setReference(elem);
}
@Override
public void setValue(Object value)
{
super.setValue(value);
if (getReference() != null && document != null)
{
if (isAttribute())
{
updateAttribute();
}
else
{
updateElement(value);
}
}
}
@Override
protected void removeReference()
{
if (getReference() != null)
{
Element element = (Element) getReference();
if (isAttribute())
{
updateAttribute();
}
else
{
org.w3c.dom.Node parentElem = element.getParentNode();
if (parentElem != null)
{
parentElem.removeChild(element);
}
}
}
}
private void updateElement(Object value)
{
Text txtNode = findTextNodeForUpdate();
if (value == null)
{
if (txtNode != null)
{
((Element) getReference()).removeChild(txtNode);
}
}
else
{
if (txtNode == null)
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode = document.createTextNode(newValue);
if (((Element) getReference()).getFirstChild() != null)
{
((Element) getReference()).insertBefore(txtNode,
((Element) getReference()).getFirstChild());
}
else
{
((Element) getReference()).appendChild(txtNode);
}
}
else
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode.setNodeValue(newValue);
}
}
}
private void updateAttribute()
{
XMLBuilderVisitor.updateAttribute(getParent(), getName(), getListDelimiter(),
isAttributeSplittingDisabled());
}
private Text findTextNodeForUpdate()
{
Text result = null;
Element elem = (Element) getReference();
NodeList children = elem.getChildNodes();
Collection<org.w3c.dom.Node> textNodes = new ArrayList<org.w3c.dom.Node>();
for (int i = 0; i < children.getLength(); i++)
{
org.w3c.dom.Node nd = children.item(i);
if (nd instanceof Text)
{
if (result == null)
{
result = (Text) nd;
}
else
{
textNodes.add(nd);
}
}
}
if (result instanceof CDATASection)
{
textNodes.add(result);
result = null;
}
for (org.w3c.dom.Node tn : textNodes)
{
elem.removeChild(tn);
}
return result;
",0,False
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",0,False
"result = namedNodes.get(name);
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
"public static final EventType<ConfigurationBuilderResultCreatedEvent> RESULT_CREATED =
new EventType<ConfigurationBuilderResultCreatedEvent>(ANY,
""RESULT_CREATED"");
private final ImmutableConfiguration configuration;
public ConfigurationBuilderResultCreatedEvent(
ConfigurationBuilder<?> source,
EventType<? extends ConfigurationBuilderResultCreatedEvent> evType,
ImmutableConfiguration createdConfiguration)
{
super(source, evType);
if (createdConfiguration == null)
{
throw new IllegalArgumentException(
""Configuration must not be null!"");
}
configuration = createdConfiguration;
}
public ImmutableConfiguration getConfiguration()
{
return configuration;
",0,False
private final ImmutableConfiguration configuration;,0,False
"catch (Exception ex)
",0,False
private final String protocol;,0,False
"staticCatalog = catalog;
",0,False
private final QueryResult<T> attributeResult;,0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0,False
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0,False
"value = array.length == 0 ? null : new Long(array[0]);
",0,False
"value = array.length == 0 ? null : new Double(array[0]);
",0,False
"return count % 2 == 1;
",0,False
"if (file != null && file.exists())
",0,False
protected Configuration configuration;,0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"switch (state)
{
case 0:
if (c == '\\')
{
state = 1;
}
else if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c))
{
key.append(c);
}
else
{
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
",0,False
"return new Long(n.longValue());
",0,False
"getConfiguration().addProperty(name, new Integer(array[i]));
",0,False
"throw new IllegalArgumentException(""No such property name=["" + name + ""]"");
",0,False
public Token currentToken;,0,False
"return null;
",0,False
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true)
{
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration)
{
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
return configuration;
",0,False
"jjround = 0x80000001;
for (i = 9; i-- > 0;)
jjrounds[i] = 0x80000000;
}
",0,False
"if ((jjbitVec0[i2] & l2) == 0L)
break;
if (kind > 19)
kind = 19;
jjCheckNAdd(3);
break;
",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"{
public void end() throws Exception
{
}
",0,False
"List lst = (List) namedNodes.get(node.getName());
",0,False
"result = (List) namedNodes.get(name);
",0,False
"return dataSource;
",0,False
"result.setErrorHandler(new DefaultHandler() {
@Override
public void error(final SAXParseException ex) throws SAXException {
throw ex;
",0,False
"} catch (final Exception e) {
",0,False
"return sourceURL != null ? sourceURL.toExternalForm() : StringUtils.EMPTY;
",0,False
"final String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
private final QueryResult<T> attributeResult;,0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent, wrapper.getNode(), wrapper.getNodeHandler());
",0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"writer = new OutputStreamWriter(out);
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"reader = new InputStreamReader(in);
",0,False
"return new Double(n.doubleValue());
",0,False
private NodeHandler<T> nodeHandler;,0,False
"T node2 = ((ConfigurationNodePointer<T>) pointer2).getConfigurationNode();
",0,False
"T node1 = ((ConfigurationNodePointer<T>) pointer1).getConfigurationNode();
",0,False
private final String protocol;,0,False
"try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 5; i++) jj_la1[i] = -1;
}
",0,False
"String key = null;
Object value = null;
key = String();
jj_consume_token(SEPARATOR);
value = Value();
ConfigurationNode node = null;
if (value instanceof AbstractHierarchicalConfiguration)
{
AbstractHierarchicalConfiguration config = (AbstractHierarchicalConfiguration) value;
node = (ConfigurationNode) config.getRootNode();
node.setName(key);
}
else if (value != null)
{
node = new DefaultConfigurationNode();
node.setValue(value);
node.setName(key);
}
{if (true) return node;}
",0,False
"token = jj_consume_token(TRUE);
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"jjround = 0x80000001;
for (i = 31; i-- > 0;)
jjrounds[i] = 0x80000000;
}
",0,False
"retval += "" \"""";
",0,False
"ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
",0,False
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0,False
public Token specialToken;,0,False
"return instance.getByteArray(null, null);
",0,False
"retval += "" \"""";
",0,False
"Object value = null;
if (jj_2_1(2)) {
value = Array();
{if (true) return value;}
} else {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_BEGIN:
value = Dictionary();
{if (true) return value;}
break;
case STRING:
case QUOTED_STRING:
value = String();
{if (true) return value;}
break;
case DATA:
value = Data();
{if (true) return value;}
break;
case DATE:
value = Date();
{if (true) return value;}
break;
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"token = jj_consume_token(DATA);
{if (true) return filterData(token.image);}
",0,False
"if (lexState >= 1 || lexState < 0)
{
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
}
else
{
curLexState = lexState;
}
}
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
}
",0,False
public Token specialToken;,0,False
public int endLine;,0,False
"catch (Exception e)
",0,False
"String name = (url == null) ? fileName : url.toString();
",0,False
"staticCatalog = catalog;
",0,False
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0,False
"List<ConfigurationNode> nodes = namedNodes.remove(name);
",0,False
"return getFloat(key, new Float(defaultValue)).floatValue();
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"file = new File(fileName);
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"private Map<String, ConfigurationProvider> providers;",0,False
"parent.mkdirs();
",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
private ConfigurationNode rootNode;,0,False
"instanceId = ++counter;
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final AbstractHierarchicalFileConfiguration config;
private final String path;
private final boolean trailing;
private boolean init;
public PatternSubtreeConfigurationWrapper(AbstractHierarchicalFileConfiguration config, String path)
{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
@Override
public Object getReloadLock()
{
return config.getReloadLock();
}
@Override
public void addProperty(String key, Object value)
{
config.addProperty(makePath(key), value);
}
@Override
public void clear()
{
getConfig().clear();
}
@Override
public void clearProperty(String key)
{
config.clearProperty(makePath(key));
}
@Override
public boolean containsKey(String key)
{
return config.containsKey(makePath(key));
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
@Override
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
@Override
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
@Override
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
@Override
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
@Override
public int getInt(String key)
{
return config.getInt(makePath(key));
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return config.getKeys(makePath());
}
@Override
public Iterator<String> getKeys(String prefix)
{
return config.getKeys(makePath(prefix));
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
@Override
public List<Object> getList(String key)
{
return config.getList(makePath(key));
}
@Override
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public long getLong(String key)
{
return config.getLong(makePath(key));
}
@Override
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
@Override
public Object getProperty(String key)
{
return config.getProperty(makePath(key));
}
@Override
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public short getShort(String key)
{
return config.getShort(makePath(key));
}
@Override
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
@Override
public String getString(String key)
{
return config.getString(makePath(key));
}
@Override
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
@Override
public boolean isEmpty()
{
return getConfig().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
getConfig().setProperty(key, value);
}
@Override
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
@Override
public Node getRoot()
{
return getConfig().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
getConfig().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
getConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
@Override
public void clearTree(String key)
{
config.clearTree(makePath(key));
}
@Override
public int getMaxIndex(String key)
{
return config.getMaxIndex(makePath(key));
}
@Override
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
config.save(writer);
}
public void load(Reader reader) throws ConfigurationException
{
config.load(reader);
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return getConfig().getErrorListeners();
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
private HierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return getSubstitutor().replace(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return getSubstitutor().replace(pathPattern) + item;
",0,False
"return new Double(n.doubleValue());
",0,False
"return new Float(n.floatValue());
",0,False
"return new Integer(n.intValue());
",0,False
"catch (Exception ex)
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
"writer = new OutputStreamWriter(out);
",0,False
private NodeCombiner nodeCombiner;,0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"if (file != null && file.exists())
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
private ConfigurationNode rootNode;,0,False
"{
public void load() throws ConfigurationException
{
}
public void save() throws ConfigurationException
{
}
",0,False
"if (init)
",0,False
"private static ThreadLocal recursive = new ThreadLocal()
{
protected synchronized Object initialValue()
{
return Boolean.FALSE;
}
};
private final AbstractHierarchicalFileConfiguration config;
private final String path;
private final boolean trailing;
private boolean init;
public PatternSubtreeConfigurationWrapper(AbstractHierarchicalFileConfiguration config, String path)
{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
public void addProperty(String key, Object value)
{
config.addProperty(makePath(key), value);
}
public void clear()
{
getConfig().clear();
}
public void clearProperty(String key)
{
config.clearProperty(makePath(key));
}
public boolean containsKey(String key)
{
return config.containsKey(makePath(key));
}
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
public int getInt(String key)
{
return config.getInt(makePath(key));
}
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
public Iterator getKeys()
{
return config.getKeys(makePath());
}
public Iterator getKeys(String prefix)
{
return config.getKeys(makePath(prefix));
}
public List getList(String key, List defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
public List getList(String key)
{
return config.getList(makePath(key));
}
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
public long getLong(String key)
{
return config.getLong(makePath(key));
}
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
public Object getProperty(String key)
{
return config.getProperty(makePath(key));
}
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
public short getShort(String key)
{
return config.getShort(makePath(key));
}
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
public String getString(String key)
{
return config.getString(makePath(key));
}
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
public boolean isEmpty()
{
return getConfig().isEmpty();
}
public void setProperty(String key, Object value)
{
getConfig().setProperty(key, value);
}
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
public Node getRoot()
{
return getConfig().getRoot();
}
public void setRoot(Node node)
{
if (init)
{
getConfig().setRoot(node);
}
else
{
super.setRoot(node);
}
}
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
public void addNodes(String key, Collection nodes)
{
getConfig().addNodes(key, nodes);
}
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
public List configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
public void clearTree(String key)
{
config.clearTree(makePath(key));
}
public int getMaxIndex(String key)
{
return config.getMaxIndex(makePath(key));
}
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
public Collection getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
config.save(writer);
}
public void load(Reader reader) throws ConfigurationException
{
config.load(reader);
}
public Collection getErrorListeners()
{
return getConfig().getErrorListeners();
}
protected Object resolveContainerStore(String key)
{
if (((Boolean) recursive.get()).booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
private HierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return getSubstitutor().replace(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return getSubstitutor().replace(pathPattern) + item;
",0,False
"catch (Exception e)
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
"expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
",0,False
"return null;
",0,False
private boolean jj_semLA;,0,False
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (8 - (column & 07));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"List lst = (List) namedNodes.get(node.getName());
",0,False
"final ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"getLogger().debug(os.toString());
",0,False
"} catch (final Exception ex) {
",0,False
"return dataSource;
",0,False
private AutoSaveListener autoSaveListener;,0,False
"return new ConfigurationBuilderResultCreatedEvent(this, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED,
",0,False
"reloadingController.resetReloadingState();
",0,False
"final ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
private final NodeHandler<T> handler;,0,False
"value = array.length == 0 ? null : new Byte(array[0]);
",0,False
"value = array.length == 0 ? null : new Float(array[0]);
",0,False
"value = array.length == 0 ? null : new Short(array[0]);
",0,False
"reader = new InputStreamReader(in);
",0,False
"catch (Exception ex)
",0,False
private ConfigurationNode combinedRoot;,0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"return new Integer(n.intValue());
",0,False
"return new Long(n.longValue());
",0,False
"return new Short(n.shortValue());
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"initProperty(bean, propName, properties.get(propName));
",0,False
"getConfiguration().addProperty(name, new Float(array[i]));
",0,False
public Token currentToken;,0,False
"Node node = new Node();
String key = String();
node.setName(key);
jj_consume_token(EQUAL);
Object value = Element();
node.setValue(value);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
return node;
",0,False
"jjround = 0x80000001;
for (i = 9; i-- > 0;)
jjrounds[i] = 0x80000000;
}
",0,False
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"return(""Lexical error at line "" +
",0,False
"result = (List) namedNodes.get(name);
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
private ConfigurationSourceData sourceData;,0,False
"catch (Exception e)
",0,False
"return new Float(n.floatValue());
",0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0,False
"getLogger().debug(os.toString());
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"parent.mkdirs();
",0,False
"public class DynamicCombinedConfiguration extends CombinedConfiguration
{
private static final ThreadLocal<CurrentConfigHolder> currentConfig =
new ThreadLocal<CurrentConfigHolder>();
private final ConcurrentMap<String, CombinedConfiguration> configs =
new ConcurrentHashMap<String, CombinedConfiguration>();
private List<ConfigData> configurations = new ArrayList<ConfigData>();
private Map<String, Configuration> namedConfigurations =
new HashMap<String, Configuration>();
private String keyPattern;
private NodeCombiner nodeCombiner;
private String loggerName = DynamicCombinedConfiguration.class.getName();
private final ConfigurationInterpolator localSubst;
public DynamicCombinedConfiguration(NodeCombiner comb)
{
super();
setNodeCombiner(comb);
setLogger(LogFactory.getLog(DynamicCombinedConfiguration.class));
localSubst = initLocalInterpolator();
}
public DynamicCombinedConfiguration()
{
super();
setLogger(LogFactory.getLog(DynamicCombinedConfiguration.class));
localSubst = initLocalInterpolator();
}
public void setKeyPattern(String pattern)
{
this.keyPattern = pattern;
}
public String getKeyPattern()
{
return this.keyPattern;
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
@Override
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
@Override
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidateAll();
}
@Override
public void addConfiguration(Configuration config, String name,
String at)
{
beginWrite(true);
try
{
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
configs.clear();
}
finally
{
endWrite();
}
}
@Override
public int getNumberOfConfigurations()
{
beginRead(false);
try
{
return configurations.size();
}
finally
{
endRead();
}
}
@Override
public Configuration getConfiguration(int index)
{
beginRead(false);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
@Override
public Configuration getConfiguration(String name)
{
beginRead(false);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
@Override
public Set<String> getConfigurationNames()
{
beginRead(false);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
@Override
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
@Override
public boolean removeConfiguration(Configuration config)
{
beginWrite(false);
try
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
finally
{
endWrite();
}
}
@Override
public Configuration removeConfigurationAt(int index)
{
beginWrite(false);
try
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
return cd.getConfiguration();
}
finally
{
endWrite();
}
}
@Override
public ConfigurationNode getRootNode()
{
return getCurrentConfig().getRootNode();
}
@Override
protected void setRootNodeInternal(ConfigurationNode rootNode)
{
if (configs != null)
{
this.getCurrentConfig().setRootNode(rootNode);
}
else
{
super.setRootNodeInternal(rootNode);
}
}
@Override
protected void addPropertyInternal(String key, Object value)
{
this.getCurrentConfig().addProperty(key, value);
}
@Override
protected void clearInternal()
{
if (configs != null)
{
this.getCurrentConfig().clear();
}
}
@Override
protected void clearPropertyDirect(String key)
{
this.getCurrentConfig().clearProperty(key);
}
@Override
protected boolean containsKeyInternal(String key)
{
return this.getCurrentConfig().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getCurrentConfig().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getCurrentConfig().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getCurrentConfig().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getCurrentConfig().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getCurrentConfig().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getCurrentConfig().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getCurrentConfig().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getCurrentConfig().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getCurrentConfig().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getCurrentConfig().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getCurrentConfig().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getCurrentConfig().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getCurrentConfig().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getCurrentConfig().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getCurrentConfig().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getCurrentConfig().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getCurrentConfig().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getCurrentConfig().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getCurrentConfig().getInteger(key, defaultValue);
}
@Override
protected Iterator<String> getKeysInternal()
{
return this.getCurrentConfig().getKeys();
}
@Override
protected Iterator<String> getKeysInternal(String prefix)
{
return this.getCurrentConfig().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getCurrentConfig().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getCurrentConfig().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getCurrentConfig().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getCurrentConfig().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getCurrentConfig().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getCurrentConfig().getProperties(key);
}
@Override
protected Object getPropertyInternal(String key)
{
return this.getCurrentConfig().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getCurrentConfig().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getCurrentConfig().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getCurrentConfig().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getCurrentConfig().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getCurrentConfig().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getCurrentConfig().getStringArray(key);
}
@Override
protected boolean isEmptyInternal()
{
return this.getCurrentConfig().isEmpty();
}
@Override
protected void setPropertyInternal(String key, Object value)
{
if (configs != null)
{
this.getCurrentConfig().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getCurrentConfig().subset(prefix);
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
protected void addNodesInternal(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getCurrentConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getCurrentConfig().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getCurrentConfig().configurationAt(key);
}
@Override
public List<SubnodeConfiguration> configurationsAt(String key)
{
return this.getCurrentConfig().configurationsAt(key);
}
@Override
protected List<ConfigurationNode> clearTreeInternal(String key)
{
this.getCurrentConfig().clearTree(key);
return Collections.emptyList();
}
@Override
protected int getMaxIndexInternal(String key)
{
return this.getCurrentConfig().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getCurrentConfig().interpolatedConfiguration();
}
@Override
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
return getCurrentConfig().getSource(key);
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
for (CombinedConfiguration cc : configs.values())
{
cc.addConfigurationListener(l);
}
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
for (CombinedConfiguration cc : configs.values())
{
cc.removeConfigurationListener(l);
}
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
for (CombinedConfiguration cc : configs.values())
{
cc.clearConfigurationListeners();
}
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
for (CombinedConfiguration cc : configs.values())
{
cc.addErrorListener(l);
}
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
for (CombinedConfiguration cc : configs.values())
{
cc.removeErrorListener(l);
}
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
for (CombinedConfiguration cc : configs.values())
{
cc.clearErrorListeners();
}
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
@Override
public Object clone()
{
return super.clone();
}
@Override
public void invalidate()
{
getCurrentConfig().invalidate();
}
public void invalidateAll()
{
for (CombinedConfiguration cc : configs.values())
{
cc.invalidate();
}
}
@Override
protected void beginRead(boolean optimize)
{
CurrentConfigHolder cch = ensureCurrentConfiguration();
cch.incrementLockCount();
if (!optimize && cch.getCurrentConfiguration() == null)
{
beginWrite(optimize);
endWrite();
}
cch.getCurrentConfiguration().beginRead(optimize);
}
@Override
protected void beginWrite(boolean optimize)
{
CurrentConfigHolder cch = ensureCurrentConfiguration();
cch.incrementLockCount();
super.beginWrite(optimize);
if (!optimize && cch.getCurrentConfiguration() == null)
{
cch.setCurrentConfiguration(createChildConfiguration());
configs.put(cch.getKey(), cch.getCurrentConfiguration());
initChildConfiguration(cch.getCurrentConfiguration());
}
}
@Override
protected void endRead()
{
currentConfig.get().getCurrentConfiguration().endRead();
releaseLock();
}
@Override
protected void endWrite()
{
super.endWrite();
releaseLock();
}
private void releaseLock()
{
CurrentConfigHolder cch = currentConfig.get();
assert cch != null : ""No current configuration!"";
if(cch.decrementLockCountAndCheckRelease())
{
currentConfig.remove();
}
}
private CombinedConfiguration getCurrentConfig()
{
CombinedConfiguration config;
String key;
beginRead(false);
try
{
config = currentConfig.get().getCurrentConfiguration();
key = currentConfig.get().getKey();
}
finally
{
endRead();
}
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Returning config for "" + key + "": "" + config);
}
return config;
}
private CombinedConfiguration createChildConfiguration()
{
return new CombinedConfiguration(getNodeCombiner());
}
private void initChildConfiguration(CombinedConfiguration config)
{
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
config.setLogger(log);
}
}
config.setExpressionEngine(this.getExpressionEngine());
config.setConversionExpressionEngine(getConversionExpressionEngine());
config.setListDelimiterHandler(getListDelimiterHandler());
for (ConfigurationErrorListener listener : getErrorListeners())
{
config.addErrorListener(listener);
}
for (ConfigurationListener listener : getConfigurationListeners())
{
config.addConfigurationListener(listener);
}
for (ConfigData data : configurations)
{
config.addConfiguration(data.getConfiguration(), data.getName(),
data.getAt());
}
config.setSynchronizer(getSynchronizer());
}
private ConfigurationInterpolator initLocalInterpolator()
{
ConfigurationInterpolator ci = new ConfigurationInterpolator()
{
@Override
protected Lookup fetchLookupForPrefix(String prefix)
{
return ConfigurationInterpolator
.nullSafeLookup(getInterpolator().getLookups().get(
prefix));
}
};
return ci;
}
private CurrentConfigHolder ensureCurrentConfiguration()
{
CurrentConfigHolder cch = currentConfig.get();
if (cch == null)
{
String key = String.valueOf(localSubst.interpolate(keyPattern));
cch = new CurrentConfigHolder(key);
cch.setCurrentConfiguration(configs.get(key));
currentConfig.set(cch);
}
return cch;
",0,False
"catch (Exception ex)
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
private ReloadingController reloadingController;,0,False
"return new Short(n.shortValue());
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"public class BaseHierarchicalConfiguration extends AbstractHierarchicalConfiguration<ImmutableNode>
implements Cloneable, InMemoryNodeModelSupport
{
private final EventListener<ConfigurationEvent> changeListener;
public BaseHierarchicalConfiguration()
{
this((HierarchicalConfiguration<ImmutableNode>) null);
}
public BaseHierarchicalConfiguration(HierarchicalConfiguration<ImmutableNode> c)
{
this(createNodeModel(c));
}
protected BaseHierarchicalConfiguration(NodeModel<ImmutableNode> model)
{
super(model);
changeListener = createChangeListener();
}
@Override
public InMemoryNodeModel getNodeModel()
{
return (InMemoryNodeModel) super.getNodeModel();
}
@Override
public Configuration subset(String prefix)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(prefix);
if (results.isEmpty())
{
return new BaseHierarchicalConfiguration();
}
final BaseHierarchicalConfiguration parent = this;
BaseHierarchicalConfiguration result =
new BaseHierarchicalConfiguration()
{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
}
};
result.getModel().setRootNode(createSubsetRootNode(results));
if (result.isEmpty())
{
return new BaseHierarchicalConfiguration();
}
else
{
result.setSynchronizer(getSynchronizer());
return result;
}
}
finally
{
endRead();
}
}
private ImmutableNode createSubsetRootNode(
Collection<QueryResult<ImmutableNode>> results)
{
ImmutableNode.Builder builder = new ImmutableNode.Builder();
Object value = null;
int valueCount = 0;
for (QueryResult<ImmutableNode> result : results)
{
if (result.isAttributeResult())
{
builder.addAttribute(result.getAttributeName(),
result.getAttributeValue(getModel().getNodeHandler()));
}
else
{
if (result.getNode().getValue() != null)
{
value = result.getNode().getValue();
valueCount++;
}
builder.addChildren(result.getNode().getChildren());
builder.addAttributes(result.getNode().getAttributes());
}
}
if (valueCount == 1)
{
builder.value(value);
}
return builder.create();
}
public HierarchicalConfiguration<ImmutableNode> configurationAt(String key,
boolean supportUpdates)
{
beginRead(false);
try
{
return supportUpdates ? createConnectedSubConfiguration(key)
: createIndependentSubConfiguration(key);
}
finally
{
endRead();
}
}
protected InMemoryNodeModel getSubConfigurationParentModel()
{
return (InMemoryNodeModel) getModel();
}
protected NodeSelector getSubConfigurationNodeSelector(String key)
{
return new NodeSelector(key);
}
protected SubnodeConfiguration createSubConfigurationForTrackedNode(
NodeSelector selector, InMemoryNodeModelSupport parentModelSupport)
{
SubnodeConfiguration subConfig =
new SubnodeConfiguration(this, new TrackedNodeModel(
parentModelSupport, selector, true));
initSubConfigurationForThisParent(subConfig);
return subConfig;
}
protected void initSubConfigurationForThisParent(SubnodeConfiguration subConfig)
{
initSubConfiguration(subConfig);
subConfig.addEventListener(ConfigurationEvent.ANY, changeListener);
}
private BaseHierarchicalConfiguration createConnectedSubConfiguration(
String key)
{
NodeSelector selector = getSubConfigurationNodeSelector(key);
getSubConfigurationParentModel().trackNode(selector, this);
return createSubConfigurationForTrackedNode(selector, this);
}
private List<HierarchicalConfiguration<ImmutableNode>> createConnectedSubConfigurations(
InMemoryNodeModelSupport parentModelSupport,
Collection<NodeSelector> selectors)
{
List<HierarchicalConfiguration<ImmutableNode>> configs =
new ArrayList<HierarchicalConfiguration<ImmutableNode>>(
selectors.size());
for (NodeSelector selector : selectors)
{
configs.add(createSubConfigurationForTrackedNode(selector,
parentModelSupport));
}
return configs;
}
private BaseHierarchicalConfiguration createIndependentSubConfiguration(
String key)
{
List<ImmutableNode> targetNodes = fetchFilteredNodeResults(key);
if (targetNodes.size() != 1)
{
throw new ConfigurationRuntimeException(
""Passed in key must select exactly one node: "" + key);
}
BaseHierarchicalConfiguration sub =
new BaseHierarchicalConfiguration(new InMemoryNodeModel(
targetNodes.get(0)));
initSubConfiguration(sub);
return sub;
}
private BaseHierarchicalConfiguration createIndependentSubConfigurationForNode(
ImmutableNode node)
{
BaseHierarchicalConfiguration sub =
new BaseHierarchicalConfiguration(new InMemoryNodeModel(node));
initSubConfiguration(sub);
return sub;
}
private List<ImmutableNode> fetchFilteredNodeResults(String key)
{
NodeHandler<ImmutableNode> handler = getModel().getNodeHandler();
return resolveNodeKey(handler.getRootNode(), key, handler);
}
public ImmutableHierarchicalConfiguration immutableConfigurationAt(
String key, boolean supportUpdates)
{
return ConfigurationUtils.unmodifiableConfiguration(configurationAt(
key, supportUpdates));
}
public HierarchicalConfiguration<ImmutableNode> configurationAt(String key)
{
return configurationAt(key, false);
}
public ImmutableHierarchicalConfiguration immutableConfigurationAt(
String key)
{
return ConfigurationUtils.unmodifiableConfiguration(configurationAt(
key));
}
public List<HierarchicalConfiguration<ImmutableNode>> configurationsAt(
String key)
{
List<ImmutableNode> nodes;
beginRead(false);
try
{
nodes = fetchFilteredNodeResults(key);
}
finally
{
endRead();
}
List<HierarchicalConfiguration<ImmutableNode>> results =
new ArrayList<HierarchicalConfiguration<ImmutableNode>>(
nodes.size());
for (ImmutableNode node : nodes)
{
BaseHierarchicalConfiguration sub =
createIndependentSubConfigurationForNode(node);
results.add(sub);
}
return results;
}
public List<HierarchicalConfiguration<ImmutableNode>> configurationsAt(
String key, boolean supportUpdates)
{
if (!supportUpdates)
{
return configurationsAt(key);
}
InMemoryNodeModel parentModel;
beginRead(false);
try
{
parentModel = getSubConfigurationParentModel();
}
finally
{
endRead();
}
Collection<NodeSelector> selectors =
parentModel.selectAndTrackNodes(key, this);
return createConnectedSubConfigurations(this, selectors);
}
public List<ImmutableHierarchicalConfiguration> immutableConfigurationsAt(
String key)
{
return toImmutable(configurationsAt(key));
}
public List<HierarchicalConfiguration<ImmutableNode>> childConfigurationsAt(
String key)
{
List<ImmutableNode> nodes;
beginRead(false);
try
{
nodes = fetchFilteredNodeResults(key);
}
finally
{
endRead();
}
if (nodes.size() != 1)
{
return Collections.emptyList();
}
ImmutableNode parent = nodes.get(0);
List<HierarchicalConfiguration<ImmutableNode>> subs =
new ArrayList<HierarchicalConfiguration<ImmutableNode>>(parent
.getChildren().size());
for (ImmutableNode node : parent.getChildren())
{
subs.add(createIndependentSubConfigurationForNode(node));
}
return subs;
}
public List<HierarchicalConfiguration<ImmutableNode>> childConfigurationsAt(
String key, boolean supportUpdates)
{
if (!supportUpdates)
{
return childConfigurationsAt(key);
}
InMemoryNodeModel parentModel = getSubConfigurationParentModel();
return createConnectedSubConfigurations(this,
parentModel.trackChildNodes(key, this));
}
public List<ImmutableHierarchicalConfiguration> immutableChildConfigurationsAt(
String key)
{
return toImmutable(childConfigurationsAt(key));
}
protected void subnodeConfigurationChanged(ConfigurationEvent event)
{
fireEvent(ConfigurationEvent.SUBNODE_CHANGED, null, event, event.isBeforeUpdate());
}
private void initSubConfiguration(BaseHierarchicalConfiguration sub)
{
sub.setSynchronizer(getSynchronizer());
sub.setExpressionEngine(getExpressionEngine());
sub.setListDelimiterHandler(getListDelimiterHandler());
sub.setThrowExceptionOnMissing(isThrowExceptionOnMissing());
sub.getInterpolator().setParentInterpolator(getInterpolator());
}
private EventListener<ConfigurationEvent> createChangeListener()
{
return new EventListener<ConfigurationEvent>()
{
@Override
public void onEvent(ConfigurationEvent event)
{
subnodeConfigurationChanged(event);
}
};
}
@Override
public Configuration interpolatedConfiguration()
{
InterpolatedVisitor visitor = new InterpolatedVisitor();
NodeHandler<ImmutableNode> handler = getModel().getNodeHandler();
NodeTreeWalker.INSTANCE
.walkDFS(handler.getRootNode(), visitor, handler);
BaseHierarchicalConfiguration c =
(BaseHierarchicalConfiguration) clone();
c.getNodeModel().setRootNode(visitor.getInterpolatedRoot());
return c;
}
@Override
protected NodeModel<ImmutableNode> cloneNodeModel()
{
return new InMemoryNodeModel(getModel().getNodeHandler().getRootNode());
}
private static List<ImmutableHierarchicalConfiguration> toImmutable(
List<? extends HierarchicalConfiguration<?>> subs)
{
List<ImmutableHierarchicalConfiguration> res =
new ArrayList<ImmutableHierarchicalConfiguration>(subs.size());
for (HierarchicalConfiguration<?> sub : subs)
{
res.add(ConfigurationUtils.unmodifiableConfiguration(sub));
}
return res;
}
private static NodeModel<ImmutableNode> createNodeModel(
HierarchicalConfiguration<ImmutableNode> c)
{
ImmutableNode root = (c != null) ? obtainRootNode(c) : null;
return new InMemoryNodeModel(root);
}
private static ImmutableNode obtainRootNode(
HierarchicalConfiguration<ImmutableNode> c)
{
return c.getNodeModel().getNodeHandler().getRootNode();
",0,False
"ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"catch (Exception e)
",0,False
"return new Double(n.doubleValue());
",0,False
"staticCatalog = catalog;
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if(optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"getLogger().debug(os.toString());
",0,False
"catch (Exception ex)
",0,False
private AutoSaveListener autoSaveListener;,0,False
"return new Short(n.shortValue());
",0,False
private final String protocol;,0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"} catch (final Exception ex) {
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
private final String protocol;,0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
private final ConversionHandler dataConversionHandler;,0,False
private ReloadingController reloadingController;,0,False
"return new Byte(n.byteValue());
",0,False
"return new Short(n.shortValue());
",0,False
"return new Long(n.longValue());
",0,False
private final String protocol;,0,False
"catch (Exception e)
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0,False
private ConfigurationNode node;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"catch (Exception e)
",0,False
"{
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
"Token token = null;
String value = null;
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
{if (true) return unescapeQuotes(removeQuotes(token.image));}
break;
case STRING:
token = jj_consume_token(STRING);
{if (true) return token.image;}
break;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (8 - (column & 07));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0,False
public Token specialToken;,0,False
"return(""Lexical error at line "" +
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"value = array.length == 0 ? null : new Integer(array[0]);
",0,False
"value = array.length == 0 ? null : new Float(array[0]);
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"return new Integer(n.intValue());
",0,False
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_BEGIN:
case DICT_BEGIN:
case DATA:
case STRING:
case QUOTED_STRING:
element = Element();
list.add(element);
label_2:
while (true)
{
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(ARRAY_SEPARATOR);
element = Element();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
return list;
",0,False
"if ((jjbitVec0[i2] & l2) == 0L)
break;
if (kind > 19)
kind = 19;
jjCheckNAdd(3);
break;
",0,False
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
private ConfigurationNode node;,0,False
"catch (Exception e)
",0,False
private final String protocol;,0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
private List<ConfigData> configurations;,0,False
"dump(configuration, new PrintWriter(out));
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0,False
"if (configs != null)
",0,False
private ConfigurationNode rootNode;,0,False
"{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
",0,False
"if (init)
",0,False
"configurationsMap.putIfAbsent(pattern, configuration);
",0,False
"if (init)
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"catch (Exception e)
",0,False
"catch (Exception e)
",0,False
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0,False
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0,False
"String name = (url == null) ? fileName : url.toString();
",0,False
"List<ConfigurationNode> lst = namedNodes.get(node.getName());
",0,False
"{
@Override
protected Object interpolate(final Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
"reloadingController.resetReloadingState();
",0,False
"catch (final Exception e)
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"return src != null ? src.clone() : null;
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"catch (Exception ex)
",0,False
"configurationsMap.putIfAbsent(pattern, configuration);
",0,False
"if (init)
",0,False
"if (!init)
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"public class ConfigurationNodeHandler extends AbstractNodeHandler<ConfigurationNode>
implements NodeHandler<ConfigurationNode>
{
public ConfigurationNode addChild(ConfigurationNode node, String name)
{
ConfigurationNode child = createNode(node, name);
node.addChild(child);
return child;
}
public Object getAttributeValue(ConfigurationNode node, String name)
{
List<ConfigurationNode> attrs = node.getAttributes(name);
if (attrs.isEmpty())
{
return null;
}
else if (attrs.size() == 1)
{
return attrs.get(0).getValue();
}
else
{
List<Object> result = new ArrayList<Object>(attrs.size());
for (ConfigurationNode attr : attrs)
{
result.add(attr.getValue());
}
return result;
}
}
public List<String> getAttributes(ConfigurationNode node)
{
List<ConfigurationNode> attrs = node.getAttributes();
assert attrs != null : ""Attribute list is null"";
List<String> names = new ArrayList<String>(attrs.size());
for (ConfigurationNode n : attrs)
{
names.add(n.getName());
}
return names;
}
@Override
public boolean hasAttributes(ConfigurationNode node)
{
return !node.getAttributes().isEmpty();
}
public ConfigurationNode getChild(ConfigurationNode node, int index)
{
return node.getChild(index);
}
public List<ConfigurationNode> getChildren(ConfigurationNode node)
{
return node.getChildren();
}
public List<ConfigurationNode> getChildren(ConfigurationNode node,
String name)
{
return node.getChildren(name);
}
public ConfigurationNode getParent(ConfigurationNode node)
{
return node.getParentNode();
}
public Object getValue(ConfigurationNode node)
{
return node.getValue();
}
public String nodeName(ConfigurationNode node)
{
return node.getName();
}
public void setAttributeValue(ConfigurationNode node, String name,
Object value)
{
node.removeAttribute(name);
addAttributeValue(node, name, value);
}
public void addAttributeValue(ConfigurationNode node, String name,
Object value)
{
ConfigurationNode attr = createNode(node, name);
attr.setValue(value);
node.addAttribute(attr);
}
public void setValue(ConfigurationNode node, Object value)
{
node.setValue(value);
}
protected ConfigurationNode createNode(ConfigurationNode parent, String name)
{
ConfigurationNode node = new DefaultConfigurationNode(name);
node.setParentNode(parent);
return node;
}
public void removeAttribute(ConfigurationNode node, String name)
{
node.removeAttribute(name);
}
public void removeChild(ConfigurationNode node, ConfigurationNode child)
{
node.removeChild(child);
}
public int getChildrenCount(ConfigurationNode node, String name)
{
return node.getChildrenCount(name);
",0,False
"if (fileName.startsWith(""."" + File.separator))
",0,False
"catch (Exception ex)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"catch (Exception ex)
",0,False
"List children = new ArrayList();
ConfigurationNode child = null;
jj_consume_token(OBJECT_BEGIN);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
child = Property();
if (child != null) children.add(child);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case LIST_SEPARATOR:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
jj_consume_token(LIST_SEPARATOR);
child = Property();
if (child != null) children.add(child);
}
break;
default:
jj_la1[1] = jj_gen;
;
}
jj_consume_token(OBJECT_END);
JSONConfiguration configuration = new JSONConfiguration();
ConfigurationNode root = configuration.getRootNode();
for (int i = 0; i < children.size(); i++)
{
child = (ConfigurationNode) children.get(i);
root.addChild(child);
}
{if (true) return configuration;}
",0,False
"token = jj_consume_token(TRUE);
",0,False
"jjround = 0x80000001;
for (i = 31; i-- > 0;)
jjrounds[i] = 0x80000000;
}
",0,False
public Token currentToken;,0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
}
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0,False
"token = jj_consume_token(DATA);
{if (true) return filterData(token.image);}
",0,False
"String key = null;
Object value = null;
ConfigurationNode node = new DefaultConfigurationNode();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{if (true) return node;}
",0,False
"token = jj_consume_token(DATE);
{if (true) return parseDate(token.image);}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
",0,False
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0,False
"ReInit(dstream, encoding, startline, startcolumn, 4096);
}
",0,False
public Token specialToken;,0,False
"catch (Exception e)
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<>();
namedConfigurations = new HashMap<>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"return dataSource;
",0,False
"catch (Exception e)
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"return statement.executeUpdate(sql, autoGeneratedKeys);
",0,False
"return connection.prepareStatement(sql);
",0,False
public static final Set<String> DISCONNECTION_SQL_CODES;,0,False
"} catch (final Exception e) {
",0,False
"return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql));
",0,False
"xaConnection.addConnectionEventListener(new ConnectionEventListener() {
@Override
public void connectionClosed(final ConnectionEvent event) {
final PooledConnection pc = (PooledConnection) event.getSource();
pc.removeConnectionEventListener(this);
try {
pc.close();
} catch (final SQLException e) {
System.err.println(""Failed to close XAConnection"");
e.printStackTrace();
}
}
@Override
public void connectionErrorOccurred(final ConnectionEvent event) {
connectionClosed(event);
}
",0,False
"connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)));
",0,False
"protected static final HashMap<String, ObjectPool<? extends Connection>> pools = new HashMap<>();",0,False
"return value != null ? value.toCharArray() : null;
",0,False
"pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency));
",0,False
"} catch (final Exception ignored) {
",0,False
"closeDueToException(info);
",0,False
"stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append("" You have set value of \"""")
",1,False
"connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)));
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception ignored) {
",1,False
"return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, autoGeneratedKeys));
",0,False
"} catch (final Exception ignored) {
",1,False
"return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue(),
",0,False
"connection.prepareStatement(sql, autoGeneratedKeys));
",0,False
"return statement.executeLargeUpdate(sql, columnNames);
",0,False
"} catch (final Exception ignored) {
",0,False
"return statement.execute(sql);
",0,False
"return connection.prepareStatement(sql);
",0,False
"return statement.execute(sql, columnIndexes);
",0,False
"stmt.execute(sql);
",1,False
"return columnIndexes;
",1,False
"return connection.prepareStatement(sql, columnNames);
",0,False
"return statement.execute(sql, autoGeneratedKeys);
",0,False
"connection.prepareStatement(sql, columnNames));
",0,False
"return statement.executeLargeUpdate(sql);
",0,False
"if (!this.currentXid.equals(xid)) {
",0,False
"return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
",0,False
"connection.prepareStatement(sql, resultSetType, resultSetConcurrency)));
",0,False
"return null;
",0,False
"return ( null );
",0,False
private final List<ErrorMessage> errors;,0,False
"return ( null );
",0,False
"return ( null );
",0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"} catch (Exception ex){
",0,False
"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
private FromXmlRuleSet ruleSet;,0,False
"if ( paramTypes.length == 0 )
",0,False
"return ( null );
",0,False
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0,False
"{
@Override
protected void loadRules()
{
loadXMLRules( xmlRulesResource );
}
",0,False
"if (paramTypes.length == 0) {
",0,False
"} catch (Exception e) {
",0,False
private String currChildNamespaceURI = null;,0,False
"this.annotations = annotations;
",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"} catch (Exception ex){
",0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"Formatter formatter = new Formatter(""[CallMethodRule]"");
",0,False
"Object paramValues[] = new Object[paramTypes.length];
",0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0,False
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"if (paramTypes.length == 0) {
",0,False
"protected String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
protected static float version;,0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0,False
private final List<ErrorMessage> errors;,0,False
"if ( paramTypes.length == 0 )
",0,False
"|| rulesBinder.isAlreadyBound( type ) )
",0,False
"rulesBinder.addError( e );
",0,False
protected String namespaceURI = null;,0,False
"version = new Float( versionNumber ).floatValue();
",0,False
"} catch (Exception ex){
",0,False
protected static float version;,0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"if (paramTypes.length == 0) {
",0,False
"new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
",0,False
private final float loadFactor = 0.75f;,0,False
"} catch (Exception ex){
",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"Formatter formatter = new Formatter(""[CallMethodRule]"");
",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
protected static float version;,0,False
protected static String versionNumber = null;,0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"if (paramTypes.length == 0) {
",0,False
"version = new Float( versionNumber ).floatValue();
",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"return ( null );
",0,False
"rulesBinder.addError( e );
",0,False
"return updated;
",0,False
"final FileWriter out = new FileWriter( dest );
",0,False
"final FileReader inRaw = new FileReader( source );
",0,False
"pw = new PrintWriter( stream );
",0,False
"if ( paramTypes.length == 0 )
",0,False
"String address = emails.get( type );
",0,False
"return new java.io.StringReader( baos.toString() );
",0,False
"return updated;
",0,False
"BufferedReader in = new BufferedReader( inRaw );
",0,False
"catch ( Exception e )
",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"private final Map<Class<?>, FromAnnotationsRuleSet> data = new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
}
};",0,False
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"if ( paramTypes.length == 0 )
",0,False
"return ( null );
",0,False
"return ( null );
",0,False
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0,False
"invokeExactMethod( parent, methodName, new Object[] { child }, paramTypes );
",0,False
"return ( null );
",0,False
"return ( null );
",0,False
"return ( null );
",0,False
"this.annotations = annotations;
",0,False
"return ( null );
",0,False
"{
public Field[] run()
{
return type.getDeclaredFields();
",0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
protected static String versionNumber = null;,0,False
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"rulesBinder.addError( e );
",0,False
"return null;
",0,False
private String currChildNamespaceURI = null;,1,False
"if (keyPattern == null) {
return provider;
}
List<RuleProvider<? extends Rule>> providerLits = providers.get(keyPattern);
if (providerLits == null) {
providerLits = new ArrayList<RuleProvider<? extends Rule>>();
providers.put(keyPattern, providerLits);
}
providerLits.add(provider);
return provider;
",1,False
"invokeExactMethod( parent, methodName, new Object[] { child }, paramTypes );
",0,False
"this.rulesBinder.addError( messagePattern, arguments );
",0,False
private final List<ErrorMessage> errors;,1,False
"this.annotations = annotations;
",1,False
private ClassLoader classLoader;,1,False
"public static String DFLT_METHOD_ATTR = ""method"";",1,False
"throw new SAXException( format( ""[ObjectCreateRule]{%s} Class '%s' does not have a construcor with types"",
",0,False
"header += "" "" + headerPart.substring(nonWs, end);
",1,False
"String nameLower = name.toLowerCase();
",0,False
"return cachedContent;
",1,False
"&& pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
",1,False
"this.chars = charArray;
",1,False
"headerValue += "","" + iter2.next();
",1,False
"return new String(new byte[0]);
",1,False
protected int lineLength;,1,False
protected int deferredWhitespace = 0;,1,False
"return new String(rawdata);
",0,False
"return cachedContent;
",1,False
"return null;
",1,False
"return cachedContent;
",1,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"boundary = boundaryStr.getBytes(); 
",1,False
"byte[] rawdata = new byte[0];
",0,False
"if (!""post"".equals(request.getMethod().toLowerCase())) {
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"skip(av);
",0,False
"headers = baos.toString();
",0,False
"fis.read(fileData);
",0,False
"String nameLower = name.toLowerCase();
",0,False
"String nameLower = name.toLowerCase();
",0,False
"paramName = paramName.toLowerCase();
",0,False
"fis.read(fileData);
",0,False
"outputFile.delete();
",0,False
"outputFile.delete();
",0,False
"return baos.toString();
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"boundary = boundaryStr.getBytes();
",0,False
".trim().toLowerCase();
",0,False
"return (String) headers.get(name.toLowerCase());
",0,False
"this(null, null, null);
",0,False
"outputFile.delete();
",0,False
"fis.read(fileData);
",0,False
"dfosFile.delete();
",0,False
"String cdl = cd.toLowerCase();
",0,False
"skip(av);
",0,False
"private static final String UID =
new java.rmi.server.UID().toString()
.replace(':', '_').replace('-', '_');
private static int counter = 0;
private String fieldName;
private String contentType;
private boolean isFormField;
private String fileName;
private long size = -1;
private int sizeThreshold;
private File repository;
private byte[] cachedContent;
private transient DeferredFileOutputStream dfos;
private File dfosFile;
public DiskFileItem(String fieldName, String contentType,
boolean isFormField, String fileName, int sizeThreshold,
File repository) {
this.fieldName = fieldName;
this.contentType = contentType;
this.isFormField = isFormField;
this.fileName = fileName;
this.sizeThreshold = sizeThreshold;
this.repository = repository;
}
public InputStream getInputStream()
throws IOException {
if (!isInMemory()) {
return new FileInputStream(dfos.getFile());
}
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return new ByteArrayInputStream(cachedContent);
}
public String getContentType() {
return contentType;
}
public String getCharSet() {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(getContentType(), ';');
return (String) params.get(""charset"");
}
public String getName() {
return fileName;
}
public boolean isInMemory() {
if (cachedContent != null) {
return true;
}
return dfos.isInMemory();
}
public long getSize() {
if (size >= 0) {
return size;
} else if (cachedContent != null) {
return cachedContent.length;
} else if (dfos.isInMemory()) {
return dfos.getData().length;
} else {
return dfos.getFile().length();
}
}
public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}
public String getString(final String charset)
throws UnsupportedEncodingException {
return new String(get(), charset);
}
public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}
public void write(File file) throws Exception {
if (isInMemory()) {
FileOutputStream fout = null;
try {
fout = new FileOutputStream(file);
fout.write(get());
} finally {
if (fout != null) {
fout.close();
}
}
} else {
File outputFile = getStoreLocation();
if (outputFile != null) {
size = outputFile.length();
if (!outputFile.renameTo(file)) {
BufferedInputStream in = null;
BufferedOutputStream out = null;
try {
in = new BufferedInputStream(
new FileInputStream(outputFile));
out = new BufferedOutputStream(
new FileOutputStream(file));
IOUtils.copy(in, out);
} finally {
if (in != null) {
try {
in.close();
} catch (IOException e) {
}
}
if (out != null) {
try {
out.close();
} catch (IOException e) {
}
}
}
}
} else {
throw new FileUploadException(
""Cannot write uploaded file to disk!"");
}
}
}
public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
public String getFieldName() {
return fieldName;
}
public void setFieldName(String fieldName) {
this.fieldName = fieldName;
}
public boolean isFormField() {
return isFormField;
}
public void setFormField(boolean state) {
isFormField = state;
}
public OutputStream getOutputStream()
throws IOException {
if (dfos == null) {
File outputFile = getTempFile();
dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);
}
return dfos;
}
public File getStoreLocation() {
return dfos.getFile();
}
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
protected File getTempFile() {
File tempDir = repository;
if (tempDir == null) {
tempDir = new File(System.getProperty(""java.io.tmpdir""));
}
String tempFileName = ""upload_"" + UID + ""_"" + getUniqueId() + "".tmp"";
File f = new File(tempDir, tempFileName);
FileCleaner.track(f, this);
return f;
}
private static String getUniqueId() {
final int limit = 100000000;
int current;
synchronized (DiskFileItem.class) {
current = counter++;
}
String id = Integer.toString(current);
if (current < limit) {
id = (""00000000"" + id).substring(id.length());
}
return id;
}
public String toString() {
return ""name="" + this.getName()
+ "", StoreLocation=""
+ String.valueOf(this.getStoreLocation())
+ "", size=""
+ this.getSize()
+ ""bytes, ""
+ ""isFormField="" + isFormField()
+ "", FieldName=""
+ this.getFieldName();
}
private void writeObject(ObjectOutputStream out) throws IOException {
if (dfos.isInMemory()) {
cachedContent = get();
} else {
cachedContent = null;
dfosFile = dfos.getFile();
}
out.defaultWriteObject();
}
private void readObject(ObjectInputStream in)
throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}
",0,False
"return baos.toString();
",0,False
"if (contentType.toLowerCase().startsWith(MULTIPART)) {
",0,False
private boolean opened;,0,False
"return (String) headers.get(name.toLowerCase());
",0,False
"if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
",0,False
"this(null, null, null);
",0,False
"&&  subContentType.toLowerCase()
",0,False
"String cdl = pContentDisposition.toLowerCase();
",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"skip(av);
",0,False
"this.chars = chars;
",0,False
"return cachedContent;
",0,False
"return new String(rawdata);
",0,False
"fis.read(fileData);
",0,False
"outputFile.delete();
",0,False
"return null;
",0,False
"&&  subContentType.toLowerCase()
",0,False
"outputFile.delete();
",0,False
"if (!""post"".equals(request.getMethod().toLowerCase())) {
",0,False
"String nameLower = name.toLowerCase();
",0,False
"return baos.toString();
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
",0,False
private boolean opened;,0,False
"return null;
",0,False
"skip(av);
",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"return new String(rawdata);
",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"headers = baos.toString();
",0,False
"this(null, null, null);
",0,False
"dfosFile.delete();
",0,False
"while (iter2.hasNext()) {
",0,False
"while (iter2.hasNext()) {
",0,False
"if (pContentDisposition != null) {
",0,False
"}
",0,False
"av = makeAvailable();
",0,False
"paramName = paramName.toLowerCase();
",0,False
"return null;
",0,False
"return baos.toString();
",0,False
"boundary = boundaryStr.getBytes();
",0,False
"return null;
",0,False
"headers = baos.toString();
",0,False
"fis.read(fileData);
",0,False
"outputFile.delete();
",0,False
"return new String(rawdata);
",0,False
"String nameLower = name.toLowerCase();
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"&&  subContentType.toLowerCase()
",0,False
"this(null, null, null);
",0,False
"paramName = paramName.toLowerCase();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"boundary = boundaryStr.getBytes(); 
",0,False
private boolean opened;,0,False
"return baos.toString();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"this.chars = chars;
",0,False
"return baos.toString();
",0,False
private boolean opened;,0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"headers = baos.toString();
",0,False
"skip(av);
",0,False
"return baos.toString();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"fis.read(fileData);
",0,False
"outputFile.delete();
",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"dfosFile.delete();
",0,False
"return new String(rawdata);
",0,False
private boolean opened;,0,False
"return new String(rawdata);
",0,False
"dfosFile.delete();
",0,False
"outputFile.delete();
",0,False
"String charset = word.substring(2, charsetPos).toLowerCase();
",0,False
protected File outputFile;,0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
"Writer w = new BufferedWriter( new FileWriter( out ) );
",0,False
"out.getParentFile().mkdirs();
",0,False
"projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
",0,False
"TreeTokens treeTokens = toTreeTokens( tokens );
",0,False
private ArtifactRepositoryFactory artifactRepositoryManager;,0,False
"outputWriter = new FileWriter( outputFile );
",0,False
"marker.createNewFile();
",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"clearMarker.delete();
",0,False
"filter.addFilter( new ProjectTransitivityFilter( project.getDependencyArtifacts(), this.excludeTransitive ) );
",0,False
public boolean silent;,0,False
"catch ( Exception e )
",0,False
private File cpFile;,0,False
"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
",0,False
boolean outputFilterFile;,0,False
"public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
private boolean stripVersion = false;
private String prefix;
private File cpFile;
private File outputFile;
private boolean regenerateFile;
private String fileSeparator;
private String pathSeparator;
private String localRepoProperty;
boolean attach;
boolean outputFilterFile;
private MavenProjectHelper projectHelper;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
public void execute()
throws MojoExecutionException
{
if ( cpFile != null )
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<Artifact>( artifacts );
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuffer sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
Writer w = null;
try
{
w = new BufferedWriter( new FileWriter( out ) );
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': ""
+ ex.toString(), ex );
}
finally
{
IOUtil.close( w );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = null;
try
{
r = new BufferedReader( new FileReader( outputFile ) );
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
IOUtil.close( r );
}
}
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
",0,False
"deleteTarget.delete();
",0,False
"if ( parent.list().length < 2 )
",0,False
protected MavenProject project;,0,False
"UnArchiver unArchiver;
",0,False
"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
",0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
"message += ""  "" + missingArtifact.getId() + ""\n"";
",0,False
"if ( parent.list().length < 2 )
",0,False
private boolean excludeTransitive;,0,False
"marker.createNewFile();
",0,False
"marker.createNewFile();
",0,False
"catch ( Exception e )
",0,False
"location.mkdirs();
",0,False
"out.getParentFile().mkdirs();
",0,False
"@Parameter
protected boolean ignorePermissions;",0,False
"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"outputWriter = new FileWriter( outputFile );
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"if ( artifact != null )
",0,False
"return this.fileMappers;
",0,False
"return this.fileMappers;
",0,False
"this.fileMappers = fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
",0,False
"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
",0,False
"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
",0,False
"this.fileMappers = fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"if ( plugins == null || plugins.isEmpty() )
",0,False
"marker.createNewFile();
",0,False
"this.fileMappers = fileMappers;
",0,False
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"marker.getParentFile().mkdirs();
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"return this.fileMappers;
",0,False
"if ( plugins == null || plugins.isEmpty() )
",0,False
"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
",0,False
public boolean silent;,0,False
"catch ( Exception e )
",0,False
"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
",0,False
"ProjectDependencyAnalysis analysis = analyzer.analyze( project );
",0,False
"logArtifacts( usedUndeclared, true );
",0,False
private MavenProject project;,0,False
"else if ( arg2 == null )
",0,False
"if ( parent.list().length < 2 )
",0,False
protected boolean outputScope;,0,False
"marker.createNewFile();
",0,False
"clearMarker.delete();
",0,False
"catch ( Exception e )
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return Objects.equals( cpString, oldCp );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out,
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
",0,False
"out.getParentFile().mkdirs();
",0,False
"return this.fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
",0,False
"message += ""  "" + missingArtifact.getId() + ""\n"";
",0,False
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0,False
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"return this.fileMappers;
",0,False
"this.fileMappers = fileMappers;
",0,False
"if ( plugins == null || plugins.isEmpty() )
",0,False
"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
",0,False
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0,False
"catch ( Exception e )
",0,False
"}
",0,False
"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.getLocal() );
",0,False
"projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
",0,False
"installer.install( artifact.getFile(), artifact, targetRepository );
",0,False
"ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(
",0,False
protected MavenProject project;,0,False
"project.getProperties().setProperty( artifact.getDependencyConflictId(),
",0,False
"outputFile.getParentFile().mkdirs();
",0,False
"writer = new FileWriter( file, append );
",0,False
"file.getParentFile().mkdirs();
",0,False
"marker.setLastModified( ts );
",0,False
"if (silent)
",0,False
protected boolean useSubDirectoryPerArtifact;,0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
protected boolean overWriteReleases;,0,False
protected boolean overWriteSnapshots;,0,False
private String groupId;,0,False
private List remotePluginRepositories;,0,False
"markerFile.createNewFile();
",0,False
"log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext())
{
Artifact artifact = (Artifact) iter.next();
log.debug(""""+artifact);
}
}
",0,False
"catch ( Exception e )
",0,False
"if ( artifact != null )
",0,False
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"return this.fileMappers;
",0,False
"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
",0,False
"file.getParentFile().mkdirs();
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"return this.fileMappers;
",0,False
"this.fileMappers = fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"private class ModuleDescriptor
{
String name;
boolean automatic = true;
",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"catch ( Exception e )
",0,False
private Renderer siteRenderer;,0,False
"if ( ""pom"".equals( project.getPackaging() ) )
",0,False
"else if ( arg2 == null )
",0,False
"out.getParentFile().mkdirs();
",0,False
"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
",0,False
private boolean excludeTransitive;,0,False
"marker.createNewFile();
",0,False
"clearMarker.delete();
",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"catch ( Exception e )
",0,False
"location.mkdirs();
",0,False
"return this.fileMappers;
",0,False
"return this.fileMappers;
",0,False
"private class ModuleDescriptor
{
String name;
boolean automatic = true;
",0,False
"if ( plugins == null || plugins.isEmpty() )
",0,False
"marker.createNewFile();
",0,False
"catch ( Exception e )
",0,False
"w = new BufferedWriter( new FileWriter( out ) );
",0,False
"out.getParentFile().mkdirs();
",0,False
"clearMarker.delete();
",0,False
"marker.createNewFile();
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"this.fileMappers = fileMappers;
",0,False
"file.getParentFile().mkdirs();
",0,False
"else
",0,False
"marker.getParentFile().mkdirs();
",0,False
"catch ( Exception e )
",0,False
"return this.fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"this.fileMappers = fileMappers;
",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"this.fileMappers = fileMappers;
",0,False
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0,False
"file.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"location.mkdirs();
",0,False
"message += ""  "" + missingArtifact.getId() + ""\n"";
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"marker.getParentFile().mkdirs();
",0,False
"clearMarker.delete();
",0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
protected File outputDirectory;,0,False
"if ( artifact != null )
",0,False
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"return this.fileMappers;
",0,False
"if ( plugins == null || plugins.isEmpty() )
",0,False
"marker.getParentFile().mkdirs();
",0,False
"else if ( arg1 == null )
",0,False
"model = pomReader.read( new FileReader( project.getFile() ) );
",1,False
"try ( BufferedReader r = new BufferedReader( new FileReader( outputFile ) ) )
",1,False
"model = pomReader.read( new FileReader( project.getFile() ) );
",1,False
"return recommendedVersion.compareTo( theVersion ) <= 0;
",0,False
"@Parameter(property = ""mdep.prependGroupId"", defaultValue = ""false"")
private final boolean prependGroupId = false;",0,False
"Dependency depMgtDependency = (Dependency) mismatch.get( resolvedArtifact );
",1,False
private String includes;,0,False
"file.getParentFile().mkdirs();
",0,False
"try ( Writer w = new BufferedWriter( new FileWriter( out ) ) )
",1,False
"Artifact newArtifact = factory.createArtifactWithClassifier( artifact.getGroupId(), artifact
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"createCommandSupport();
",0,False
"return null;
",0,False
"return null;
",0,False
"idTable = null;
",0,False
"return null;
",0,False
"aytMonitor.wait(timeout);
",0,False
"__queue.wait(100);
",0,False
"__receiveState = _STATE_DATA;
break; 
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"return null;
",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"return null;
",0,False
"return null;
",0,False
"pointer.articleId = tokens[i++];
",0,False
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0,False
"ThreadContainer c = idTable.get(key);
",0,False
"num = size = 0;
",0,False
public int size;,0,False
"return null;
",0,False
"aytMonitor.wait(timeout);
",0,False
"__queue.notify();
",0,False
"__queue.wait(100);
",0,False
"return null;
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"modulus = (++modulus) % 3;
",0,False
"return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker);
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
",0,False
"return null;
",0,False
"return null;
",0,False
"__receiveState = _STATE_DATA;
break; 
",0,False
"__queue.wait(100);
",0,False
"__queue.wait(100);
",0,False
"__queue.notify();
",0,False
"return null;
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0,False
"return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
",0,False
"final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) { 
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
"" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
"" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(
""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(
""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"") 
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for(String s : l) {
System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[]{args.getClass()});
String[] args2 = new String[args.length-1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object)args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}
",0,False
"this(new PrintWriter(stream));
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker);
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
",0,False
"file.setGroup(grp);
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"aytMonitor.wait(timeout);
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"this(new PrintWriter(stream), suppressLogin);
",0,False
"_output_.write(username.getBytes());
",0,False
"return sendCommand(CMD_ENC, new String(Base64.encodeBase64(data)));
",0,False
"return sendCommand(CMD_CONF, new String(Base64.encodeBase64(data)));
",0,False
"createCommandSupport();
",0,False
"if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}
",0,False
public String identifier;,0,False
"return null;
",0,False
"__queue.wait(100);
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"switch (modulus) {
case 2 :
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3 :
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker);
",0,False
"return null;
",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
",0,False
"createCommandSupport();
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}
",0,False
"if (messages == null) {
return null;
}
HashMap<String,ThreadContainer> idTable = new HashMap<String,ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
",0,False
"idTable = null;
",0,False
"ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(
""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"__queue.wait(100);
",0,False
"modulus = (++modulus) % 3;
",0,False
"return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}
",0,False
"idTable = null;
",0,False
public String identifier;,0,False
"return null;
",0,False
"__queue.wait(100);
",0,False
"return null;
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
",0,False
"return null;
",0,False
"file.setGroup(grp);
",0,False
"return null;
",0,False
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
bogusIdCount++ ; 
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0,False
"return null;
",0,False
"__queue.notify();
",0,False
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"this(new PrintWriter(stream), suppressLogin);
",0,False
"new BufferedReader(new InputStreamReader(getInputStream(longOutput,
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
",0,False
"return null;
",0,False
"pointer.articleId = tokens[i++];
",0,False
"return null;
",0,False
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) { 
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0,False
"Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())
",0,False
"return null;
",0,False
"return null;
",0,False
"(SSLSocket) ssf.createSocket(_socket_, ip, port, true);
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"__queue.notify();
",0,False
"__receiveState = _STATE_DATA;
break; 
",0,False
"return null;
",0,False
"return null;
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
",0,False
"if (!(pObject instanceof byte[])) {
throw new RuntimeException(""Parameter supplied to Base64 encode is not a byte[]"");
}
return encode((byte[]) pObject);
",0,False
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0,False
"return unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"catch (IllegalMonitorStateException e)
",1,False
"ThreadContainer c = idTable.get(key);
",1,False
"@Deprecated
public static String PROVIDER;",1,False
"file.setGroup(grp);
",0,False
"(SSLSocket) ssf.createSocket(_socket_, ip, port, false);
",0,False
"output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"file.setGroup(grp);
",0,False
"return null;
",0,False
"FTPListParseEngine engine =
",1,False
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;,0,True
"writeLock.tryLock();
",0,True
"} catch (final Exception e) {
",0,False
private GenericObjectPoolConfig config;,0,False
"} catch (Exception e) {
",0,False
"if(newlyCreated) {
",0,False
private long _maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;,0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (final Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"return ((IdentityWrapper) other).instance == instance;
",0,False
"} catch (Exception e2) {
",0,False
private int _numTestsPerEvictionRun = GenericKeyedObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;,0,False
"} catch (final Exception e) {
",0,False
"} catch (Exception e) {
",0,False
private GenericKeyedObjectPoolConfig config;,0,False
"} catch (Exception e) {
",0,False
"latch.notify();
",0,False
"if (this._factory == null) {
synchronized (factoryLock) {
if (this._factory == null) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"writeLock.tryLock();
",0,True
"} catch (final Exception e) {
",0,False
"writeLock.tryLock();
",0,True
"writeLock.tryLock();
",0,True
"} catch(Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"writeLock.tryLock();
",0,True
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
private int _maxSleeping = StackKeyedObjectPool.DEFAULT_MAX_SLEEPING;,0,False
"writeLock.tryLock();
",0,True
"} catch(Exception e) {
",0,False
"return ((IdentityWrapper) other).instance == instance;
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"ObjectQueue pool = _poolMap.get(key);
",0,False
private int initIdleCapacity;,0,True
"} catch (Exception e1) {
",0,False
"writeLock.tryLock();
",0,True
"} catch (final Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"readLock.tryLock();
",0,True
"} catch (Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"_activeCount.put(key,new Integer(1));
",1,True
"writeLock.tryLock();
",1,True
"result = result * ((counter - 1) / counter) +
",1,True
"} catch (Exception e) {
",1,False
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1,True
"readLock.tryLock();
",1,True
"_numActive++;
",1,True
"} catch (Exception e) {
",1,False
"writeLock.tryLock();
",1,True
"_numActive--;
",1,True
"} catch (Exception e) {
",1,False
"if (objectDeque != null) {
",1,False
"final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
",1,False
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",1,False
"} catch (Exception e) {
",1,False
private Exception borrowedBy = null;,1,True
"if (!p.deallocate()) {
",1,True
"} catch (Exception e) {
",1,False
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;,1,True
"result = result * ((counter - 1) / counter) +
",1,True
"writeLock.tryLock();
",1,True
"readLock.tryLock();
",1,True
"readLock.tryLock();
",1,True
"} catch (Exception e) {
",1,False
"if (!p.deallocate()) {
",1,True
"_numActive--;
",1,True
"final ObjectDeque<T> queue = poolMap.get(key);
",1,False
"} catch (Exception e) {
",1,False
"_activeCount.put(key, new Integer(active.intValue() - 1));
",1,True
"ObjectDeque<T> queue = poolMap.get(key);
",1,False
"Collection c = (Collection) m.get(key);
",1,False
protected int _totIdle = 0;,1,True
private int initIdleCapacity;,1,True
"} catch (Exception e) {
",1,False
"_numActive--;
",1,True
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"} catch (Exception e1) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"} catch (Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch(Exception e) {
",0,False
"latch.notify();
",0,False
"public class GenericObjectPool<T> extends BaseObjectPool<T> implements ObjectPool<T> {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList<ObjectTimestampPair<T>>();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int minIdle) {
synchronized(this) {
_minIdle = minIdle;
}
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public void setConfig(GenericObjectPool.Config conf) {
synchronized (this) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
}
allocate();
}
@Override
public T borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch<T> latch = new Latch<T>();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
_numInternalProcessing--;
doAllocate = true;
} else {
_numInternalProcessing--;
_numActive++;
returnObject(latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
T obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair<T>(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair( _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
@Override
public void invalidateObject(T obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
}
allocate();
}
}
@Override
public void clear() {
List<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection<ObjectTimestampPair<T>> c, PoolableObjectFactory<T> factory) {
for (Iterator<ObjectTimestampPair<T>> it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(it.next().value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
}
allocate();
}
}
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized int getNumIdle() {
return _pool.size();
}
@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
@Deprecated
@Override
public void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
List<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();
final PoolableObjectFactory<T> oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
_evictionCursor.previous() :
_evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator<ObjectTimestampPair<T>> it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair<T> pair = it.next();
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
@Override
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch<T> {
private ObjectTimestampPair<T> _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair<T> getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair<T> pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList<ObjectTimestampPair<T>> _pool = null;
private CursorableLinkedList<ObjectTimestampPair<T>>.Cursor _evictionCursor = null;
private PoolableObjectFactory<T> _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList<Latch<T>> _allocationQueue = new LinkedList<Latch<T>>();
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList<SoftReference<T>>();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory<T> factory) {
_pool = new ArrayList<SoftReference<T>>();
_factory = factory;
}
@Deprecated
public SoftReferenceObjectPool(PoolableObjectFactory<T> factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList<SoftReference<T>>(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference<T> ref = _pool.remove(_pool.size() - 1);
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized void clear() {
if(null != _factory) {
Iterator<SoftReference<T>> iter = _pool.iterator();
while(iter.hasNext()) {
try {
T obj = iter.next().get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Deprecated
@Override
public synchronized void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference<? extends T> ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
public synchronized PoolableObjectFactory<T> getFactory() {
return _factory;
}
private final List<SoftReference<T>> _pool;
private PoolableObjectFactory<T> _factory = null;
private final ReferenceQueue<T> refQueue = new ReferenceQueue<T>();
private int _numActive = 0; 
",0,False
"this(null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
@Deprecated
public StackObjectPool(int maxIdle) {
this(null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
@Deprecated
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this(null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory<T> factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory<T> factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory<T> factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack<T>();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
@Override
public synchronized int getNumIdle() {
return _pool.size();
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized void clear() {
if(null != _factory) {
Iterator<T> it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Deprecated
@Override
public synchronized void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
@Deprecated
protected Stack<T> _pool = null;
@Deprecated
protected PoolableObjectFactory<T> _factory = null;
@Deprecated
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
@Deprecated
protected int _numActive = 0;
public synchronized PoolableObjectFactory<T> getFactory() {
return _factory;
}
public int getMaxSleeping() {
return _maxSleeping;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy);
}
private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext();) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception e2) {
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"l.notify();
",0,False
"} catch(Exception e) {
",0,False
"latch.notify();
",0,False
"l.notify();
",0,False
"} catch(Exception e) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
public synchronized PoolableObjectFactory getFactory() {
return _factory;
}
private final List _pool;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0; 
",0,False
protected int _totIdle = 0;,0,True
protected int _totActive = 0;,0,True
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"private Listable _prev = null;
private Listable _next = null;
private Object _val = null;
Listable(Listable prev, Listable next, Object val) {
_prev = prev;
_next = next;
_val = val;
}
Listable next() {
return _next;
}
Listable prev() {
return _prev;
}
Object value() {
return _val;
}
void setNext(Listable next) {
_next = next;
}
void setPrev(Listable prev) {
_prev = prev;
}
Object setValue(Object val) {
Object temp = _val;
_val = val;
return temp;
",0,False
"} catch(Exception e) {
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0,False
"latch.notify();
",0,False
"latch.notify();
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
protected int _totActive = 0;,0,True
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"latch.notify();
",0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList<SoftReference<T>>();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory<T> factory) {
_pool = new ArrayList<SoftReference<T>>();
_factory = factory;
}
@Deprecated
public SoftReferenceObjectPool(PoolableObjectFactory<T> factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList<SoftReference<T>>(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference<T> ref = _pool.remove(_pool.size() - 1);
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized void clear() {
if(null != _factory) {
Iterator<SoftReference<T>> iter = _pool.iterator();
while(iter.hasNext()) {
try {
T obj = iter.next().get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Deprecated
@Override
public synchronized void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference<? extends T> ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
public synchronized PoolableObjectFactory<T> getFactory() {
return _factory;
}
private final List<SoftReference<T>> _pool;
private PoolableObjectFactory<T> _factory = null;
private final ReferenceQueue<T> refQueue = new ReferenceQueue<T>();
private int _numActive = 0; 
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"this((PoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle) {
this((PoolableObjectFactory)null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this((PoolableObjectFactory)null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized int getNumIdle() {
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected Stack _pool = null;
protected PoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _numActive = 0;
public synchronized PoolableObjectFactory getFactory() {
return _factory;
}
public int getMaxSleeping() {
return _maxSleeping;
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"latch.notify();
",0,False
"} catch (Exception ex2) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList<SoftReference<T>>();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory<T> factory) {
_pool = new ArrayList<SoftReference<T>>();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory<T> factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList<SoftReference<T>>(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference<T> ref = _pool.remove(_pool.size() - 1);
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator<SoftReference<T>> iter = _pool.iterator();
while(iter.hasNext()) {
try {
T obj = iter.next().get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference<? extends T> ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
public synchronized PoolableObjectFactory<T> getFactory() {
return _factory;
}
private List<SoftReference<T>> _pool = null;
private PoolableObjectFactory<T> _factory = null;
private final ReferenceQueue<T> refQueue = new ReferenceQueue<T>();
private int _numActive = 0;
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
",0,False
"ObjectQueue pool = _poolMap.get(key);
",0,False
"catch (Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"public class GenericObjectPool<T> extends BaseObjectPool<T> implements ObjectPool<T> {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList<ObjectTimestampPair<T>>();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int minIdle) {
synchronized(this) {
_minIdle = minIdle;
}
allocate();
}
public synchronized int getMinIdle() {
if (_minIdle > _maxIdle) {
return _maxIdle;
} else {
return _minIdle;
}
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public void setConfig(GenericObjectPool.Config conf) {
synchronized (this) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
}
allocate();
}
@Override
public T borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch<T> latch = new Latch<T>();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
_numInternalProcessing--;
doAllocate = true;
} else {
_numInternalProcessing--;
_numActive++;
returnObject(latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
T obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair<T>(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
try {
_factory.activateObject(latch.getPair().getValue());
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().getValue())) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().getValue();
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().getValue());
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) {
return;
}
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair( _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
@Override
public void invalidateObject(T obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
}
allocate();
}
}
@Override
public void clear() {
List<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection<ObjectTimestampPair<T>> c, PoolableObjectFactory<T> factory) {
for (Iterator<ObjectTimestampPair<T>> it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(it.next().getValue());
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
}
allocate();
}
}
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized int getNumIdle() {
return _pool.size();
}
@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
@Deprecated
@Override
public void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
List<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();
final PoolableObjectFactory<T> oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
_evictionCursor.previous() :
_evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.getTstamp();
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.getValue());
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.getValue())) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.getValue());
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.getValue());
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator<ObjectTimestampPair<T>> it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair<T> pair = it.next();
buf.append(""\t"").append(pair.getValue()).append(""\t"").append(time - pair.getTstamp()).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
@Override
public void run() {
ClassLoader savedClassLoader =
Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(
_factoryClassLoader);
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch<T> {
private ObjectTimestampPair<T> _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair<T> getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair<T> pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList<ObjectTimestampPair<T>> _pool = null;
private CursorableLinkedList<ObjectTimestampPair<T>>.Cursor _evictionCursor = null;
private PoolableObjectFactory<T> _factory = null;
private ClassLoader _factoryClassLoader = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList<Latch<T>> _allocationQueue = new LinkedList<Latch<T>>();
",0,False
"latch.notify();
",0,False
"l.notify();
",0,False
"} catch(Exception e) {
",0,False
"Stack<V> stack = _pools.get(key);
",0,False
"Stack<V> s = _pools.get(key);
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int minIdle) {
synchronized(this) {
_minIdle = minIdle;
}
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public void setConfig(GenericObjectPool.Config conf) {
synchronized (this) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
}
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
_numInternalProcessing--;
doAllocate = true;
} else {
_numInternalProcessing--;
_numActive++;
returnObject(latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
}
allocate();
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection c, PoolableObjectFactory factory) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
}
allocate();
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
final PoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
protected int _totActive = 0;,0,True
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy);
}
private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext();) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDefecit(pool, false);
for (int i = 0; i < objectDeficit && calculateDefecit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDefecit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e1) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"} catch (Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"private Listable _prev = null;
private Listable _next = null;
private Object _val = null;
Listable(Listable prev, Listable next, Object val) {
_prev = prev;
_next = next;
_val = val;
}
Listable next() {
return _next;
}
Listable prev() {
return _prev;
}
Object value() {
return _val;
}
void setNext(Listable next) {
_next = next;
}
void setPrev(Listable prev) {
_prev = prev;
}
Object setValue(Object val) {
Object temp = _val;
_val = val;
return temp;
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"} catch (Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy);
}
private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext();) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDefecit(pool, false);
for (int i = 0; i < objectDeficit && calculateDefecit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDefecit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception ex2) {
",0,False
"latch.notify();
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"latch.notify();
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception ex2) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public void setMaxTotal(int maxTotal) {
synchronized(this) {
_maxTotal = maxTotal;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
latch.getPool().decrementInternalProcessingCount();
doAllocate = true;
} else {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
returnObject(latch.getkey(), latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
}
allocate();
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue)_poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator entries = m.entrySet().iterator(); entries.hasNext();) {
Map.Entry entry = (Entry) entries.next();
Object key = entry.getKey();
Collection c = (Collection) entry.getValue();
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
ObjectQueue objectQueue =
(ObjectQueue) _poolMap.get(key);
if (objectQueue != null) {
objectQueue.decrementInternalProcessingCount();
if (objectQueue.internalProcessingCount == 0 &&
objectQueue.activeCount == 0 &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
}
allocate(); 
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() &&
objectQueue.activeCount == 0 &&
objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
}
allocate();
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
//CHECKSTYLE: stop VisibilityModifier
Object value;
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public Object getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int minIdle) {
synchronized(this) {
_minIdle = minIdle;
}
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public void setConfig(GenericObjectPool.Config conf) {
synchronized (this) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
}
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
_numInternalProcessing--;
doAllocate = true;
} else {
_numInternalProcessing--;
_numActive++;
returnObject(latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
}
allocate();
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection c, PoolableObjectFactory factory) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
}
allocate();
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
final PoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectQueue pool = _poolMap.get(key);
",0,False
"catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"boolean _valid = false;
Cursor(int index) {
super(index);
_valid = true;
registerCursor(this);
}
public int previousIndex() {
throw new UnsupportedOperationException();
}
public int nextIndex() {
throw new UnsupportedOperationException();
}
public void add(Object o) {
checkForComod();
Listable elt = insertListable(_cur.prev(),_cur.next(),o);
_cur.setPrev(elt);
_cur.setNext(elt.next());
_lastReturned = null;
_nextIndex++;
_expectedModCount++;
}
protected void listableRemoved(Listable elt) {
if(null == _head.prev()) {
_cur.setNext(null);
} else if(_cur.next() == elt) {
_cur.setNext(elt.next());
}
if(null == _head.next()) {
_cur.setPrev(null);
} else if(_cur.prev() == elt) {
_cur.setPrev(elt.prev());
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableInserted(Listable elt) {
if(null == _cur.next() && null == _cur.prev()) {
_cur.setNext(elt);
} else if(_cur.prev() == elt.prev()) {
_cur.setNext(elt);
}
if(_cur.next() == elt.next()) {
_cur.setPrev(elt);
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableChanged(Listable elt) {
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void checkForComod() {
if(!_valid) {
throw new ConcurrentModificationException();
}
}
protected void invalidate() {
_valid = false;
}
public void close() {
if(_valid) {
_valid = false;
unregisterCursor(this);
}
}
",0,False
"l.notify();
",0,False
private ClassLoader _factoryClassLoader = null;,0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"l.notify();
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
private int minIdlePerKey;,0,False
"} catch(Exception e) {
",0,False
private boolean testOnBorrow;,0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
private int minIdlePerKey;,0,False
private int maxTotalPerKey;,0,False
private int maxIdlePerKey;,0,False
private long minEvictableIdleTimeMillis;,0,False
"} catch(Exception e) {
",0,False
private boolean testOnReturn;,0,False
"} catch (Exception ex2) {
",0,False
private int numTestsPerEvictionRun;,0,False
private long minEvictableIdleTimeMillis;,0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
for (;;) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
toDestroy.put(key, pool.queue);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
}
}
destroy(toDestroy);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
toDestroy.put(key, pool.queue);
}
destroy(toDestroy);
}
private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext();) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
toDestroy.put(key, pool.queue);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
}
}
destroy(toDestroy);
_factory = factory;
}
}
destroy(toDestroy);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDefecit(pool, false);
for (int i = 0; i < objectDeficit && calculateDefecit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
buf.append(""\t"").append(_poolMap.get(it.next())).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return _numTestsPerEvictionRun;
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDefecit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectQueue pool = _poolMap.get(key);
",0,False
"public class GenericKeyedObjectPool<K,V> extends BaseKeyedObjectPool<K,V> implements KeyedObjectPool<K,V>, GenericKeyedObjectPoolMBean<K> {
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K,V> factory) {
this(factory, new GenericKeyedObjectPoolConfig.Builder().createConfig());
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K,V> factory, GenericKeyedObjectPoolConfig config) {
if (factory == null) {
throw new IllegalArgumentException(""factory must not be null"");
}
if (config == null) {
throw new IllegalArgumentException(""config must not be null"");
}
_factory = factory;
this.maxIdlePerKey = config.getMaxIdlePerKey();
this.minIdlePerKey = config.getMinIdlePerKey();
this.maxTotalPerKey = config.getMaxTotalPerKey();
this.maxTotal = config.getMaxTotal();
this.maxWait = config.getMaxWait();
this.whenExhaustedAction = config.getWhenExhaustedAction();
this.testOnBorrow = config.getTestOnBorrow();
this.testOnReturn = config.getTestOnReturn();
this.testWhileIdle = config.getTestWhileIdle();
this.timeBetweenEvictionRunsMillis = config.getTimeBetweenEvictionRunsMillis();
this.numTestsPerEvictionRun = config.getNumTestsPerEvictionRun();
this.minEvictableIdleTimeMillis = config.getMinEvictableIdleTimeMillis();
this.lifo = config.getLifo();
_poolMap = new HashMap<K,ObjectQueue>();
_poolList = new CursorableLinkedList<K>();
startEvictor(this.timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxTotalPerKey() {
return this.maxTotalPerKey;
}
public synchronized void setMaxTotalPerKey(int maxTotalPerKey) {
this.maxTotalPerKey = maxTotalPerKey;
allocate();
}
public synchronized int getMaxTotal() {
return this.maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
this.maxTotal = maxTotal;
allocate();
}
public synchronized WhenExhaustedAction getWhenExhaustedAction() {
return this.whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(WhenExhaustedAction whenExhaustedAction) {
this.whenExhaustedAction = whenExhaustedAction;
allocate();
}
public synchronized long getMaxWait() {
return this.maxWait;
}
public synchronized void setMaxWait(long maxWait) {
this.maxWait = maxWait;
}
public synchronized int getMaxIdlePerKey() {
return this.maxIdlePerKey;
}
public synchronized void setMaxIdlePerKey(int maxIdlePerKey) {
this.maxIdlePerKey = maxIdlePerKey;
allocate();
}
public synchronized void setMinIdle(int minIdlePerKey) {
this.minIdlePerKey = minIdlePerKey;
}
public synchronized int getMinIdlePerKey() {
return this.minIdlePerKey;
}
public synchronized boolean getTestOnBorrow() {
return this.testOnBorrow;
}
public synchronized void setTestOnBorrow(boolean testOnBorrow) {
this.testOnBorrow = testOnBorrow;
}
public synchronized boolean getTestOnReturn() {
return this.testOnReturn;
}
public synchronized void setTestOnReturn(boolean testOnReturn) {
this.testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return this.timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(this.timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return this.numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
this.numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return this.minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return this.testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
this.testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return this.lifo;
}
public synchronized void setLifo(boolean lifo) {
this.lifo = lifo;
}
@Override
public V borrowObject(K key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
WhenExhaustedAction whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = this.whenExhaustedAction;
maxWait = this.maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
V obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair<V>(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().getValue());
if (this.testOnBorrow && !_factory.validateObject(key, latch.getPair().getValue())) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().getValue();
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().getValue());
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) &&
(this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
@Override
public void clear() {
Map<K,List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K,List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext();) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (K key : _poolMap.keySet()) {
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (ObjectTimestampPair<V> pair : list) {
map.put(pair, key);
}
}
Set<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
@Override
public void clear(K key) {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final ObjectQueue pool;
synchronized (this) {
pool = _poolMap.remove(key);
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map<K, List<ObjectTimestampPair<V>>> m, KeyedPoolableObjectFactory<K, V> factory) {
for (Map.Entry<K, List<ObjectTimestampPair<V>>> entry : m.entrySet()) {
K key = entry.getKey();
Collection<ObjectTimestampPair<V>> c = entry.getValue();
for (ObjectTimestampPair<V> pair : c) {
try {
factory.destroyObject(key, pair.getValue());
} catch (Exception e) {
} finally {
synchronized (this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
@Override
public synchronized int getNumActive() {
return _totalActive;
}
@Override
public synchronized int getNumIdle() {
return _totalIdle;
}
@Override
public synchronized int getNumActive(K key) {
final ObjectQueue pool = (_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
@Override
public synchronized int getNumIdle(K key) {
final ObjectQueue pool = (_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
private void addObjectToPool(K key, V obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (this.testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (this.maxIdlePerKey >= 0 && (pool.queue.size() >= this.maxIdlePerKey)) {
shouldDestroy = true;
} else if (success) {
if (this.lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
@Override
public void invalidateObject(K key, V obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
@Override
public void addObject(K key) throws Exception {
assertOpen();
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = this.testWhileIdle;
minEvictableIdleTimeMillis = this.minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((this.lifo && !_evictionCursor.hasPrevious()) ||
(!this.lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((this.lifo && !_evictionCursor.hasPrevious()) ||
(!this.lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = this.lifo ?
_evictionCursor.previous() :
_evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.getTstamp() >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.getValue());
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.getValue())) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.getValue());
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.getValue());
} catch(Exception e) {
} finally {
if (this.minIdlePerKey == 0) {
synchronized (this) {
ObjectQueue objectQueue =
_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (this.lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(K key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
CursorableLinkedList<ObjectTimestampPair<V>> queue = pool.queue;
_evictionCursor = queue.cursor(this.lifo ? queue.size() : 0);
}
}
@SuppressWarnings(""unchecked"") 
private void ensureMinIdle() throws Exception {
if (this.minIdlePerKey > 0) {
K[] keysCopy;
synchronized(this) {
keysCopy = (K[]) _poolMap.keySet().toArray(); 
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(K key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
for (K key : _poolMap.keySet()) {
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (this.numTestsPerEvictionRun >= 0) {
return Math.min(this.numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)this.numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = this.minIdlePerKey - pool.queue.size();
if (this.maxTotalPerKey > 0) {
int growLimit = Math.max(0, this.maxTotalPerKey - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (this.maxTotal > 0) {
int growLimit = Math.max(0, this.maxTotal - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList<ObjectTimestampPair<V>> queue = new CursorableLinkedList<ObjectTimestampPair<V>>();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair<V> implements Comparable<ObjectTimestampPair<V>> {
//CHECKSTYLE: stop VisibilityModifier
private final V value;
private final long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(V val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(V val, long time) {
value = val;
tstamp = time;
}
@Override
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(ObjectTimestampPair<V> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public V getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
@Override
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
private final class Latch {
private final K _key;
private ObjectQueue _pool;
private ObjectTimestampPair<V> _pair;
private boolean _mayCreate = false;
private Latch(K key) {
_key = key;
}
private synchronized K getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair<V> getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair<V> pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int maxIdlePerKey; 
private int minIdlePerKey; 
private int maxTotalPerKey; 
private int maxTotal; 
private long maxWait; 
private WhenExhaustedAction whenExhaustedAction; 
private boolean testOnBorrow; 
private boolean testOnReturn; 
private boolean testWhileIdle; 
private long timeBetweenEvictionRunsMillis; 
private int numTestsPerEvictionRun; 
private long minEvictableIdleTimeMillis; 
private boolean lifo; 
private final Map<K,ObjectQueue> _poolMap;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private final KeyedPoolableObjectFactory<K,V> _factory;
private Evictor _evictor = null;
private final CursorableLinkedList<K> _poolList;
private CursorableLinkedList<ObjectTimestampPair<V>>.Cursor _evictionCursor = null;
private CursorableLinkedList<K>.Cursor _evictionKeyCursor = null;
private final LinkedList<Latch> _allocationQueue = new LinkedList<Latch>();
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"} catch (Exception e1) {
",0,False
"} catch (Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"static final Timer COMPOSITE_TIMER = new Timer(true);
// XXX: Add better handling of when this instance is not Serializable
private final PoolableObjectFactory factory;
private final transient List pool;
private final Lender lender;
private final Manager manager;
private final Tracker tracker;
private final boolean validateOnReturn;
private volatile boolean open = true;
private final CompositeObjectPoolFactory.FactoryConfig factoryConfig;
private CompositeKeyedObjectPool owningCompositeKeyedObjectPool = null;
CompositeObjectPool(final PoolableObjectFactory factory, final Manager manager, final Lender lender, final Tracker tracker, final boolean validateOnReturn) {
this(factory, manager, lender, tracker, validateOnReturn, null);
}
CompositeObjectPool(final PoolableObjectFactory factory, final Manager manager, final Lender lender, final Tracker tracker, final boolean validateOnReturn, final CompositeObjectPoolFactory.FactoryConfig factoryConfig) {
this(factory, new LinkedList(), manager, lender, tracker, validateOnReturn, factoryConfig);
}
CompositeObjectPool(final PoolableObjectFactory factory, final List pool, final Manager manager, final Lender lender, final Tracker tracker, final boolean validateOnReturn, final CompositeObjectPoolFactory.FactoryConfig factoryConfig) {
if (factory == null) {
throw new IllegalArgumentException(""factory cannot be null."");
}
if (pool == null) {
throw new IllegalArgumentException(""pool cannot be null."");
}
if (manager == null) {
throw new IllegalArgumentException(""manager cannot be null."");
}
if (lender == null) {
throw new IllegalArgumentException(""lender cannot be null."");
}
if (tracker == null) {
throw new IllegalArgumentException(""tracker cannot be null."");
}
this.factory = factory;
this.pool = pool;
this.manager = manager;
this.lender = lender;
this.tracker = tracker;
this.validateOnReturn = validateOnReturn;
this.factoryConfig = factoryConfig;
updateCompositeObjectPools();
}
private void updateCompositeObjectPools() {
lender.setCompositeObjectPool(this);
manager.setCompositeObjectPool(this);
}
Lender getLender() {
return lender;
}
PoolableObjectFactory getFactory() {
return factory;
}
List getPool() {
return pool;
}
void setOwningCompositeKeyedObjectPool(final CompositeKeyedObjectPool ckop) {
if (owningCompositeKeyedObjectPool != null) {
throw new IllegalStateException(""CompositeObjectPools cannot change ownership."");
}
owningCompositeKeyedObjectPool = ckop;
}
CompositeKeyedObjectPool getOwningCompositeKeyedObjectPool() {
return owningCompositeKeyedObjectPool;
}
public void addObject() throws Exception {
assertOpen();
final Object obj = factory.makeObject();
factory.passivateObject(obj);
synchronized (pool) {
if (isOpen()) {
manager.returnToPool(obj);
} else {
factory.destroyObject(obj);
}
}
}
public Object borrowObject() throws Exception {
assertOpen();
return internalBorrowObject();
}
private Object internalBorrowObject() throws Exception {
final Object obj;
synchronized (pool) {
obj = manager.nextFromPool();
tracker.borrowed(obj);
}
return obj;
}
public void returnObject(final Object obj) {
if (validateOnReturn) {
if (!factory.validateObject(obj)) {
invalidateObject(obj);
return;
}
}
try {
factory.passivateObject(obj);
} catch (Exception e) {
invalidateObject(obj);
return;
}
synchronized (pool) {
if (isOpen()) {
tracker.returned(obj);
manager.returnToPool(obj);
} else {
invalidateObject(obj);
}
}
}
public void invalidateObject(final Object obj) {
synchronized (pool) {
if (pool.contains(obj)) {
throw new IllegalStateException(""An object currently in the pool cannot be invalidated."");
}
tracker.returned(obj);
try {
factory.destroyObject(obj);
} catch (Exception e) {
} finally {
pool.notifyAll(); 
}
}
}
public void clear() throws Exception, UnsupportedOperationException {
synchronized (pool) {
while (pool.size() > 0) {
final Object obj = internalBorrowObject();
invalidateObject(obj);
}
if (pool instanceof ArrayList) {
((ArrayList)pool).trimToSize();
}
}
}
public void close() {
open = false;
Thread.yield(); 
synchronized (pool) {
try {
clear();
} catch (Exception e) {
}
pool.notifyAll(); 
}
}
public void setFactory(final PoolableObjectFactory factory) throws IllegalStateException, UnsupportedOperationException {
if (this.factory != factory) {
throw new UnsupportedOperationException(""Replacing the factory not supported. Create a new pool instance instead."");
}
}
public int getNumActive() {
return tracker.getBorrowed();
}
public int getNumIdle() {
return lender.size();
}
boolean isOpen() {
return open;
}
private void assertOpen() throws IllegalStateException {
if (!isOpen()) {
throw new IllegalStateException(""pool has been closed."");
}
}
public String toString() {
final StringBuffer sb = new StringBuffer(128);
sb.append(""CompositeObjectPool{"");
if (factoryConfig != null) {
sb.append(factoryConfig);
} else {
sb.append(""factory="").append(factory);
sb.append("", lender="").append(lender);
sb.append("", manager="").append(manager);
sb.append("", tracker="").append(tracker);
sb.append("", validateOnReturn="").append(validateOnReturn);
}
sb.append("", open="").append(open);
try {
final int numActive = getNumActive();
sb.append("", activeObjects="").append(numActive);
} catch (Exception e) {
}
try {
final int numIdle = getNumIdle();
sb.append("", idleObjects="").append(numIdle);
} catch (Exception e) {
}
sb.append('}');
return sb.toString();
",0,False
"// XXX: Add better handling of when this instance is not Serializable
private final PoolableObjectFactory factory;",0,False
"super(delegate);
prune = !(delegate instanceof EvictorLender);
}
public Object borrow() {
final EvictorReference ref = (EvictorReference)super.borrow();
Object obj = null;
if (ref != null) {
synchronized (ref) {
obj = ref.get();
ref.clear();
}
}
return obj;
}
public void repay(final Object obj) {
super.repay(createReference(obj));
}
public ListIterator listIterator() {
return new EvictorListIterator(super.listIterator());
}
public int size() {
if (prune) {
synchronized (getObjectPool().getPool()) {
final Iterator iter = super.listIterator();
while (iter.hasNext()) {
Object o = iter.next();
while (o instanceof LenderReference) {
o = ((LenderReference)o).get();
}
if (o == null) {
iter.remove();
}
}
}
}
return super.size();
}
protected abstract EvictorReference createReference(Object obj);
protected final Timer getTimer() {
return CompositeObjectPool.COMPOSITE_TIMER;
",0,False
"active++;
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"catch (Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch (Exception e2) {
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"public class GenericObjectPool<T> extends BaseObjectPool<T> implements ObjectPool<T> {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList<ObjectTimestampPair<T>>();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int minIdle) {
synchronized(this) {
_minIdle = minIdle;
}
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public void setConfig(GenericObjectPool.Config conf) {
synchronized (this) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
}
allocate();
}
@Override
public T borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch<T> latch = new Latch<T>();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
_numInternalProcessing--;
doAllocate = true;
} else {
_numInternalProcessing--;
_numActive++;
returnObject(latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
T obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair<T>(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair( _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
@Override
public void invalidateObject(T obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
}
allocate();
}
}
@Override
public void clear() {
List<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection<ObjectTimestampPair<T>> c, PoolableObjectFactory<T> factory) {
for (Iterator<ObjectTimestampPair<T>> it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(it.next().value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
}
allocate();
}
}
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized int getNumIdle() {
return _pool.size();
}
@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
@Deprecated
@Override
public void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
List<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();
final PoolableObjectFactory<T> oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
_evictionCursor.previous() :
_evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator<ObjectTimestampPair<T>> it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair<T> pair = it.next();
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
@Override
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch<T> {
private ObjectTimestampPair<T> _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair<T> getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair<T> pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList<ObjectTimestampPair<T>> _pool = null;
private CursorableLinkedList<ObjectTimestampPair<T>>.Cursor _evictionCursor = null;
private PoolableObjectFactory<T> _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList<Latch<T>> _allocationQueue = new LinkedList<Latch<T>>();
",0,False
"@Deprecated
protected int _totActive = 0;",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch (Exception e2) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
allocate();
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
allocate();
}
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection c, PoolableObjectFactory factory) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
final PoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
public synchronized PoolableObjectFactory getFactory() {
return _factory;
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"if (!idleQueue.offerFirst(this)) {
",0,False
"} catch (final Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0,False
"latch.notify();
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
protected int _totActive = 0;,0,True
"this((PoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle) {
this((PoolableObjectFactory)null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this((PoolableObjectFactory)null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized int getNumIdle() {
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected Stack _pool = null;
protected PoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _numActive = 0;
public synchronized PoolableObjectFactory getFactory() {
return _factory;
}
public int getMaxSleeping() {
return _maxSleeping;
",0,False
"} catch (Exception e) {
",0,False
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0,False
"ObjectDeque<T> queue = poolMap.get(k);
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"borrowedCount++;
",0,False
"} catch (final Exception e1) {
",0,False
"} catch (final Exception ignored) {
",0,False
"public interface PooledObject<T> extends Comparable<PooledObject<T>> {
boolean allocate();
@Override
int compareTo(PooledObject<T> other);
boolean deallocate();
boolean endEvictionTest(Deque<PooledObject<T>> idleQueue);
@Override
boolean equals(Object obj);
default Duration getActiveDuration() {
final Instant lastReturnInstant = getLastReturnInstant();
final Instant lastBorrowInstant = getLastBorrowInstant();
// @formatter:off
return lastReturnInstant.isAfter(lastBorrowInstant) ?
Duration.between(lastBorrowInstant, lastReturnInstant) :
Duration.between(lastBorrowInstant, Instant.now());
// @formatter:on
}
@Deprecated
default Duration getActiveTime() {
return getActiveDuration();
}
@Deprecated
long getActiveTimeMillis();
default long getBorrowedCount() {
return -1;
}
default Instant getCreateInstant() {
return Instant.ofEpochMilli(getCreateTime());
}
@Deprecated
long getCreateTime();
default Duration getFullDuration() {
return Duration.between(getCreateInstant(), Instant.now());
}
default Duration getIdleDuration() {
return Duration.ofMillis(getIdleTimeMillis());
}
@Deprecated
default Duration getIdleTime() {
return Duration.ofMillis(getIdleTimeMillis());
}
@Deprecated
long getIdleTimeMillis();
default Instant getLastBorrowInstant() {
return Instant.ofEpochMilli(getLastBorrowTime());
}
@Deprecated
long getLastBorrowTime();
default Instant getLastReturnInstant() {
return Instant.ofEpochMilli(getLastReturnTime());
}
@Deprecated
long getLastReturnTime();
default Instant getLastUsedInstant() {
return Instant.ofEpochMilli(getLastUsedTime());
}
@Deprecated
long getLastUsedTime();
T getObject();
PooledObjectState getState();
@Override
int hashCode();
void invalidate();
void markAbandoned();
void markReturning();
void printStackTrace(PrintWriter writer);
void setLogAbandoned(boolean logAbandoned);
default void setRequireFullStackTrace(final boolean requireFullStackTrace) {
}
",0,False
"} catch (final Exception e) {
",0,False
"return (E) throwable;
",0,False
"throw (Error) validationThrowable;
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch(Exception e) {
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"} catch (Exception e2) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
_numInternalProcessing--;
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
allocate();
}
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy);
}
private void destroy(Collection c) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0,False
"} catch(Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e1) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"} catch (Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"return (E) throwable;
",0,False
"if (!idleQueue.offerFirst(this)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"} catch (Exception e2) {
",0,False
"catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"ObjectDeque<T> queue = poolMap.get(k);
",0,False
