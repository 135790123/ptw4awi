source,target,raw_preds
"public ModuleExports[] getExportsTable() {
return exports_table;
}",0,False
"@Override
public boolean equals(final Instruction i1, final Instruction i2) {
if (i1.getOpcode() == i2.getOpcode()) {
if (i1 instanceof BranchInstruction) {
return false;
} else if (i1 instanceof ConstantPushInstruction) {
return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());
} else if (i1 instanceof IndexedInstruction) {
return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();
} else if (i1 instanceof NEWARRAY) {
return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
} else {
return true;
}
}
return false;
}",0,False
"public ModuleProvides[] getProvidesTable() {
return provides_table;
}",0,False
"public ModuleOpens[] getOpensTable() {
return opens_table;
}",0,False
"@Deprecated
public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",0,True
"public StackMapType[] getTypesOfLocals() {
return types_of_locals;
}",0,False
"public BootstrapMethod(int bootstrap_method_ref, int num_bootstrap_arguments, int[] bootstrap_arguments) {
this.bootstrap_method_ref = bootstrap_method_ref;
this.bootstrap_arguments = new int[num_bootstrap_arguments];
this.bootstrap_arguments = bootstrap_arguments;
}",1,False
"public void setConstantPool(final Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0,False
"public StackMapType[] getTypesOfStackItems() {
return types_of_stack_items;
}",0,False
"public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",1,False
"public ElementValue[] getElementValuesArray() {
return evalues;
}",0,False
"public static final String[] METHODHANDLE_NAMES = { """", ""getField"", ""getStatic"", ""putField"", ""putStatic"", ""invokeVirtual"", ""invokeStatic"", ""invokeSpecial"", ""newInvokeSpecial"", ""invokeInterface"" };",1,False
"public String[] getInterfaceNames() {
return interface_names;
}",0,False
"public InnerClass[] getInnerClasses() {
return inner_classes;
}",0,False
"public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
return parameter_annotation_table;
}",0,False
"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
return parameter_annotation_table;
}",0,False
"@Deprecated
public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0,True
"public static final int[] CONSUME_STACK = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 3, 4, 3, 4, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 3, 4, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 2, 1, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 4, 2, 4, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 4, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 1, 2, 1, 0, 0, UNPREDICTABLE, 1, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, UNPREDICTABLE, 1, 1, 0, 0, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1,False
"public int[] getPackageIndexTable() {
return package_index_table;
}",0,False
"public Annotations(byte annotation_type, int name_index, int length, AnnotationEntry[] annotation_table, ConstantPool constant_pool, boolean isRuntimeVisible) {
super(annotation_type, name_index, length, constant_pool);
this.annotation_table = annotation_table;
this.isRuntimeVisible = isRuntimeVisible;
}",0,False
"public final BootstrapMethod[] getBootstrapMethods() {
return bootstrap_methods;
}",0,False
"public Constant[] getConstantPool() {
return constant_pool;
}",0,False
"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
"ConstantUtf8(DataInput file) throws IOException {
super(Const.CONSTANT_Utf8);
bytes = file.readUTF();
created++;
}",0,False
"public Deprecated(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {
super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);
this.bytes = bytes;
}",0,False
"public final void setAttributes(Attribute[] attributes) {
this.attributes = attributes;
this.attributes_count = attributes != null ? attributes.length : 0;
}",0,False
"public void setInterfaceNames(String[] interface_names) {
this.interface_names = interface_names;
}",0,False
"public AnnotationEntry[] getAnnotationEntries() {
if (annotations == null) {
annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotations;
}",0,False
"public Method[] getMethods() {
return methods;
}",0,False
"public LineNumberTable(int name_index, int length, LineNumber[] line_number_table, ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.line_number_table = line_number_table;
}",0,False
"public int getSourceLine(int pos) {
int l = 0;
int r = line_number_table.length - 1;
if (r < 0) {
return -1;
}
int min_index = -1;
int min = -1;
do {
int i = (l + r) / 2;
int j = line_number_table[i].getStartPC();
if (j == pos) {
return line_number_table[i].getLineNumber();
} else if (pos < j) {
r = i - 1;
} else {
l = i + 1;
}
if (j < pos && j > min) {
min = j;
min_index = i;
}
} while (l <= r);
if (min_index < 0) {
return -1;
}
return line_number_table[min_index].getLineNumber();
}",0,False
"public LocalVariableTable(int name_index, int length, LocalVariable[] local_variable_table, ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TABLE, name_index, length, constant_pool);
this.local_variable_table = local_variable_table;
}",0,False
"public final LocalVariable[] getLocalVariableTypeTable() {
return local_variable_type_table;
}",0,False
"public MethodParameter[] getParameters() {
return parameters;
}",0,False
"static BranchHandle getBranchHandle(BranchInstruction i) {
if (bh_list == null) {
return new BranchHandle(i);
}
BranchHandle bh = bh_list;
bh_list = (BranchHandle) bh.getNext();
bh.setInstruction(i);
return bh;
}",0,False
"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
"public static ElementValueGen copy(ElementValue value, ConstantPoolGen cpool, boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0,False
"public void setInitValue(double d) {
checkType(Type.DOUBLE);
if (d != 0.0) {
value = new Double(d);
}
}",0,False
"public void setInitValue(float f) {
checkType(Type.FLOAT);
if (f != 0.0) {
value = new Float(f);
}
}",0,False
"public int[] getInstructionPositions() {
return byte_positions;
}",0,False
private final InstructionHandle[] targets;,0,False
"public InstructionHandle[] getTargets() {
return targets;
}",0,False
"public BCELifier(JavaClass clazz, OutputStream out) {
_clazz = clazz;
_out = new PrintWriter(out);
_cp = new ConstantPoolGen(_clazz.getConstantPool());
}",0,False
"public Class2HTML(JavaClass java_class, String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0,False
"public Class2HTML(JavaClass java_class, String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0,False
"private String codeToHTML(ByteSequence bytes, int method_number) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constant_pool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
String field_name = constant_pool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(class_name)) {
buf.append(""<A HREF=\"""").append(class_name).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constant_html.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(index, Const.CONSTANT_NameAndType)));
ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constant_pool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
String[] args = Utility.methodSignatureArgumentTypes(signature, false);
String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
int dimensions = bytes.readByte();
buf.append(constant_html.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0,False
"@Override
public void visitField(Field obj) {
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isFinal() && obj.isVolatile()) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isStatic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_STATIC modifier set but hasn't!"");
}
if (!obj.isFinal()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_FINAL modifier set but hasn't!"");
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_VOLATILE | Const.ACC_TRANSIENT)) > 0) {
addMessage(""Field '"" + tostring(obj) + ""' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED,"" + "" ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored)."");
}
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
String name = obj.getName();
if (!validFieldName(name)) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' has illegal name '"" + obj.getName() + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
try {
Type.getType(sig);
} catch (ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by '"" + tostring(obj) + ""'."", cfe);
}
String nameanddesc = name + sig;
if (field_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two fields (like '"" + tostring(obj) + ""') are allowed have same names and descriptors!"");
}
if (field_names.contains(name)) {
addMessage(""More than one field of name '"" + name + ""' detected (but with different type descriptors). This is very unusual."");
}
field_names_and_desc.add(nameanddesc);
field_names.add(name);
Attribute[] atts = obj.getAttributes();
for (Attribute att : atts) {
if ((!(att instanceof ConstantValue)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if (!(att instanceof ConstantValue)) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is not a ConstantValue and is therefore only of use for debuggers and such."");
}
}
}",0,False
"String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"" };",0,False
"int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0,True
"// TODO: mutable public array!!
String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"" };",0,False
"@Deprecated
Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = { NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR, EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR };",0,False
"public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {
this.annotationTable = annotationTable;
}",0,False
"public int[] getBootstrapArguments() {
return bootstrapArguments;
}",0,False
"public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrapMethods, final ConstantPool constant_pool) {
super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);
this.bootstrapMethods = bootstrapMethods;
}",0,False
"public int getEndPC() {
return endPc;
}",0,False
"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
"public ConstantPool(final Constant[] constantPool) {
this.constantPool = constantPool;
}",0,False
"ConstantUtf8(final DataInput dataInput) throws IOException {
super(Const.CONSTANT_Utf8);
value = dataInput.readUTF();
created++;
}",0,False
"public Method[] getMethods() {
return methods;
}",0,False
"public LineNumber[] getLineNumberTable() {
return lineNumberTable;
}",0,False
"public void setParameters(final MethodParameter[] parameters) {
this.parameters = parameters;
}",0,False
"public ModuleOpens[] getOpensTable() {
return opensTable;
}",0,False
"public ModuleRequires[] getRequiresTable() {
return requiresTable;
}",0,False
"public AnnotationEntry[] getAnnotationEntries() {
return annotationTable;
}",0,False
"public StackMapEntry[] getStackMap() {
return map;
}",0,False
"public byte[] getBytes() {
return bytes;
}",0,False
"public static String signatureToString(final String signature, final boolean chopit) {
String type = """";
String typeParams = """";
int index = 0;
if (signature.charAt(0) == '<') {
typeParams = typeParamTypesToString(signature, chopit);
index += unwrap(consumed_chars);
}
if (signature.charAt(index) == '(') {
type = typeParams + typeSignaturesToString(signature.substring(index), chopit, ')');
index += unwrap(consumed_chars);
type = type + typeSignatureToString(signature.substring(index), chopit);
index += unwrap(consumed_chars);
return type;
}
type = typeSignatureToString(signature.substring(index), chopit);
index += unwrap(consumed_chars);
if ((typeParams.length() == 0) && (index == signature.length())) {
return type;
}
final StringBuilder typeClass = new StringBuilder(typeParams);
typeClass.append("" extends "");
typeClass.append(type);
if (index < signature.length()) {
typeClass.append("" implements "");
typeClass.append(typeSignatureToString(signature.substring(index), chopit));
index += unwrap(consumed_chars);
}
while (index < signature.length()) {
typeClass.append("", "");
typeClass.append(typeSignatureToString(signature.substring(index), chopit));
index += unwrap(consumed_chars);
}
return typeClass.toString();
}",0,False
"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0,False
"public void setInitValue(final double d) {
checkType(Type.DOUBLE);
if (d != 0.0) {
value = new Double(d);
}
}",0,False
"public int[] getInstructionPositions() {
return bytePositions;
}",0,False
"public void setPositions(final boolean check) {
int max_additional_bytes = 0;
int additional_bytes = 0;
int index = 0;
int count = 0;
final int[] pos = new int[length];
if (check) {
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
final Instruction i = ih.getInstruction();
if (i instanceof BranchInstruction) {
Instruction inst = ((BranchInstruction) i).getTarget().getInstruction();
if (!contains(inst)) {
throw new ClassGenException(""Branch target of "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not in instruction list"");
}
if (i instanceof Select) {
final InstructionHandle[] targets = ((Select) i).getTargets();
for (final InstructionHandle target : targets) {
inst = target.getInstruction();
if (!contains(inst)) {
throw new ClassGenException(""Branch target of "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not in instruction list"");
}
}
}
if (!(ih instanceof BranchHandle)) {
throw new ClassGenException(""Branch instruction "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not contained in BranchHandle."");
}
}
}
}
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
final Instruction i = ih.getInstruction();
ih.setPosition(index);
pos[count++] = index;
switch(i.getOpcode()) {
case Const.JSR:
case Const.GOTO:
max_additional_bytes += 2;
break;
case Const.TABLESWITCH:
case Const.LOOKUPSWITCH:
max_additional_bytes += 3;
break;
}
index += i.getLength();
}
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);
}
index = count = 0;
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
final Instruction i = ih.getInstruction();
ih.setPosition(index);
pos[count++] = index;
index += i.getLength();
}
bytePositions = new int[count];
System.arraycopy(pos, 0, bytePositions, 0, count);
}",0,False
"public Object getValue(final ConstantPoolGen cpg) {
org.apache.bcel.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.bcel.Const.CONSTANT_String:
final int i = ((org.apache.bcel.classfile.ConstantString) c).getStringIndex();
c = cpg.getConstantPool().getConstant(i);
return ((org.apache.bcel.classfile.ConstantUtf8) c).getBytes();
case org.apache.bcel.Const.CONSTANT_Float:
return new Float(((org.apache.bcel.classfile.ConstantFloat) c).getBytes());
case org.apache.bcel.Const.CONSTANT_Integer:
return Integer.valueOf(((org.apache.bcel.classfile.ConstantInteger) c).getBytes());
case org.apache.bcel.Const.CONSTANT_Class:
final int nameIndex = ((org.apache.bcel.classfile.ConstantClass) c).getNameIndex();
c = cpg.getConstantPool().getConstant(nameIndex);
return new ObjectType(((org.apache.bcel.classfile.ConstantUtf8) c).getBytes());
default:
// Never reached
throw new IllegalArgumentException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0,False
"public MethodGen(final int access_flags, final Type return_type, final Type[] argTypes, String[] argNames, final String method_name, final String className, final InstructionList il, final ConstantPoolGen cp) {
super(access_flags);
setType(return_type);
setArgumentTypes(argTypes);
setArgumentNames(argNames);
setName(method_name);
setClassName(className);
setInstructionList(il);
setConstantPool(cp);
final boolean abstract_ = isAbstract() || isNative();
InstructionHandle start = null;
final InstructionHandle end = null;
if (!abstract_) {
start = il.getStart();
if (!isStatic() && (className != null)) {
addLocalVariable(""this"", ObjectType.getInstance(className), start, end);
}
}
if (argTypes != null) {
final int size = argTypes.length;
for (final Type arg_type : argTypes) {
if (Type.VOID == arg_type) {
throw new ClassGenException(""'void' is an illegal argument type for a method"");
}
}
if (argNames != null) {
if (size != argNames.length) {
throw new ClassGenException(""Mismatch in argument array lengths: "" + size + "" vs. "" + argNames.length);
}
} else {
argNames = new String[size];
for (int i = 0; i < size; i++) {
argNames[i] = ""arg"" + i;
}
setArgumentNames(argNames);
}
if (!abstract_) {
for (int i = 0; i < size; i++) {
addLocalVariable(argNames[i], argTypes[i], start, end);
}
}
}
}",0,False
"@Override
public void visitAllocationInstruction(final AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
final short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new IllegalArgumentException(""Unhandled opcode: "" + opcode);
}
}",0,False
"private void updateBranchTargets() {
for (final BranchInstruction bi : branches) {
final BranchHandle bh = (BranchHandle) branch_map.get(bi);
final int pos = bh.getPosition();
final String name = bi.getName() + ""_"" + pos;
int t_pos = bh.getTarget().getPosition();
_out.println(""    "" + name + "".setTarget(ih_"" + t_pos + "");"");
if (bi instanceof Select) {
final InstructionHandle[] ihs = ((Select) bi).getTargets();
for (int j = 0; j < ihs.length; j++) {
t_pos = ihs[j].getPosition();
_out.println(""    "" + name + "".setTarget("" + j + "", ih_"" + t_pos + "");"");
}
}
}
}",0,False
"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
final Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
final int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0,False
"@Override
public String getBase() {
return resolved.getFileName().toString();
}",0,False
"private static void addJdkModules(final String javaHome, final List<String> list) {
String modulesPath = System.getProperty(""java.modules.path"");
if (modulesPath == null || modulesPath.trim().isEmpty()) {
modulesPath = javaHome + File.separator + ""jmods"";
}
final File modulesDir = new File(modulesPath);
if (modulesDir.exists()) {
final String[] modules = modulesDir.list(MODULES_FILTER);
for (String module : modules) {
list.add(modulesDir.getPath() + File.separatorChar + module);
}
}
}",0,False
"private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {
final short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
final StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
final int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (final int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
final int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
final int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
final int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
final ConstantFieldref c1 = (ConstantFieldref) constantPool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constantPool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
final String field_name = constantPool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(className)) {
buf.append(""<A HREF=\"""").append(className).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constantHtml.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
final int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
final ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constantPool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
final ConstantInvokeDynamic c = (ConstantInvokeDynamic) constantPool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(index, Const.CONSTANT_NameAndType)));
final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
final String[] args = Utility.methodSignatureArgumentTypes(signature, false);
final String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(className).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(className).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(className).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
final int dimensions = bytes.readByte();
buf.append(constantHtml.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0,False
"public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0,True
"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0,False
"public void setBootstrapArguments(final int[] bootstrap_arguments) {
this.bootstrap_arguments = bootstrap_arguments;
}",0,False
"public int[] getBootstrapArguments() {
return bootstrap_arguments;
}",0,False
"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
"public Field[] getFields() {
return fields;
}",0,False
"public void setFields(final Field[] fields) {
this.fields = fields;
}",0,False
"public String[] getInterfaceNames() {
return interface_names;
}",0,False
"public final void setLineNumberTable(final LineNumber[] line_number_table) {
this.line_number_table = line_number_table;
}",0,False
"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.local_variable_type_table = local_variable_table;
}",0,False
"public void setParameters(final MethodParameter[] parameters) {
this.parameters = parameters;
}",0,False
"public MethodParameter[] getParameters() {
return parameters;
}",0,False
"public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
return parameter_annotation_table;
}",0,False
"public StackMap(final int name_index, final int length, final StackMapEntry[] map, final ConstantPool constant_pool) {
super(Const.ATTR_STACK_MAP, name_index, length, constant_pool);
this.map = map;
}",0,False
"public StackMapType[] getTypesOfLocals() {
return types_of_locals;
}",0,False
"public final byte[] getBytes() {
return bytes;
}",0,False
"public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool, final boolean verbose) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
System.err.println(""Unreachable default case reached!"");
System.exit(-1);
}
}
}
}
return buf.toString();
}",0,False
"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
"public void setInitValue(final double d) {
checkType(Type.DOUBLE);
if (d != 0.0) {
value = new Double(d);
}
}",0,False
public static final Instruction[] INSTRUCTIONS = new Instruction[256];,0,False
"public CHECKCAST createCheckCast(final ReferenceType t) {
if (t instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) t));
}
return new CHECKCAST(cp.addClass((ObjectType) t));
}",0,False
"protected void addHandle() {
next = ih_list;
ih_list = this;
}",0,False
"public Number getValue(final ConstantPoolGen cpg) {
org.apache.commons.bcel6.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.commons.bcel6.Const.CONSTANT_Long:
return Long.valueOf(((org.apache.commons.bcel6.classfile.ConstantLong) c).getBytes());
case org.apache.commons.bcel6.Const.CONSTANT_Double:
return new Double(((org.apache.commons.bcel6.classfile.ConstantDouble) c).getBytes());
default:
// Never reached
throw new RuntimeException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0,False
"public void setArgumentTypes(final Type[] arg_types) {
this.arg_types = arg_types;
}",0,False
"@Override
public void visitLocalVariableInstruction(final LocalVariableInstruction i) {
short opcode = i.getOpcode();
Type type = i.getType(_cp);
if (opcode == Const.IINC) {
_out.println(""il.append(new IINC("" + i.getIndex() + "", "" + ((IINC) i).getIncrement() + ""));"");
} else {
String kind = (opcode < Const.ISTORE) ? ""Load"" : ""Store"";
_out.println(""il.append(_factory.create"" + kind + ""("" + BCELifier.printType(type) + "", "" + i.getIndex() + ""));"");
}
}",0,False
"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0,False
"@Deprecated
protected List<JavaClass> vec = new ArrayList<>();",0,False
"@Override
public void update(final String classname) {
System.gc();
for (int i = 0; i < indent; i++) {
System.out.print("" "");
}
System.out.println(classname);
indent += 1;
Verifier v = VerifierFactory.getVerifier(classname);
VerificationResult vr;
vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 1:\n"" + vr);
}
vr = v.doPass2();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 2:\n"" + vr);
}
if (vr == VerificationResult.VR_OK) {
try {
JavaClass jc = Repository.lookupClass(v.getClassName());
for (int i = 0; i < jc.getMethods().length; i++) {
vr = v.doPass3a(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3a, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
vr = v.doPass3b(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3b, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
}
} catch (ClassNotFoundException e) {
System.err.println(""Could not find class "" + v.getClassName() + "" in Repository"");
}
}
indent -= 1;
}",0,False
"@Override
public void visitMethod(final Method obj) {
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
String name = obj.getName();
if (!validMethodName(name, true)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
Type t;
Type[] ts;
try {
t = Type.getReturnType(sig);
ts = Type.getArgumentTypes(sig);
} catch (ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by Method '"" + tostring(obj) + ""'."", cfe);
}
Type act = t;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has a return type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
for (Type element : ts) {
act = element;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has an argument type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
}
if (name.equals(Const.STATIC_INITIALIZER_NAME) && (ts.length != 0)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."" + "" Its name resembles the class or interface initialization method"" + "" which it isn't because of its arguments (==descriptor)."");
}
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isAbstract()) {
if (obj.isFinal()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_FINAL modifier set."");
}
if (obj.isNative()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_NATIVE modifier set."");
}
if (obj.isPrivate()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_PRIVATE modifier set."");
}
if (obj.isStatic()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STATIC modifier set."");
}
if (obj.isStrictfp()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STRICT modifier set."");
}
if (obj.isSynchronized()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_SYNCHRONIZED modifier set."");
}
}
if (name.equals(Const.CONSTRUCTOR_NAME)) {
// ..may have at most one of ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC set: is checked above.
if (obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isAbstract()) {
throw new ClassConstraintException(""Instance initialization method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set."");
}
}
} else {
if (!name.equals(Const.STATIC_INITIALIZER_NAME)) {
if (jc.getMajor() >= Const.MAJOR_1_8) {
if (!(obj.isPublic() ^ obj.isPrivate())) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have"" + "" exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set."");
}
if (obj.isProtected() || obj.isFinal() || obj.isSynchronized() || obj.isNative()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isAbstract()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_ABSTRACT modifier set but hasn't!"");
}
if (obj.isPrivate() || obj.isProtected() || obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isStrictfp()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED,"" + "" ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set."");
}
}
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_SYNCHRONIZED | Const.ACC_NATIVE | Const.ACC_ABSTRACT | Const.ACC_STRICT)) > 0) {
addMessage(""Method '"" + tostring(obj) + ""' has access flag(s) other than"" + "" ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,"" + "" ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored)."");
}
String nameanddesc = name + sig;
if (method_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two methods (like '"" + tostring(obj) + ""') are allowed have same names and desciptors!"");
}
method_names_and_desc.add(nameanddesc);
Attribute[] atts = obj.getAttributes();
int num_code_atts = 0;
for (Attribute att : atts) {
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is neither Code nor Exceptions and is therefore only of use for debuggers and such."");
}
if ((att instanceof Code) && (obj.isNative() || obj.isAbstract())) {
throw new ClassConstraintException(""Native or abstract methods like '"" + tostring(obj) + ""' must not have a Code attribute like '"" + tostring(att) + ""'."");
}
if (att instanceof Code) {
num_code_atts++;
}
}
if (!obj.isNative() && !obj.isAbstract() && num_code_atts != 1) {
throw new ClassConstraintException(""Non-native, non-abstract methods like '"" + tostring(obj) + ""' must have exactly one Code attribute (found: "" + num_code_atts + "")."");
}
}",0,False
"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
"private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) {
int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
String saltString = m.group(4);
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage());
}
}",0,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",0,False
"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",0,False
"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase();
}
char[] inwd = txt.toUpperCase().toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
"public RefinedSoundex(char[] mapping) {
this.soundexMapping = mapping;
}",0,True
"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0,False
"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
return buffer.array();
}",0,False
"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0,False
"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,True
"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == '%') {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid URL encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write('%');
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
"public static int hash32(final String text) {
final byte[] bytes = text.getBytes();
return hash32(bytes, bytes.length);
}",0,True
"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0,False
"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
byte b = lineSeparator[lineSeparator.length - 1];
if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,True
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,True
"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
"@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = input[inPos++];
if (b == pad) {
context.eof = true;
break;
}
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus > 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 1:
validateTrailingCharacters();
case 2:
validateCharacter(MASK_2BITS, context);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
validateTrailingCharacters();
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
validateCharacter(MASK_4BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
validateCharacter(MASK_1BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
validateTrailingCharacters();
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
validateCharacter(MASK_3BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
default:
throw new IllegalStateException(""Impossible modulus "" + context.modulus);
}
}
}",0,False
"private static void packInt(final int value, final byte[] dst, final int off, final int len) {
for (int i = 0; i < len; i++) {
dst[off + i] = (byte) (value >>> i * Byte.SIZE);
}
}",0,False
"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0,False
"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
"private static byte[] getBytes(String string, Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else {
if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
}
return buffer.array();
}",0,False
"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus >= 2) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
}
}
}",1,False
"@Deprecated
public static int hash32(final String data) {
final byte[] bytes = data.getBytes();
return hash32(bytes, 0, bytes.length, DEFAULT_SEED);
}",1,True
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
switch(modulus) {
case 2:
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3:
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
}
}
}",0,False
protected static byte ESCAPE_CHAR = '%';,1,False
"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
final int savedPos = context.pos;
switch(context.modulus) {
case 1:
// top 6 bits:
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
}
break;
case 2:
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",1,False
"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1,True
"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
// top 6 bits:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
modulus = (++modulus) % 4;
x = x << 6;
switch(modulus) {
case 3:
x = x << 6;
case 0:
buf[pos++] = (byte) ((x >> 16) & 0xff);
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 8) & 0xff);
}
default:
eof = true;
return;
}
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (byte) ((++modulus) % 4);
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & 0xff);
buf[pos++] = (byte) ((x >> 8) & 0xff);
buf[pos++] = (byte) (x & 0xff);
}
}
}
}
}
}",0,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",1,False
"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize, context);
byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (context.eof && context.modulus != 0) {
ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
context.ibitWorkArea = context.ibitWorkArea >> 4;
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
case 3:
context.ibitWorkArea = context.ibitWorkArea >> 2;
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
}
}
}",0,True
"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase();
}
char[] inwd = txt.toUpperCase().toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",1,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
eof = true;
return;
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buf[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
}",0,True
private final byte ESCAPE_CHAR = '%';,1,False
"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",1,False
"public static byte[] sha256(String data) {
return sha256(data.getBytes());
}",1,True
"static String clean(String str) {
if (str == null || str.length() == 0) {
return str;
}
int len = str.length();
char[] chars = new char[len];
int count = 0;
for (int i = 0; i < len; i++) {
if (Character.isLetter(str.charAt(i))) {
chars[count++] = str.charAt(i);
}
}
if (count == len) {
return str.toUpperCase();
}
return new String(chars, 0, count).toUpperCase();
}",1,False
"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",1,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
modulus = (++modulus) % 4;
x = x << 6;
switch(modulus) {
case 3:
x = x << 6;
case 0:
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
}
default:
eof = true;
return;
}
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buf[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
}",1,True
"public long getEncodedLength(byte[] pArray) {
long len = ((pArray.length + unencodedBlockSize - 1) / unencodedBlockSize) * encodedBlockSize;
if (lineLength > 0) {
len += ((len + lineLength - 1) / lineLength) * chunkSeparatorLength;
}
return len;
}",1,False
"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
"public static int hash32(final String data) {
final byte[] origin = data.getBytes();
return hash32(origin, 0, origin.length, DEFAULT_SEED);
}",0,False
"@SuppressWarnings(""unchecked"")
protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map, final Class<C> collectionClazz, final int initialCollectionCapacity) {
if (map == null) {
throw new IllegalArgumentException(""Map must not be null"");
}
if (initialCollectionCapacity < 0) {
throw new IllegalArgumentException(""Illegal Capacity: "" + initialCollectionCapacity);
}
this.map = (Map<K, Collection<V>>) map;
this.collectionFactory = new InstantiateFactory<C>(collectionClazz, new Class[] { Integer.TYPE }, new Object[] { new Integer(initialCollectionCapacity) });
}",1,False
"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",1,False
"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0,False
"private UnmodifiableBidiMap<V, K> inverse;",0,False
"private final Transformer<C, K> keyTransformer;",0,False
"private final Transformer<? super I, ? extends O> transformer;",0,False
private final Closure<? super E>[] iClosures;,0,False
private final Closure<? super T> iClosure;,0,False
"@SuppressWarnings(""unchecked"")
static <T> Predicate<T>[] copy(final Predicate<? super T>... predicates) {
if (predicates == null) {
return null;
}
return (Predicate<T>[]) predicates.clone();
}",0,False
private final Predicate<? super T> iPredicate;,0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0,False
"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0,False
"@Override
public int hashCode() {
return hash;
}",0,False
"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0,False
"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0,False
"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0,False
"private UnmodifiableBidiMap<V, K> inverse;",0,False
"boolean add(long bits) {
if (size == data.length) {
data = Arrays.copyOf(data, size * 2);
}
data[size++] = bits;
return true;
}",0,False
private final Comparator<T> comparator;,0,False
private final Factory<? extends O> iFactory;,0,False
private final Closure<? super E> iFalseClosure;,0,False
"private final Transformer<? super I, ? extends O> iFalseTransformer;",0,False
private final Predicate<? super T> iPredicate;,0,False
private final Predicate<? super T> iPredicate;,0,False
private final Predicate<? super T> iPredicate;,0,False
private final Predicate<? super E>[] iPredicates;,0,False
"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0,False
"@Override
public int hashCode() {
return hash;
}",0,False
"private UnmodifiableBidiMap<V, K> inverse;",0,False
private final Comparator<E> comparator;,0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0,False
"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0,False
"@Override
public int hashCode() {
return hash;
}",0,False
"private final Transformer<C, K> keyTransformer;",0,False
"private final Transformer<? super I, ? extends O> transformer;",0,False
private final Predicate<? super T> iPredicate;,0,False
private final Predicate<? super T> iPredicate;,0,False
"V currentValue, nextValue;",0,False
"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0,False
"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0,False
"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
return SetUtils.hashCodeForSet(set);
}",0,False
"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0,False
"private UnmodifiableBidiMap<V, K> inverse;",0,False
"protected final Transformer<? super E, ? extends E> transformer;",0,False
private transient Method iCloneMethod;,0,False
"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0,False
"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0,False
"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0,False
"@SuppressWarnings(""unchecked"")
public void add(int index, V value) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) AbstractListValuedMap.this.createCollection();
list.add(index, value);
getMap().put((K) key, list);
}
list.add(index, value);
}",0,False
"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0,False
"private final Transformer<? super K, ? extends K> keyTransformer;",0,False
private final Equator<T> equator;,0,False
private final Factory<? extends O> iFactory;,0,False
"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0,False
"public E[] getArray() {
return this.array;
}",0,False
"protected List<E> getList() {
return (List<E>) decorated();
}",0,False
"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0,False
"@Override
public boolean equals(final Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (!(other instanceof Set)) {
return false;
}
final Set<?> otherSet = (Set<?>) other;
return SetUtils.isEqualSet(set, otherSet);
}",0,False
"@Override
public String getProperty(final String key, final String defaultValue) {
return defaultValue;
}",0,False
"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0,False
"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0,False
"@Override
public Set<E> uniqueSet() {
synchronized (lock) {
final Set<E> set = getBag().uniqueSet();
return new SynchronizedBagSet(set, lock);
}
}",0,False
"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0,False
"@Override
public boolean equals(final Object obj) {
return this.doEquals(obj, KEY);
}",0,False
"private final Transformer<C, K> keyTransformer;",0,False
"@SuppressWarnings(""unchecked"")
static <E> Closure<E>[] copy(final Closure<? super E>... closures) {
if (closures == null) {
return null;
}
return (Closure<E>[]) closures.clone();
}",0,False
"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0,False
private final Predicate<? super T> iPredicate;,0,False
"public ObjectArrayIterator(final E[] array, final int start, final int end) {
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0,False
"public E[] getArray() {
return this.array;
}",0,False
"@Override
protected List<E> decorated() {
return (List<E>) super.decorated();
}",0,False
"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0,False
"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0,False
"protected ReferenceEntry<K, V> nextEntry() {
checkMod();
if (nextNull() && !hasNext()) {
throw new NoSuchElementException();
}
previous = entry;
entry = entry.next();
currentKey = nextKey;
currentValue = nextValue;
nextKey = null;
nextValue = null;
return previous;
}",0,False
"protected void purge(final Reference<?> ref) {
final int hash = ref.hashCode();
final int index = hashIndex(hash, data.length);
HashEntry<K, V> previous = null;
HashEntry<K, V> entry = data[index];
while (entry != null) {
final ReferenceEntry<K, V> refEntry = (ReferenceEntry<K, V>) entry;
if (refEntry.purge(ref)) {
if (previous == null) {
data[index] = entry.next;
} else {
previous.next = entry.next;
}
this.size--;
refEntry.onPurge();
return;
}
previous = entry;
entry = entry.next;
}
}",0,False
"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0,False
"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0,False
"@Override
public void clear() {
final Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();
final Set<K> currentKeys = keySet();
while (it.hasNext()) {
if (currentKeys.contains(it.next().getKey())) {
it.remove();
}
}
}",0,False
"public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {
if (map != null) {
final Object answer = map.get(key);
if (answer != null) {
if (answer instanceof Boolean) {
return (Boolean) answer;
}
if (answer instanceof String) {
return Boolean.valueOf((String) answer);
}
if (answer instanceof Number) {
final Number n = (Number) answer;
return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;
}
}
}
return null;
}",0,False
"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0,False
"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0,False
"@Override
protected LinkEntry<K, V> getEntry(final Object key) {
return (LinkEntry<K, V>) super.getEntry(key);
}",0,False
"@Override
protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.before.after = link.after;
link.after.before = link.before;
link.after = null;
link.before = null;
super.removeEntry(entry, hashIndex, previous);
}",0,False
"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0,False
"@SuppressWarnings(""unchecked"")
public void add(int index, V value) {
List<V> list = (List<V>) getMapping();
if (list == null) {
list = (List<V>) AbstractListValuedMap.this.createCollection();
list.add(index, value);
getMap().put((K) key, list);
}
list.add(index, value);
}",0,False
"public V remove(int index) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
V value = list.remove(index);
if (list.isEmpty()) {
AbstractListValuedMap.this.remove(key);
}
return value;
}",0,False
private transient KeysBag keysBagView;,0,False
"@Override
public boolean equals(Object other) {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().equals(other);
}
if (other == null) {
return false;
}
if (!(other instanceof Set)) {
return false;
}
Set<?> otherSet = (Set<?>) other;
if (SetUtils.isEqualSet(set, otherSet) == false) {
return false;
}
return true;
}",0,False
"@Override
public int hashCode() {
final Set<V> set = (Set<V>) getMapping();
if (set == null) {
return Collections.emptySet().hashCode();
}
return SetUtils.hashCodeForSet(set);
}",0,False
"private final Transformer<? super K, ? extends K> keyTransformer;",0,False
"@Override
public boolean equals(final Object obj) {
return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
}",0,False
"protected List<E> getList() {
return (List<E>) decorated();
}",0,False
"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0,False
"V currentValue, nextValue;",0,False
"private void convertToMap() {
delegateMap = createDelegateMap();
switch(size) {
case 3:
delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
case 1:
delegateMap.put(key1, value1);
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
size = 0;
hash1 = hash2 = hash3 = 0;
key1 = key2 = key3 = null;
value1 = value2 = value3 = null;
}",0,False
"@Override
public int hashCode() {
if (delegateMap != null) {
return delegateMap.hashCode();
}
int total = 0;
switch(size) {
case 3:
total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
case 1:
total += hash1 ^ (value1 == null ? 0 : value1.hashCode());
case 0:
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
return total;
}",0,False
"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0,False
"public int lastIndexOf(Object o) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.indexOf(o);
}",0,False
"private final Transformer<? super K, ? extends K> keyTransformer;",0,False
"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0,False
"@Override
public List<T> get(final int index) {
final int listSize = size();
if (listSize < 0) {
throw new IllegalArgumentException(""negative size: "" + listSize);
}
if (index < 0) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must not be negative"");
}
if (index >= listSize) {
throw new IndexOutOfBoundsException(""Index "" + index + "" must be less than size "" + listSize);
}
final int start = index * size;
final int end = Math.min(start + size, list.size());
return list.subList(start, end);
}",0,False
"@SuppressWarnings(""unchecked"")
static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>... transformers) {
if (transformers == null) {
return null;
}
return (Transformer<I, O>[]) transformers.clone();
}",0,False
"private final Transformer<? super I, ? extends O> iFalseTransformer;",0,False
"private final Transformer<? super I, ? extends O> iDefault;",0,False
"protected List<E> getList() {
return (List<E>) decorated();
}",0,False
"private AVLNode<E> removeSelf() {
if (getRightSubTree() == null && getLeftSubTree() == null) {
return null;
}
if (getRightSubTree() == null) {
if (relativePosition > 0) {
left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
}
left.max().setRight(null, right);
return left;
}
if (getLeftSubTree() == null) {
right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
right.min().setLeft(null, left);
return right;
}
if (heightRightMinusLeft() > 0) {
final AVLNode<E> rightMin = right.min();
value = rightMin.value;
if (leftIsPrevious) {
left = rightMin.left;
}
right = right.removeMin();
if (relativePosition < 0) {
relativePosition++;
}
} else {
final AVLNode<E> leftMax = left.max();
value = leftMax.value;
if (rightIsNext) {
right = leftMax.right;
}
final AVLNode<E> leftPrevious = left.left;
left = left.removeMax();
if (left == null) {
left = leftPrevious;
leftIsPrevious = true;
}
if (relativePosition > 0) {
relativePosition--;
}
}
recalcHeight();
return this;
}",0,False
"@Override
protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {
final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
link.after = header;
link.before = header.before;
header.before.after = link;
header.before = link;
data[hashIndex] = link;
}",0,False
"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0,False
"@SuppressWarnings(""unchecked"")
public void add(V value) {
if (getMap().get(key) == null) {
List<V> list = (List<V>) createCollection();
getMap().put((K) key, list);
this.values = list;
this.iterator = list.listIterator();
}
this.iterator.add(value);
}",0,False
"public V set(int index, V value) {
final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
return list.set(index, value);
}",0,False
"@SuppressWarnings(""unchecked"")
public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {
if (map instanceof Unmodifiable) {
return (UnmodifiableMultiValuedMap<K, V>) map;
}
return new UnmodifiableMultiValuedMap<K, V>(map);
}",0,False
"protected SortedSet<E> getSortedSet() {
return (SortedSet<E>) decorated();
}",0,False
"private final Transformer<C, K> keyTransformer;",0,False
private final Comparator<E> comparator;,0,False
"private final Transformer<? super I, ? extends O> iTrueTransformer;",0,False
"private final Transformer<? super I, ? extends O> iDefault;",0,False
"public ObjectArrayIterator(final E[] array, final int start, final int end) {
super();
if (start < 0) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be less than zero"");
}
if (end > array.length) {
throw new ArrayIndexOutOfBoundsException(""End index must not be greater than the array length"");
}
if (start > array.length) {
throw new ArrayIndexOutOfBoundsException(""Start index must not be greater than the array length"");
}
if (end < start) {
throw new IllegalArgumentException(""End index must not be less than start index"");
}
this.array = array;
this.startIndex = start;
this.endIndex = end;
this.index = start;
}",0,False
"protected List<E> getList() {
return (List<E>) decorated();
}",0,False
"@Override
public int hashCode() {
return hash;
}",0,False
"@Override
public String toString() {
if (delegateMap != null) {
return delegateMap.toString();
}
if (size == 0) {
return ""{}"";
}
final StringBuilder buf = new StringBuilder(128);
buf.append('{');
switch(size) {
case 3:
buf.append(key3 == this ? ""(this Map)"" : key3);
buf.append('=');
buf.append(value3 == this ? ""(this Map)"" : value3);
buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
buf.append('=');
buf.append(value2 == this ? ""(this Map)"" : value2);
buf.append(',');
case 1:
buf.append(key1 == this ? ""(this Map)"" : key1);
buf.append('=');
buf.append(value1 == this ? ""(this Map)"" : value1);
break;
default:
throw new IllegalStateException(""Invalid map index: "" + size);
}
buf.append('}');
return buf.toString();
}",0,False
"@Override
protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {
moveToMRU((LinkEntry<K, V>) entry);
entry.setValue(newValue);
}",0,False
protected V value;,0,False
"@Override
protected Set<E> decorated() {
return (Set<E>) super.decorated();
}",0,False
"static File constructFile(String basePath, String fileName) {
File file = null;
File absolute = null;
if (fileName != null) {
absolute = new File(fileName);
}
if (StringUtils.isEmpty(basePath) || (absolute != null && absolute.isAbsolute())) {
file = new File(fileName);
} else {
StringBuffer fName = new StringBuffer();
fName.append(basePath);
if (!basePath.endsWith(File.separator)) {
fName.append(File.separator);
}
if (fileName.startsWith(""."" + File.separator)) {
fName.append(fileName.substring(2));
} else {
fName.append(fileName);
}
file = new File(fName.toString());
}
return file;
}",0,False
"public boolean containsKey(String key) {
boolean found = false;
StringBuilder query = new StringBuilder(""SELECT * FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
ResultSet rs = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
rs = pstmt.executeQuery();
found = rs.next();
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt, rs);
}
return found;
}",1,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
} else {
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
private final ConversionHandler dataConversionHandler;,1,False
"public void init() {
if (configuration.getURL() == null && configuration.getFileName() == null) {
return;
}
if (this.configuration == null) {
throw new IllegalStateException(""No configuration has been set for this strategy"");
}
updateLastModified();
}",0,False
private final HttpFileSystemConfigBuilder httpBuilder;,1,False
"private void setProperty(FileSystemConfigBuilder builder, FileSystemOptions options, String key, Object value) {
String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
Class[] paramTypes = new Class[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
Method method = builder.getClass().getMethod(methodName, paramTypes);
Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (Exception ex) {
return;
}
}",0,False
"private FileSystemOptions getOptions(final String scheme) {
if (scheme == null) {
return null;
}
final FileSystemOptions opts = new FileSystemOptions();
FileSystemConfigBuilder builder;
try {
builder = getManager().getFileSystemConfigBuilder(scheme);
} catch (final Exception ex) {
return null;
}
final FileOptionsProvider provider = getFileOptionsProvider();
if (provider != null) {
final Map<String, Object> map = provider.getOptions();
if (map == null) {
return null;
}
int count = 0;
for (final Map.Entry<String, Object> entry : map.entrySet()) {
try {
String key = entry.getKey();
if (FileOptionsProvider.CURRENT_USER.equals(key)) {
key = ""creatorName"";
}
setProperty(builder, opts, key, entry.getValue());
++count;
} catch (final Exception ex) {
continue;
}
}
if (count > 0) {
return opts;
}
}
return null;
}",0,False
"final public String String() throws ParseException {
Token token = null;
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
return unescapeQuotes(removeQuotes(token.image));
case STRING:
token = jj_consume_token(STRING);
return token.image;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}",0,False
"private static Class<?> getDefaultClass(final Object bean, final String propName) {
try {
final PropertyDescriptor desc = BEAN_UTILS_BEAN.getPropertyUtils().getPropertyDescriptor(bean, propName);
if (desc == null) {
return null;
}
return desc.getPropertyType();
} catch (final Exception ex) {
return null;
}
}",0,False
"static File constructFile(String basePath, String fileName) {
File file;
File absolute = null;
if (fileName != null) {
absolute = new File(fileName);
}
if (StringUtils.isEmpty(basePath) || (absolute != null && absolute.isAbsolute())) {
file = new File(fileName);
} else {
StringBuilder fName = new StringBuilder();
fName.append(basePath);
if (!basePath.endsWith(File.separator)) {
fName.append(File.separator);
}
if (fileName.startsWith(""."" + File.separator)) {
fName.append(fileName.substring(2));
} else {
fName.append(fileName);
}
file = new File(fName.toString());
}
return file;
}",0,False
"public void addDataValue(String value) {
addValue(Base64.decodeBase64(value.getBytes()));
}",1,False
"@Override
protected void addPropertyDirect(String key, Object obj) {
StringBuilder query = new StringBuilder(""INSERT INTO "" + table);
if (nameColumn != null) {
query.append("" ("" + nameColumn + "", "" + keyColumn + "", "" + valueColumn + "") VALUES (?, ?, ?)"");
} else {
query.append("" ("" + keyColumn + "", "" + valueColumn + "") VALUES (?, ?)"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
int index = 1;
if (nameColumn != null) {
pstmt.setString(index++, name);
}
pstmt.setString(index++, key);
pstmt.setString(index++, String.valueOf(obj));
pstmt.executeUpdate();
commitIfRequired(conn);
} catch (SQLException e) {
fireError(EVENT_ADD_PROPERTY, key, obj, e);
} finally {
close(conn, pstmt, null);
}
}",1,False
"static Object toInternetAddress(Object value) throws ConversionException {
if (value.getClass().getName().equals(INTERNET_ADDRESS_CLASSNAME)) {
return value;
} else if (value instanceof String) {
try {
Constructor ctor = Class.forName(INTERNET_ADDRESS_CLASSNAME).getConstructor(new Class[] { String.class });
return ctor.newInstance(new Object[] { value });
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"", e);
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"");
}
}",0,False
private AutoSaveListener autoSaveListener;,0,False
"static File constructFile(String basePath, String fileName) {
File file;
File absolute = null;
if (fileName != null) {
absolute = new File(fileName);
}
if (StringUtils.isEmpty(basePath) || (absolute != null && absolute.isAbsolute())) {
file = new File(fileName);
} else {
file = new File(appendPath(basePath, fileName));
}
return file;
}",0,False
"static File constructFile(String basePath, String fileName) {
File file;
File absolute = null;
if (fileName != null) {
absolute = new File(fileName);
}
if (StringUtils.isEmpty(basePath) || (absolute != null && absolute.isAbsolute())) {
file = new File(fileName);
} else {
file = new File(appendPath(basePath, fileName));
}
return file;
}",0,False
"private Map<String, Configuration> namedConfigurations;",0,False
private final Configuration configuration;,0,False
"@Override
public void setRootNode(ConfigurationNode rootNode) {
if (init) {
getConfig().setRootNode(rootNode);
} else {
super.setRootNode(rootNode);
}
}",0,False
private ReloadingController reloadingController;,1,False
"public void setValue(final Object value) throws ConfigurationRuntimeException {
try {
if (!(value instanceof String)) {
this.value = value;
return;
}
final String val = (String) value;
final String name = StringUtils.removeStartIgnoreCase(val, CLASS);
final Class<?> clazz = ClassUtils.getClass(name);
if (name.length() == val.length()) {
this.value = clazz.newInstance();
} else {
this.value = clazz;
}
} catch (final Exception e) {
throw new ConfigurationRuntimeException(""Unable to create "" + value, e);
}
}",0,False
private ExpressionEngine conversionExpressionEngine;,0,False
"public org.apache.xml.resolver.Catalog getPrivateCatalog() {
org.apache.xml.resolver.Catalog catalog = staticCatalog;
if (catalog == null || !getUseStaticCatalog()) {
try {
catalog = new Catalog();
catalog.setCatalogManager(this);
catalog.setupReaders();
catalog.loadSystemCatalogs();
} catch (Exception ex) {
ex.printStackTrace();
}
if (getUseStaticCatalog()) {
staticCatalog = catalog;
}
}
return catalog;
}",0,False
private List<ConfigData> configurations = new ArrayList<ConfigData>();,0,False
"protected Object resolveContainerStore(String key) {
Object value = getProperty(key);
if (value != null) {
if (value instanceof List) {
List list = (List) value;
value = list.isEmpty() ? null : list.get(0);
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
value = array.length == 0 ? null : array[0];
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
value = array.length == 0 ? null : array[0] ? Boolean.TRUE : Boolean.FALSE;
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
value = array.length == 0 ? null : new Byte(array[0]);
} else if (value instanceof short[]) {
short[] array = (short[]) value;
value = array.length == 0 ? null : new Short(array[0]);
} else if (value instanceof int[]) {
int[] array = (int[]) value;
value = array.length == 0 ? null : new Integer(array[0]);
} else if (value instanceof long[]) {
long[] array = (long[]) value;
value = array.length == 0 ? null : new Long(array[0]);
} else if (value instanceof float[]) {
float[] array = (float[]) value;
value = array.length == 0 ? null : new Float(array[0]);
} else if (value instanceof double[]) {
double[] array = (double[]) value;
value = array.length == 0 ? null : new Double(array[0]);
}
}
return value;
}",1,False
"static File constructFile(String basePath, String fileName) {
File file;
File absolute = null;
if (fileName != null) {
absolute = new File(fileName);
}
if (StringUtils.isEmpty(basePath) || (absolute != null && absolute.isAbsolute())) {
file = new File(fileName);
} else {
StringBuilder fName = new StringBuilder();
fName.append(basePath);
if (!basePath.endsWith(File.separator)) {
fName.append(File.separator);
}
if (fileName.startsWith(""."" + File.separator)) {
fName.append(fileName.substring(2));
} else {
fName.append(fileName);
}
file = new File(fName.toString());
}
return file;
}",0,False
"static File constructFile(String basePath, String fileName) {
File file;
File absolute = null;
if (fileName != null) {
absolute = new File(fileName);
}
if (StringUtils.isEmpty(basePath) || (absolute != null && absolute.isAbsolute())) {
file = new File(fileName);
} else {
file = new File(appendPath(basePath, fileName));
}
return file;
}",0,False
"private static boolean checkCombineLines(String line) {
int bsCount = 0;
for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\'; idx--) {
bsCount++;
}
return bsCount % 2 == 1;
}",1,False
"public void setDetailEvents(boolean enable) {
synchronized (listeners) {
if (enable) {
detailEvents++;
} else {
detailEvents--;
}
}
}",0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue)).floatValue();
}",1,False
"public byte getByte(String key, byte defaultValue) {
return getByte(key, new Byte(defaultValue)).byteValue();
}",1,False
"public void setLocations(Resource[] locations) {
this.locations = locations;
}",1,True
private ConfigurationNode rootNode;,0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
} else {
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"private void setProperty(FileSystemConfigBuilder builder, FileSystemOptions options, String key, Object value) {
String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
Method method = builder.getClass().getMethod(methodName, paramTypes);
Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (Exception ex) {
log.warn(""Cannot access property '"" + key + ""'! Ignoring."", ex);
}
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
EntityResolver resolver = new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler();
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
getNodeModel().mergeRoot(handler.getResultBuilder().createNode(), null, null, null, this);
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
private final NodeHandler<T> handler;,0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue)).floatValue();
}",0,False
"public void load(InputStream in, String encoding) throws ConfigurationException {
Reader reader = null;
if (encoding != null) {
try {
reader = new InputStreamReader(in, encoding);
} catch (UnsupportedEncodingException e) {
throw new ConfigurationException(""The requested encoding is not supported, try the default encoding."", e);
}
}
if (reader == null) {
reader = new InputStreamReader(in);
}
load(reader);
}",0,False
private List<ConfigData> configurations;,0,False
"public boolean isEmpty() {
boolean empty = true;
StringBuilder query = new StringBuilder(""SELECT count(*) FROM "" + table);
if (nameColumn != null) {
query.append("" WHERE "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
ResultSet rs = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
if (nameColumn != null) {
pstmt.setString(1, name);
}
rs = pstmt.executeQuery();
if (rs.next()) {
empty = rs.getInt(1) == 0;
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, null, null, e);
} finally {
close(conn, pstmt, rs);
}
return empty;
}",0,False
"@Override
protected void clearPropertyDirect(String key) {
StringBuilder query = new StringBuilder(""DELETE FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
pstmt.executeUpdate();
commitIfRequired(conn);
} catch (SQLException e) {
fireError(EVENT_CLEAR_PROPERTY, key, null, e);
} finally {
close(conn, pstmt, null);
}
}",0,False
"public Object createBean(Class<?> beanClass, BeanDeclaration data, Object param) throws Exception {
ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
String tagName = decl.getNode().getName();
ConfigurationProvider provider = decl.getConfigurationBuilder().providerForTag(tagName);
if (provider == null) {
throw new ConfigurationRuntimeException(""No ConfigurationProvider registered for tag "" + tagName);
}
try {
AbstractConfiguration config = provider.getConfiguration(decl);
installInterpolator(decl, config);
return config;
} catch (Exception ex) {
if (!decl.isOptional()) {
throw ex;
} else {
if (logger.isDebugEnabled()) {
logger.debug(""Load failed for optional configuration "" + tagName + "": "" + ex.getMessage());
}
decl.getConfigurationBuilder().fireError(EVENT_ERR_LOAD_OPTIONAL, decl.getConfiguration().getString(ATTR_NAME), null, ex);
if (decl.isForceCreate()) {
try {
return provider.getEmptyConfiguration(decl);
} catch (Exception ex2) {
logger.warn(""Could not create instance of optional configuration "" + tagName, ex2);
}
}
return null;
}
}
}",0,False
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0,False
"private void createPath(File file) {
if (file != null) {
if (!file.exists()) {
File parent = file.getParentFile();
if (parent != null && !parent.exists()) {
parent.mkdirs();
}
}
}
}",0,False
"@Override
public void setRootNode(ConfigurationNode rootNode) {
if (init) {
this.getConfiguration().setRootNode(rootNode);
} else {
super.setRootNode(rootNode);
}
}",0,False
"@Override
public long getLong(String key) {
return config.getLong(makePath(key));
}",0,False
"@Override
public void load(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
// todo: support included properties ?
}",0,False
"public void init() {
if (configuration.getURL() == null && configuration.getFileName() == null) {
return;
}
if (this.configuration == null) {
throw new IllegalStateException(""No configuration has been set for this strategy"");
}
updateLastModified();
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = ConfigurationUtils.locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = ConfigurationUtils.locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"public NodePointer getNodePointer() {
if (getPosition() < 1 && !setPosition(1)) {
return null;
}
return createNodePointer(subNodes.get(positionToIndex(getPosition())));
}",0,False
private ConfigurationNode node;,0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
final Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
final ByteArrayOutputStream os = new ByteArrayOutputStream();
final PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}",0,False
"public static Synchronizer cloneSynchronizer(final Synchronizer sync) {
if (sync == null) {
throw new IllegalArgumentException(""Synchronizer must not be null!"");
}
if (NoOpSynchronizer.INSTANCE == sync) {
return sync;
}
try {
return sync.getClass().newInstance();
} catch (final Exception ex) {
LOG.info(""Cannot create new instance of "" + sync.getClass());
}
try {
return (Synchronizer) clone(sync);
} catch (final CloneNotSupportedException cnex) {
throw new ConfigurationRuntimeException(""Cannot clone Synchronizer "" + sync);
}
}",0,False
"public static void dump(final ImmutableConfiguration configuration, final PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"private void setProperty(final FileSystemConfigBuilder builder, final FileSystemOptions options, final String key, final Object value) {
final String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
final Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
final Method method = builder.getClass().getMethod(methodName, paramTypes);
final Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (final Exception ex) {
log.warn(""Cannot access property '"" + key + ""'! Ignoring."", ex);
}
}",0,False
"public static URL locate(FileSystem fileSystem, String base, String name) {
if (LOG.isDebugEnabled()) {
StringBuilder buf = new StringBuilder();
buf.append(""ConfigurationUtils.locate(): base is "").append(base);
buf.append("", name is "").append(name);
LOG.debug(buf.toString());
}
if (name == null) {
return null;
}
URL url = fileSystem.locateFromURL(base, name);
if (url == null) {
File file = new File(name);
if (file.isAbsolute() && file.exists()) {
try {
url = toURL(file);
LOG.debug(""Loading configuration from the absolute path "" + name);
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
}
if (url == null) {
try {
File file = constructFile(base, name);
if (file != null && file.exists()) {
url = toURL(file);
}
if (url != null) {
LOG.debug(""Loading configuration from the path "" + file);
}
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
try {
File file = constructFile(System.getProperty(""user.home""), name);
if (file != null && file.exists()) {
url = toURL(file);
}
if (url != null) {
LOG.debug(""Loading configuration from the home path "" + file);
}
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
url = locateFromClasspath(name);
}
return url;
}",0,False
"public boolean isEmpty() {
boolean empty = true;
StringBuilder query = new StringBuilder(""SELECT count(*) FROM "" + table);
if (nameColumn != null) {
query.append("" WHERE "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
if (nameColumn != null) {
pstmt.setString(1, name);
}
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
empty = rs.getInt(1) == 0;
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, null, null, e);
} finally {
close(conn, pstmt);
}
return empty;
}",0,False
"public boolean containsKey(String key) {
boolean found = false;
StringBuilder query = new StringBuilder(""SELECT * FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
found = rs.next();
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
return found;
}",0,False
private final Object reloadLock;,0,False
"static Object toInternetAddress(Object value) throws ConversionException {
if (value.getClass().getName().equals(INTERNET_ADDRESS_CLASSNAME)) {
return value;
} else if (value instanceof String) {
try {
Constructor<?> ctor = Class.forName(INTERNET_ADDRESS_CLASSNAME).getConstructor(new Class[] { String.class });
return ctor.newInstance(new Object[] { value });
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"", e);
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"");
}
}",0,False
"public static Float toFloat(Object value) throws ConversionException {
Number n = toNumber(value, Float.class);
if (n instanceof Float) {
return (Float) n;
} else {
return new Float(n.floatValue());
}
}",0,False
private final String protocol;,0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"public byte getByte(String key, byte defaultValue) {
return getByte(key, new Byte(defaultValue)).byteValue();
}",0,False
"private ConfigurationNode constructCombinedNode() {
if (getNumberOfConfigurations() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
} else {
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = getNodeCombiner().combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"@Override
protected void addPropertyDirect(String key, Object obj) {
StringBuilder query = new StringBuilder(""INSERT INTO "" + table);
if (nameColumn != null) {
query.append("" ("" + nameColumn + "", "" + keyColumn + "", "" + valueColumn + "") VALUES (?, ?, ?)"");
} else {
query.append("" ("" + keyColumn + "", "" + valueColumn + "") VALUES (?, ?)"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
int index = 1;
if (nameColumn != null) {
pstmt.setString(index++, name);
}
pstmt.setString(index++, key);
pstmt.setString(index++, String.valueOf(obj));
pstmt.executeUpdate();
commitIfRequired(conn);
} catch (SQLException e) {
fireError(EVENT_ADD_PROPERTY, key, obj, e);
} finally {
close(conn, pstmt, null);
}
}",0,False
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0,False
private ConfigurationNode rootNode;,0,False
"public Lock(String name) {
this.name = name;
synchronized (counterLock) {
instanceId = ++counter;
}
}",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"private AbstractHierarchicalFileConfiguration getConfiguration() {
if (pattern == null) {
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path)) {
return configurationsMap.get(path);
}
if (path.equals(pattern)) {
XMLConfiguration configuration = new XMLConfiguration() {
@Override
public void load() throws ConfigurationException {
}
@Override
public void save() throws ConfigurationException {
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null) {
Log log = LogFactory.getLog(loggerName);
if (log != null) {
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null) {
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try {
configuration.load();
} catch (ConfigurationException ce) {
if (isThrowable(ce)) {
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}",0,False
"public static Short toShort(Object value) throws ConversionException {
Number n = toNumber(value, Short.class);
if (n instanceof Short) {
return (Short) n;
} else {
return new Short(n.shortValue());
}
}",0,False
"public static Long toLong(Object value) throws ConversionException {
Number n = toNumber(value, Long.class);
if (n instanceof Long) {
return (Long) n;
} else {
return new Long(n.longValue());
}
}",0,False
"private void setProperty(FileSystemConfigBuilder builder, FileSystemOptions options, String key, Object value) {
String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
Method method = builder.getClass().getMethod(methodName, paramTypes);
Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (Exception ex) {
return;
}
}",0,False
"@Override
public void save(Writer out) throws ConfigurationException {
PrintWriter writer = new PrintWriter(out);
String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
writer.println(""<?xml version=\""1.0\"" encoding=\"""" + encoding + ""\""?>"");
writer.println(""<!DOCTYPE properties SYSTEM \""http://java.sun.com/dtd/properties.dtd\"">"");
writer.println(""<properties>"");
if (getHeader() != null) {
writer.println(""  <comment>"" + StringEscapeUtils.escapeXml(getHeader()) + ""</comment>"");
}
Iterator<String> keys = getKeys();
while (keys.hasNext()) {
String key = keys.next();
Object value = getProperty(key);
if (value instanceof List) {
writeProperty(writer, key, (List<?>) value);
} else {
writeProperty(writer, key, value);
}
}
writer.println(""</properties>"");
writer.flush();
}",0,False
"private static Class<?> getDefaultClass(Object bean, String propName) {
try {
PropertyDescriptor desc = PropertyUtils.getPropertyDescriptor(bean, propName);
if (desc == null) {
return null;
}
return desc.getPropertyType();
} catch (Exception ex) {
return null;
}
}",0,False
"public void setValue(Object value) throws ConfigurationRuntimeException {
try {
if (!(value instanceof String)) {
this.value = value;
return;
}
String val = (String) value;
String name = StringUtils.removeStartIgnoreCase(val, CLASS);
Class<?> clazz = ClassUtils.getClass(name);
if (name.length() == val.length()) {
this.value = clazz.newInstance();
} else {
this.value = clazz;
}
} catch (Exception e) {
throw new ConfigurationRuntimeException(""Unable to create "" + value, e);
}
}",0,False
"@Override
public org.apache.xml.resolver.Catalog getPrivateCatalog() {
org.apache.xml.resolver.Catalog catalog = staticCatalog;
if (catalog == null || !getUseStaticCatalog()) {
try {
catalog = new Catalog();
catalog.setCatalogManager(this);
catalog.setupReaders();
catalog.loadSystemCatalogs();
} catch (Exception ex) {
ex.printStackTrace();
}
if (getUseStaticCatalog()) {
staticCatalog = catalog;
}
}
return catalog;
}",0,False
"public List<ConfigurationNode> getSubNodes(String name) {
if (name == null) {
return getSubNodes();
}
List<ConfigurationNode> result;
if (nodes == null) {
result = null;
} else {
result = namedNodes.get(name);
}
if (result == null) {
return Collections.emptyList();
} else {
return Collections.unmodifiableList(result);
}
}",0,False
"@Override
public void visitBeforeChildren(ImmutableNode node, NodeHandler<ImmutableNode> handler) {
ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"public static Synchronizer cloneSynchronizer(Synchronizer sync) {
if (sync == null) {
throw new IllegalArgumentException(""Synchronizer must not be null!"");
}
if (NoOpSynchronizer.INSTANCE == sync) {
return sync;
}
try {
return sync.getClass().newInstance();
} catch (Exception ex) {
LOG.info(""Cannot create new instance of "" + sync.getClass());
}
try {
return (Synchronizer) clone(sync);
} catch (CloneNotSupportedException cnex) {
throw new ConfigurationRuntimeException(""Cannot clone Synchronizer "" + sync);
}
}",0,False
"static Object toInternetAddress(Object value) throws ConversionException {
if (value.getClass().getName().equals(INTERNET_ADDRESS_CLASSNAME)) {
return value;
} else if (value instanceof String) {
try {
Constructor<?> ctor = Class.forName(INTERNET_ADDRESS_CLASSNAME).getConstructor(String.class);
return ctor.newInstance(value);
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"", e);
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"");
}
}",0,False
"public static Double toDouble(Object value) throws ConversionException {
Number n = toNumber(value, Double.class);
if (n instanceof Double) {
return (Double) n;
} else {
return new Double(n.doubleValue());
}
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
EntityResolver resolver = new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler();
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
getNodeModel().mergeRoot(handler.getResultBuilder().createNode(), null, null, null, this);
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
EntityResolver resolver = new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler();
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
getNodeModel().mergeRoot(handler.getResultBuilder().createNode(), null, null, null, this);
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"@Override
protected String normalizeURI(String uriref) {
ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
String resolved = (ci != null) ? String.valueOf(ci.interpolate(uriref)) : uriref;
return super.normalizeURI(resolved);
}",0,False
private final NodeHandler<T> handler;,0,False
"protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertiesConfiguration();
} else {
return new PropertiesConfiguration();
}
}",0,False
"public static URL locate(FileSystem fileSystem, String base, String name) {
if (log.isDebugEnabled()) {
StringBuffer buf = new StringBuffer();
buf.append(""ConfigurationUtils.locate(): base is "").append(base);
buf.append("", name is "").append(name);
log.debug(buf.toString());
}
if (name == null) {
return null;
}
URL url = fileSystem.locateFromURL(base, name);
if (url == null) {
File file = new File(name);
if (file.isAbsolute() && file.exists()) {
try {
url = toURL(file);
log.debug(""Loading configuration from the absolute path "" + name);
} catch (MalformedURLException e) {
log.warn(""Could not obtain URL from file"", e);
}
}
}
if (url == null) {
try {
File file = constructFile(base, name);
if (file != null && file.exists()) {
url = toURL(file);
}
if (url != null) {
log.debug(""Loading configuration from the path "" + file);
}
} catch (MalformedURLException e) {
log.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
try {
File file = constructFile(System.getProperty(""user.home""), name);
if (file != null && file.exists()) {
url = toURL(file);
}
if (url != null) {
log.debug(""Loading configuration from the home path "" + file);
}
} catch (MalformedURLException e) {
log.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
url = locateFromClasspath(name);
}
return url;
}",0,False
"public static void dump(Configuration configuration, PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"public Object getProperty(String key) {
Object result = null;
StringBuffer query = new StringBuffer(""SELECT * FROM "");
query.append(table).append("" WHERE "");
query.append(keyColumn).append(""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
List results = new ArrayList();
while (rs.next()) {
Object value = rs.getObject(valueColumn);
if (isDelimiterParsingDisabled()) {
results.add(value);
} else {
CollectionUtils.addAll(results, PropertyConverter.toIterator(value, getListDelimiter()));
}
}
if (!results.isEmpty()) {
result = (results.size() > 1) ? results : results.get(0);
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
return result;
}",0,False
private ConfigurationNode rootNode;,0,False
private final Object reloadLock;,0,False
"public void setRootNode(ConfigurationNode rootNode) {
if (init) {
this.getConfiguration().setRootNode(rootNode);
} else {
super.setRootNode(rootNode);
}
}",0,False
"private ReloadingStrategy createReloadingStrategy() {
if (fileStrategy == null) {
return null;
}
try {
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
} catch (Exception ex) {
return null;
}
}",0,False
"private static String[] doParseProperty(String line) {
String[] result = new String[3];
StringBuffer key = new StringBuffer();
StringBuffer value = new StringBuffer();
StringBuffer separator = new StringBuffer();
// state of the automaton:
int state = 0;
for (int pos = 0; pos < line.length(); pos++) {
char c = line.charAt(pos);
switch(state) {
case 0:
if (c == '\\') {
state = 1;
} else if (ArrayUtils.contains(WHITE_SPACE, c)) {
separator.append(c);
state = 2;
} else if (ArrayUtils.contains(SEPARATORS, c)) {
separator.append(c);
state = 3;
} else {
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c)) {
key.append(c);
} else {
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c) || ArrayUtils.contains(SEPARATORS, c)) {
separator.append(c);
} else {
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
break;
}
}
result[0] = key.toString().trim();
result[1] = value.toString().trim();
result[2] = separator.toString();
return result;
}",0,False
"static boolean isEnum(Class cls) {
if (!SystemUtils.isJavaVersionAtLeast(JAVA_VERSION_1_5)) {
return false;
}
try {
Method isEnumMethod = Class.class.getMethod(""isEnum"", new Class[] {});
return ((Boolean) isEnumMethod.invoke(cls, new Object[] {})).booleanValue();
} catch (Exception e) {
throw new RuntimeException(e.getMessage());
}
}",0,False
private DocumentBuilder documentBuilder;,0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"private XMLNode convertToXMLNode(ConfigurationNode node) {
if (node instanceof XMLNode) {
return (XMLNode) node;
}
XMLNode nd = (XMLNode) createNode(node.getName());
nd.setValue(node.getValue());
nd.setAttribute(node.isAttribute());
for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
nd.addChild(convertToXMLNode((ConfigurationNode) it.next()));
}
for (Iterator it = node.getAttributes().iterator(); it.hasNext(); ) {
nd.addAttribute(convertToXMLNode((ConfigurationNode) it.next()));
}
return nd;
}",0,False
"public void save(Writer out) throws ConfigurationException {
PrintWriter writer = new PrintWriter(out);
String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
writer.println(""<?xml version=\""1.0\"" encoding=\"""" + encoding + ""\""?>"");
writer.println(""<!DOCTYPE properties SYSTEM \""http://java.sun.com/dtd/properties.dtd\"">"");
writer.println(""<properties>"");
if (getHeader() != null) {
writer.println(""  <comment>"" + StringEscapeUtils.escapeXml(getHeader()) + ""</comment>"");
}
Iterator keys = getKeys();
while (keys.hasNext()) {
String key = (String) keys.next();
Object value = getProperty(key);
if (value instanceof List) {
writeProperty(writer, key, (List) value);
} else {
writeProperty(writer, key, value);
}
}
writer.println(""</properties>"");
writer.flush();
}",0,False
"public void load(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
// todo: support included properties ?
}",0,False
"public void ReInit(PropertyListParserTokenManager tm) {
token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}",0,False
"final public PropertyListConfiguration Dictionary() throws ParseException {
PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1: while (true) {
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration) {
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
} else {
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++) {
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
{
if (true)
return configuration;
}
throw new Error(""Missing return statement in function"");
}",0,False
"protected byte[] filterData(String s) throws ParseException {
if (s == null) {
return null;
}
if (s.startsWith(""<"") && s.endsWith("">"") && s.length() >= 2) {
s = s.substring(1, s.length() - 1);
}
s = StringUtils.replaceChars(s, "" \t\n\r"", """");
if (s.length() % 2 != 0) {
s = ""0"" + s;
}
try {
return Hex.decodeHex(s.toCharArray());
} catch (Exception e) {
throw (ParseException) new ParseException(""Unable to parse the byte[] : "" + e.getMessage());
}
}",0,False
"public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
}",0,False
"public String GetImage() {
if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
}",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
public Token specialToken;,0,False
"public void addDataValue(String value) {
addValue(Base64.decodeBase64(value.getBytes()));
}",0,False
"public boolean removeNodes(String name) {
if (nodes != null && name != null) {
List lst = (List) namedNodes.remove(name);
if (lst != null) {
detachNodes(lst);
nodes.removeAll(lst);
return true;
}
}
return false;
}",0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue)).floatValue();
}",0,False
"public double getDouble(String key, double defaultValue) {
return getDouble(key, new Double(defaultValue)).doubleValue();
}",0,False
"public long getLong(String key, long defaultValue) {
return getLong(key, new Long(defaultValue)).longValue();
}",0,False
"public Object getProperty(String key) {
if (isForceReloadCheck()) {
for (Iterator it = configurations.iterator(); it.hasNext(); ) {
try {
((ConfigData) it.next()).getConfiguration().getProperty(PROP_RELOAD_CHECK);
} catch (Exception ex) {
;
}
}
}
return super.getProperty(key);
}",0,False
"public static void dump(Configuration configuration, PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"private static String[] parseProperty(String line) {
String[] result = new String[2];
StringBuffer key = new StringBuffer();
StringBuffer value = new StringBuffer();
// state of the automaton:
int state = 0;
for (int pos = 0; pos < line.length(); pos++) {
char c = line.charAt(pos);
switch(state) {
case 0:
if (c == '\\') {
state = 1;
} else if (ArrayUtils.contains(WHITE_SPACE, c)) {
state = 2;
} else if (ArrayUtils.contains(SEPARATORS, c)) {
state = 3;
} else {
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c)) {
key.append(c);
} else {
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c)) {
state = 2;
} else if (ArrayUtils.contains(SEPARATORS, c)) {
state = 3;
} else {
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
break;
}
}
result[0] = key.toString().trim();
result[1] = value.toString().trim();
return result;
}",0,False
"public static Short toShort(Object value) throws ConversionException {
Number n = toNumber(value, Short.class);
if (n instanceof Short) {
return (Short) n;
} else {
return new Short(n.shortValue());
}
}",0,False
"static Object toEnum(Object value, Class cls) throws ConversionException {
if (value.getClass().equals(cls)) {
return value;
} else if (value instanceof String) {
try {
Method valueOfMethod = cls.getMethod(""valueOf"", new Class[] { String.class });
return valueOfMethod.invoke(null, new Object[] { value });
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a "" + cls.getName());
}
} else if (value instanceof Number) {
try {
Method valuesMethod = cls.getMethod(""values"", new Class[] {});
Object valuesArray = valuesMethod.invoke(null, new Object[] {});
return Array.get(valuesArray, ((Number) value).intValue());
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a "" + cls.getName());
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a "" + cls.getName());
}
}",0,False
"public ConfigurationNode getRootNode() {
if (getSubnodeKey() != null) {
try {
List nodes = getParent().fetchNodeList(getSubnodeKey());
if (nodes.size() != 1) {
setSubnodeKey(null);
} else {
ConfigurationNode currentRoot = (ConfigurationNode) nodes.get(0);
if (currentRoot != super.getRootNode()) {
setRootNode(currentRoot);
}
return currentRoot;
}
} catch (Exception ex) {
setSubnodeKey(null);
}
}
return super.getRootNode();
}",0,False
"private XMLNode convertToXMLNode(ConfigurationNode node) {
if (node instanceof XMLNode) {
return (XMLNode) node;
}
XMLNode nd = (XMLNode) createNode(node.getName());
nd.setValue(node.getValue());
for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
nd.addChild(convertToXMLNode((ConfigurationNode) it.next()));
}
for (Iterator it = node.getAttributes().iterator(); it.hasNext(); ) {
nd.addAttribute(convertToXMLNode((ConfigurationNode) it.next()));
}
return nd;
}",0,False
"protected Date parseDate(String s) throws ParseException {
String substring = s.substring(3, s.length() - 1);
try {
return PropertyListConfiguration.DATE_FORMAT.parse(substring);
} catch (Exception e) {
throw (ParseException) new ParseException(""Unable to parse the date '"" + s + ""' : "" + e.getMessage());
}
}",0,False
"public void SwitchTo(int lexState) {
if (lexState >= 1 || lexState < 0) {
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
} else {
curLexState = lexState;
}
}",0,False
"public char BeginToken() throws java.io.IOException {
tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
}",0,False
"public String GetImage() {
if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
}",0,False
"protected int getMaxPosition() {
return reverse ? getStartOffset() + 1 : subNodes.size() - getStartOffset();
}",0,False
private ConfigurationNode node;,0,False
"public short getShort(String key, short defaultValue) {
return getShort(key, new Short(defaultValue)).shortValue();
}",0,False
"public void load(InputStream in, String encoding) throws ConfigurationException {
Reader reader = null;
if (encoding != null) {
try {
reader = new InputStreamReader(in, encoding);
} catch (UnsupportedEncodingException e) {
throw new ConfigurationException(""The requested encoding is not supported, try the default encoding."", e);
}
}
if (reader == null) {
reader = new InputStreamReader(in);
}
load(reader);
}",0,False
"@Override
protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertiesConfiguration();
} else {
return new PropertiesConfiguration();
}
}",0,False
"public static URL locate(FileSystem fileSystem, String base, String name) {
if (LOG.isDebugEnabled()) {
StringBuilder buf = new StringBuilder();
buf.append(""ConfigurationUtils.locate(): base is "").append(base);
buf.append("", name is "").append(name);
LOG.debug(buf.toString());
}
if (name == null) {
return null;
}
URL url = fileSystem.locateFromURL(base, name);
if (url == null) {
File file = new File(name);
if (file.isAbsolute() && file.exists()) {
try {
url = toURL(file);
LOG.debug(""Loading configuration from the absolute path "" + name);
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
}
if (url == null) {
try {
File file = constructFile(base, name);
if (file != null && file.exists()) {
url = toURL(file);
}
if (url != null) {
LOG.debug(""Loading configuration from the path "" + file);
}
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
try {
File file = constructFile(System.getProperty(""user.home""), name);
if (file != null && file.exists()) {
url = toURL(file);
}
if (url != null) {
LOG.debug(""Loading configuration from the home path "" + file);
}
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
url = locateFromClasspath(name);
}
return url;
}",0,False
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0,False
"private void createPath(File file) {
if (file != null) {
if (!file.exists()) {
File parent = file.getParentFile();
if (parent != null && !parent.exists()) {
parent.mkdirs();
}
}
}
}",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"private ReloadingStrategy createReloadingStrategy() {
if (fileStrategy == null) {
return null;
}
try {
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
} catch (Exception ex) {
return null;
}
}",0,False
"public static Long toLong(Object value) throws ConversionException {
Number n = toNumber(value, Long.class);
if (n instanceof Long) {
return (Long) n;
} else {
return new Long(n.longValue());
}
}",0,False
"public static Float toFloat(Object value) throws ConversionException {
Number n = toNumber(value, Float.class);
if (n instanceof Float) {
return (Float) n;
} else {
return new Float(n.floatValue());
}
}",0,False
"public static Integer toInteger(Object value) throws ConversionException {
Number n = toNumber(value, Integer.class);
if (n instanceof Integer) {
return (Integer) n;
} else {
return new Integer(n.intValue());
}
}",0,False
"@Override
public ConfigurationNode getRootNode() {
if (getSubnodeKey() != null) {
try {
List<ConfigurationNode> nodes = getParent().fetchNodeList(getSubnodeKey());
if (nodes.size() != 1) {
setSubnodeKey(null);
} else {
ConfigurationNode currentRoot = nodes.get(0);
if (currentRoot != super.getRootNode()) {
fireEvent(EVENT_SUBNODE_CHANGED, null, null, true);
setRootNode(currentRoot);
fireEvent(EVENT_SUBNODE_CHANGED, null, null, false);
}
return currentRoot;
}
} catch (Exception ex) {
setSubnodeKey(null);
}
}
return super.getRootNode();
}",0,False
"private FileSystemOptions getOptions(String scheme) {
FileSystemOptions opts = new FileSystemOptions();
FileSystemConfigBuilder builder;
try {
builder = VFS.getManager().getFileSystemConfigBuilder(scheme);
} catch (Exception ex) {
return null;
}
FileOptionsProvider provider = getFileOptionsProvider();
if (provider != null) {
Map<String, Object> map = provider.getOptions();
if (map == null) {
return null;
}
int count = 0;
for (Map.Entry<String, Object> entry : map.entrySet()) {
try {
String key = entry.getKey();
if (FileOptionsProvider.CURRENT_USER.equals(key)) {
key = ""creatorName"";
}
setProperty(builder, opts, key, entry.getValue());
++count;
} catch (Exception ex) {
continue;
}
}
if (count > 0) {
return opts;
}
}
return null;
}",0,False
private final String protocol;,0,False
"public void load(Reader in) throws ConfigurationException {
if (!(getRootNode() instanceof PListNode)) {
initRoot();
}
EntityResolver resolver = new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler(getRootNode());
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"private void printValue(PrintWriter out, int indentLevel, Object value) {
String padding = StringUtils.repeat("" "", indentLevel * INDENT_SIZE);
if (value instanceof Date) {
synchronized (PListNode.FORMAT) {
out.println(padding + ""<date>"" + PListNode.FORMAT.format((Date) value) + ""</date>"");
}
} else if (value instanceof Calendar) {
printValue(out, indentLevel, ((Calendar) value).getTime());
} else if (value instanceof Number) {
if (value instanceof Double || value instanceof Float || value instanceof BigDecimal) {
out.println(padding + ""<real>"" + value.toString() + ""</real>"");
} else {
out.println(padding + ""<integer>"" + value.toString() + ""</integer>"");
}
} else if (value instanceof Boolean) {
if (((Boolean) value).booleanValue()) {
out.println(padding + ""<true/>"");
} else {
out.println(padding + ""<false/>"");
}
} else if (value instanceof List) {
out.println(padding + ""<array>"");
Iterator<?> it = ((List<?>) value).iterator();
while (it.hasNext()) {
printValue(out, indentLevel + 1, it.next());
}
out.println(padding + ""</array>"");
} else if (value instanceof HierarchicalConfiguration) {
printNode(out, indentLevel, ((HierarchicalConfiguration) value).getRootNode());
} else if (value instanceof Configuration) {
out.println(padding + ""<dict>"");
Configuration config = (Configuration) value;
Iterator<String> it = config.getKeys();
while (it.hasNext()) {
String key = it.next();
ConfigurationNode node = new DefaultConfigurationNode(key);
node.setValue(config.getProperty(key));
printNode(out, indentLevel + 1, node);
if (it.hasNext()) {
out.println();
}
}
out.println(padding + ""</dict>"");
} else if (value instanceof Map) {
Map<String, Object> map = transformMap((Map<?, ?>) value);
printValue(out, indentLevel, new MapConfiguration(map));
} else if (value instanceof byte[]) {
String base64 = new String(Base64.encodeBase64((byte[]) value));
out.println(padding + ""<data>"" + StringEscapeUtils.escapeXml(base64) + ""</data>"");
} else if (value != null) {
out.println(padding + ""<string>"" + StringEscapeUtils.escapeXml(String.valueOf(value)) + ""</string>"");
} else {
out.println(padding + ""<string/>"");
}
}",0,False
"public void load(Reader in) throws ConfigurationException {
if (!(getRootNode() instanceof PListNode)) {
initRoot();
}
EntityResolver resolver = new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler(getRootNode());
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"public void init() {
if (configuration.getURL() == null && configuration.getFileName() == null) {
return;
}
if (this.configuration == null) {
throw new IllegalStateException(""No configuration has been set for this strategy"");
}
updateLastModified();
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = ConfigurationUtils.locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"@Override
public org.apache.xml.resolver.Catalog getPrivateCatalog() {
org.apache.xml.resolver.Catalog catalog = staticCatalog;
if (catalog == null || !getUseStaticCatalog()) {
try {
catalog = new Catalog();
catalog.setCatalogManager(this);
catalog.setupReaders();
catalog.loadSystemCatalogs();
} catch (Exception ex) {
ex.printStackTrace();
}
if (getUseStaticCatalog()) {
staticCatalog = catalog;
}
}
return catalog;
}",0,False
"@Override
protected String normalizeURI(String uriref) {
StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
String resolved = substitutor != null ? substitutor.replace(uriref) : uriref;
return super.normalizeURI(resolved);
}",0,False
"protected int getMaxPosition() {
return reverse ? getStartOffset() + 1 : subNodes.size() - getStartOffset();
}",0,False
"public NodePointer getNodePointer() {
if (getPosition() < 1 && !setPosition(1)) {
return null;
}
return createNodePointer(subNodes.get(positionToIndex(getPosition())));
}",0,False
private ConfigurationNode rootNode;,0,False
private ConfigurationNode combinedRoot;,0,False
"public void read(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"@Override
public PropertyDescriptor[] getPropertyDescriptors() {
return propertyDescriptors;
}",0,False
"public static Byte toByte(Object value) throws ConversionException {
Number n = toNumber(value, Byte.class);
if (n instanceof Byte) {
return (Byte) n;
} else {
return new Byte(n.byteValue());
}
}",0,False
"public static Short toShort(Object value) throws ConversionException {
Number n = toNumber(value, Short.class);
if (n instanceof Short) {
return (Short) n;
} else {
return new Short(n.shortValue());
}
}",0,False
private final String protocol;,0,False
"private FileSystemOptions getOptions(String scheme) {
FileSystemOptions opts = new FileSystemOptions();
FileSystemConfigBuilder builder;
try {
builder = VFS.getManager().getFileSystemConfigBuilder(scheme);
} catch (Exception ex) {
return null;
}
FileOptionsProvider provider = getFileOptionsProvider();
if (provider != null) {
Map<String, Object> map = provider.getOptions();
if (map == null) {
return null;
}
int count = 0;
for (Map.Entry<String, Object> entry : map.entrySet()) {
try {
String key = entry.getKey();
if (FileOptionsProvider.CURRENT_USER.equals(key)) {
key = ""creatorName"";
}
setProperty(builder, opts, key, entry.getValue());
++count;
} catch (Exception ex) {
continue;
}
}
if (count > 0) {
return opts;
}
}
return null;
}",0,False
"public void read(Reader in) throws ConfigurationException {
if (!(getRootNode() instanceof PListNode)) {
initRoot();
}
EntityResolver resolver = new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler(getRootNode());
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"@Override
public void visitBeforeChildren(ImmutableNode node, NodeHandler<ImmutableNode> handler) {
ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
} else {
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"public static void dump(Configuration configuration, PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
// todo: support included properties ?
}",0,False
private AutoSaveListener autoSaveListener;,0,False
"public void setValue(Object value) throws ConfigurationRuntimeException {
try {
if (!(value instanceof String)) {
this.value = value;
return;
}
String val = (String) value;
String name = StringUtils.removeStartIgnoreCase(val, CLASS);
Class<?> clazz = ClassUtils.getClass(name);
if (name.length() == val.length()) {
this.value = clazz.newInstance();
} else {
this.value = clazz;
}
} catch (Exception e) {
throw new ConfigurationRuntimeException(""Unable to create "" + value, e);
}
}",0,False
"@Override
public org.apache.xml.resolver.Catalog getPrivateCatalog() {
org.apache.xml.resolver.Catalog catalog = staticCatalog;
if (catalog == null || !getUseStaticCatalog()) {
try {
catalog = new Catalog();
catalog.setCatalogManager(this);
catalog.setupReaders();
catalog.loadSystemCatalogs();
} catch (Exception ex) {
ex.printStackTrace();
}
if (getUseStaticCatalog()) {
staticCatalog = catalog;
}
}
return catalog;
}",0,False
"public void load(InputStream in, String encoding) throws ConfigurationException {
Reader reader = null;
if (encoding != null) {
try {
reader = new InputStreamReader(in, encoding);
} catch (UnsupportedEncodingException e) {
throw new ConfigurationException(""The requested encoding is not supported, try the default encoding."", e);
}
}
if (reader == null) {
reader = new InputStreamReader(in);
}
load(reader);
}",0,False
private NodeCombiner nodeCombiner;,0,False
"protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertiesConfiguration();
} else {
return new PropertiesConfiguration();
}
}",0,False
"public boolean containsKey(String key) {
boolean found = false;
StringBuffer query = new StringBuffer(""SELECT * FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
found = rs.next();
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
return found;
}",0,False
"public boolean isEmpty() {
boolean empty = true;
StringBuffer query = new StringBuffer(""SELECT count(*) FROM "" + table);
if (nameColumn != null) {
query.append("" WHERE "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
if (nameColumn != null) {
pstmt.setString(1, name);
}
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
empty = rs.getInt(1) == 0;
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, null, null, e);
} finally {
close(conn, pstmt);
}
return empty;
}",0,False
private NodeCombiner nodeCombiner;,0,False
private final Object reloadLock;,0,False
"public Lock(String name) {
this.name = name;
synchronized (counterLock) {
instanceId = ++counter;
}
}",0,False
"private ReloadingStrategy createReloadingStrategy() {
if (fileStrategy == null) {
return null;
}
try {
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
} catch (Exception ex) {
return null;
}
}",0,False
"private ReloadingStrategy createReloadingStrategy() {
if (fileStrategy == null) {
return null;
}
try {
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
} catch (Exception ex) {
return null;
}
}",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"private static String[] doParseProperty(String line) {
String[] result = new String[3];
StringBuffer key = new StringBuffer();
StringBuffer value = new StringBuffer();
StringBuffer separator = new StringBuffer();
// state of the automaton:
int state = 0;
for (int pos = 0; pos < line.length(); pos++) {
char c = line.charAt(pos);
switch(state) {
case 0:
if (c == '\\') {
state = 1;
} else if (ArrayUtils.contains(WHITE_SPACE, c)) {
separator.append(c);
state = 2;
} else if (ArrayUtils.contains(SEPARATORS, c)) {
separator.append(c);
state = 3;
} else {
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c)) {
key.append(c);
} else {
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c) || ArrayUtils.contains(SEPARATORS, c)) {
separator.append(c);
} else {
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
break;
}
}
result[0] = key.toString().trim();
result[1] = value.toString().trim();
result[2] = separator.toString();
return result;
}",0,False
"public void startElement(String uri, String localName, String qName, Attributes attrs) {
if (""comment"".equals(qName)) {
inCommentElement = true;
}
if (""entry"".equals(qName)) {
key = attrs.getValue(""key"");
inEntryElement = true;
}
}",0,False
"public void load(Reader in) throws ConfigurationException {
if (!(getRootNode() instanceof PListNode)) {
initRoot();
}
EntityResolver resolver = new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler(getRoot());
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"public void addDataValue(String value) {
addValue(Base64.decodeBase64(value.getBytes()));
}",0,False
"public short getShort(String key, short defaultValue) {
return getShort(key, new Short(defaultValue)).shortValue();
}",0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue)).floatValue();
}",0,False
"private ConfigurationNode constructCombinedNode() {
if (getNumberOfConfigurations() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
} else {
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = getNodeCombiner().combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"@Override
protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertiesConfiguration();
} else {
return new PropertiesConfiguration();
}
}",0,False
"public Iterator<String> getKeys() {
Collection<String> keys = new ArrayList<String>();
StringBuilder query = new StringBuilder(""SELECT DISTINCT "" + keyColumn + "" FROM "" + table);
if (nameColumn != null) {
query.append("" WHERE "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
if (nameColumn != null) {
pstmt.setString(1, name);
}
ResultSet rs = pstmt.executeQuery();
while (rs.next()) {
keys.add(rs.getString(1));
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, null, null, e);
} finally {
close(conn, pstmt);
}
return keys.iterator();
}",0,False
private ConfigurationNode rootNode;,0,False
private final Object reloadLock;,0,False
"private ReloadingStrategy createReloadingStrategy() {
if (fileStrategy == null) {
return null;
}
try {
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
} catch (Exception ex) {
return null;
}
}",0,False
"public static Float toFloat(Object value) throws ConversionException {
Number n = toNumber(value, Float.class);
if (n instanceof Float) {
return (Float) n;
} else {
return new Float(n.floatValue());
}
}",0,False
"public static Integer toInteger(Object value) throws ConversionException {
Number n = toNumber(value, Integer.class);
if (n instanceof Integer) {
return (Integer) n;
} else {
return new Integer(n.intValue());
}
}",0,False
"public static Double toDouble(Object value) throws ConversionException {
Number n = toNumber(value, Double.class);
if (n instanceof Double) {
return (Double) n;
} else {
return new Double(n.doubleValue());
}
}",0,False
"private void setProperty(FileSystemConfigBuilder builder, FileSystemOptions options, String key, Object value) {
String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
Method method = builder.getClass().getMethod(methodName, paramTypes);
Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (Exception ex) {
return;
}
}",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"private XMLNode convertToXMLNode(ConfigurationNode node) {
if (node instanceof XMLNode) {
return (XMLNode) node;
}
XMLNode nd = (XMLNode) createNode(node.getName());
nd.setValue(node.getValue());
nd.setAttribute(node.isAttribute());
for (ConfigurationNode child : node.getChildren()) {
nd.addChild(convertToXMLNode(child));
}
for (ConfigurationNode attr : node.getAttributes()) {
nd.addAttribute(convertToXMLNode(attr));
}
return nd;
}",0,False
"protected BeanDeclaration createBeanDeclaration(ConfigurationNode node) {
List<HierarchicalConfiguration> list = getConfiguration().configurationsAt(node.getName());
if (list.size() == 1) {
return new XMLBeanDeclaration((SubnodeConfiguration) list.get(0), node);
} else {
Iterator<HierarchicalConfiguration> iter = list.iterator();
while (iter.hasNext()) {
SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
if (config.getRootNode().equals(node)) {
return new XMLBeanDeclaration(config, node);
}
}
throw new ConfigurationRuntimeException(""Unable to match node for "" + node.getName());
}
}",0,False
"private String getName(File file) {
String name = configuration.getURL().toString();
if (name == null) {
if (file != null) {
name = file.getAbsolutePath();
} else {
name = ""base: "" + configuration.getBasePath() + ""file: "" + configuration.getFileName();
}
}
return name;
}",0,False
"public static void dump(final ImmutableConfiguration configuration, final PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"protected PreparedStatement createStatement(final String sql, final boolean nameCol) throws SQLException {
String statement;
if (nameCol && configurationNameColumn != null) {
final StringBuilder buf = new StringBuilder(sql);
buf.append("" AND "").append(configurationNameColumn).append(""=?"");
statement = buf.toString();
} else {
statement = sql;
}
pstmt = getConnection().prepareStatement(statement);
return pstmt;
}",0,False
private final ImmutableConfiguration configuration;,0,False
"private void setProperty(final FileSystemConfigBuilder builder, final FileSystemOptions options, final String key, final Object value) {
final String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
final Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
final Method method = builder.getClass().getMethod(methodName, paramTypes);
final Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (final Exception ex) {
log.warn(""Cannot access property '"" + key + ""'! Ignoring."", ex);
}
}",0,False
"@Override
@SuppressWarnings(""unchecked"")
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
if (bean instanceof NodeWrapper) {
final NodeWrapper<?> wrapper = (NodeWrapper<?>) bean;
return new ConfigurationNodePointer((ConfigurationNodePointer) parent, wrapper.getNode(), wrapper.getNodeHandler());
}
return null;
}",0,False
"public long getLong(String key, long defaultValue) {
return getLong(key, new Long(defaultValue)).longValue();
}",0,False
"public void reload() {
synchronized (reloadLock) {
if (noReload == 0) {
try {
enterNoReload();
if (strategy.reloadingRequired()) {
if (getLogger().isLoggable(Level.FINE)) {
getLogger().fine(""Reloading configuration. URL is "" + getURL());
}
fireEvent(EVENT_RELOAD, null, getURL(), true);
setDetailEvents(false);
boolean autoSaveBak = this.isAutoSave();
this.setAutoSave(false);
try {
clear();
load();
} finally {
this.setAutoSave(autoSaveBak);
setDetailEvents(true);
}
fireEvent(EVENT_RELOAD, null, getURL(), false);
strategy.reloadingPerformed();
}
} catch (Exception e) {
fireError(EVENT_RELOAD, null, null, e);
} finally {
exitNoReload();
}
}
}
}",0,False
"public static URL locate(FileSystem fileSystem, String base, String name) {
if (log.isLoggable(Level.FINE)) {
StringBuilder buf = new StringBuilder();
buf.append(""ConfigurationUtils.locate(): base is "").append(base);
buf.append("", name is "").append(name);
log.fine(buf.toString());
}
if (name == null) {
return null;
}
URL url = fileSystem.locateFromURL(base, name);
if (url == null) {
File file = new File(name);
if (file.isAbsolute() && file.exists()) {
try {
url = file.toURI().toURL();
log.fine(""Loading configuration from the absolute path "" + name);
} catch (MalformedURLException e) {
log.log(Level.WARNING, ""Could not obtain URL from file"", e);
}
}
}
if (url == null) {
try {
File file = constructFile(base, name);
if (file != null && file.exists()) {
url = file.toURI().toURL();
}
if (url != null) {
log.fine(""Loading configuration from the path "" + file);
}
} catch (MalformedURLException e) {
log.log(Level.WARNING, ""Could not obtain URL from file"", e);
}
}
if (url == null) {
try {
File file = constructFile(System.getProperty(""user.home""), name);
if (file != null && file.exists()) {
url = file.toURI().toURL();
}
if (url != null) {
log.fine(""Loading configuration from the home path "" + file);
}
} catch (MalformedURLException e) {
log.log(Level.WARNING, ""Could not obtain URL from file"", e);
}
}
if (url == null) {
url = locateFromClasspath(name);
}
return url;
}",0,False
"public static void dump(Configuration configuration, PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
protected Configuration configuration;,0,False
private List<ConfigData> configurations = new ArrayList<ConfigData>();,0,False
private ConfigurationNode rootNode;,0,False
"@Override
public void setRootNode(ConfigurationNode rootNode) {
if (init) {
getConfiguration().setRootNode(rootNode);
} else {
super.setRootNode(rootNode);
}
}",0,False
"public Double convert(Object value, Object... params) throws ConversionException {
Number n = toNumber(value, Double.class);
if (n instanceof Double) {
return (Double) n;
} else {
return new Double(n.doubleValue());
}
}",0,False
"public void addAttributeValue(ConfigurationNode node, String name, Object value) {
ConfigurationNode attr = createNode(node, name);
attr.setValue(value);
node.addAttribute(attr);
}",0,False
"@SuppressWarnings(""unchecked"")
@Override
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) {
T node1 = ((ConfigurationNodePointer<T>) pointer1).getConfigurationNode();
T node2 = ((ConfigurationNodePointer<T>) pointer2).getConfigurationNode();
for (T child : getNodeHandler().getChildren(getConfigurationNode())) {
if (child == node1) {
return -1;
} else if (child == node2) {
return 1;
}
}
return 0;
}",0,False
"protected byte[] filterData(String s) throws ParseException {
if (s == null) {
return null;
}
if (s.startsWith(""<"") && s.endsWith("">"") && s.length() >= 2) {
s = s.substring(1, s.length() - 1);
}
s = StringUtils.replaceChars(s, "" \t\n\r"", """");
if (s.length() % 2 != 0) {
s = ""0"" + s;
}
try {
return Hex.decodeHex(s.toCharArray());
} catch (Exception e) {
throw (ParseException) new ParseException(""Unable to parse the byte[] : "" + e.getMessage());
}
}",0,False
"final public String String() throws ParseException {
Token token = null;
String value = null;
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
{
if (true)
return unescapeQuotes(removeQuotes(token.image));
}
break;
case STRING:
token = jj_consume_token(STRING);
{
if (true)
return token.image;
}
break;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
throw new Error(""Missing return statement in function"");
}",0,False
"private void jj_rescan_token() {
jj_rescan = true;
for (int i = 0; i < 1; i++) {
try {
JJCalls p = jj_2_rtns[i];
do {
if (p.gen > jj_gen) {
jj_la = p.arg;
jj_lastpos = jj_scanpos = p.first;
switch(i) {
case 0:
jj_3_1();
break;
}
}
p = p.next;
} while (p != null);
} catch (LookaheadSuccess ls) {
}
}
jj_rescan = false;
}",0,False
"final public ConfigurationNode Property() throws ParseException {
String key = null;
Object value = null;
ConfigurationNode node = new DefaultConfigurationNode();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{
if (true)
return node;
}
throw new Error(""Missing return statement in function"");
}",0,False
"protected void FillBuff() throws java.io.IOException {
if (maxNextCharInd == available) {
if (available == bufsize) {
if (tokenBegin > 2048) {
bufpos = maxNextCharInd = 0;
available = tokenBegin;
} else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
} else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
inputStream.close();
throw new java.io.IOException();
} else
maxNextCharInd += i;
return;
} catch (java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
}
}",0,False
"public String GetImage() {
if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
}",0,False
"public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
}",0,False
"public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
}",0,False
public Token specialToken;,0,False
"public boolean removeNode(ConfigurationNode node) {
if (nodes != null && node != null && nodes.contains(node)) {
detachNode(node);
this.nodes.remove(node);
List<ConfigurationNode> nodes = namedNodes.get(node.getName());
if (nodes != null) {
nodes.remove(node);
if (nodes.isEmpty()) {
namedNodes.remove(node.getName());
}
}
return true;
} else {
return false;
}
}",0,False
"private void createPath(File file) {
if (file != null) {
if (!file.exists()) {
File parent = file.getParentFile();
if (parent != null && !parent.exists()) {
parent.mkdirs();
}
}
}
}",0,False
"public Iterator getKeys() {
Collection keys = new ArrayList();
StringBuffer query = new StringBuffer(""SELECT DISTINCT "" + keyColumn + "" FROM "" + table);
if (nameColumn != null) {
query.append("" WHERE "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
if (nameColumn != null) {
pstmt.setString(1, name);
}
ResultSet rs = pstmt.executeQuery();
while (rs.next()) {
keys.add(rs.getString(1));
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, null, null, e);
} finally {
close(conn, pstmt);
}
return keys.iterator();
}",0,False
"public boolean containsKey(String key) {
boolean found = false;
StringBuffer query = new StringBuffer(""SELECT * FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
found = rs.next();
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
return found;
}",0,False
"public Object getProperty(String key) {
Object result = null;
StringBuffer query = new StringBuffer(""SELECT * FROM "");
query.append(table).append("" WHERE "");
query.append(keyColumn).append(""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
List results = new ArrayList();
while (rs.next()) {
Object value = rs.getObject(valueColumn);
if (isDelimiterParsingDisabled()) {
results.add(value);
} else {
CollectionUtils.addAll(results, PropertyConverter.toIterator(value, getListDelimiter()));
}
}
if (!results.isEmpty()) {
result = (results.size() > 1) ? results : results.get(0);
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
return result;
}",0,False
"private void registerBeanFactory() {
synchronized (getClass()) {
if (!BeanHelper.registeredFactoryNames().contains(CONFIG_BEAN_FACTORY_NAME)) {
BeanHelper.registerBeanFactory(CONFIG_BEAN_FACTORY_NAME, new ConfigurationBeanFactory());
}
}
}",0,False
private ConfigurationNode rootNode;,0,False
"static boolean isEnum(Class cls) {
if (!SystemUtils.isJavaVersionAtLeast(JAVA_VERSION_1_5)) {
return false;
}
try {
Method isEnumMethod = Class.class.getMethod(""isEnum"", new Class[] {});
return ((Boolean) isEnumMethod.invoke(cls, new Object[] {})).booleanValue();
} catch (Exception e) {
throw new RuntimeException(e.getMessage());
}
}",0,False
"static Object toInternetAddress(Object value) throws ConversionException {
if (value.getClass().getName().equals(INTERNET_ADDRESS_CLASSNAME)) {
return value;
} else if (value instanceof String) {
try {
Constructor ctor = Class.forName(INTERNET_ADDRESS_CLASSNAME).getConstructor(new Class[] { String.class });
return ctor.newInstance(new Object[] { value });
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"", e);
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"");
}
}",0,False
"public void ReInit(java.io.Reader stream) {
jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}",0,False
"protected byte[] filterData(String s) throws ParseException {
if (s == null) {
return null;
}
if (s.startsWith(""<"") && s.endsWith("">"") && s.length() >= 2) {
s = s.substring(1, s.length() - 1);
}
s = StringUtils.replaceChars(s, "" \t\n\r"", """");
if (s.length() % 2 != 0) {
s = ""0"" + s;
}
try {
return Hex.decodeHex(s.toCharArray());
} catch (Exception e) {
throw (ParseException) new ParseException(""Unable to parse the byte[] : "" + e.getMessage());
}
}",0,False
"public void ReInit(PropertyListParserTokenManager tm) {
token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}",0,False
"public void ReInit(java.io.InputStream stream) {
jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}",0,False
"final public PropertyListConfiguration Dictionary() throws ParseException {
PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1: while (true) {
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration) {
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
} else {
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++) {
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
{
if (true)
return configuration;
}
throw new Error(""Missing return statement in function"");
}",0,False
private boolean jj_semLA;,0,False
"public void ReInit(SimpleCharStream stream) {
jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}",0,False
"protected void UpdateLineColumn(char c) {
column++;
if (prevCharIsLF) {
prevCharIsLF = false;
line += (column = 1);
} else if (prevCharIsCR) {
prevCharIsCR = false;
if (c == '\n') {
prevCharIsLF = true;
} else
line += (column = 1);
}
switch(c) {
case '\r':
prevCharIsCR = true;
break;
case '\n':
prevCharIsLF = true;
break;
case '\t':
column--;
column += (8 - (column & 07));
break;
default:
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}",0,False
"public void ReInit(java.io.InputStream dstream) {
ReInit(dstream, 1, 1, 4096);
}",0,False
"public boolean removeNode(ConfigurationNode node) {
if (nodes != null && node != null && nodes.contains(node)) {
detachNode(node);
nodes.remove(node);
List lst = (List) namedNodes.get(node.getName());
if (lst != null) {
lst.remove(node);
if (lst.isEmpty()) {
namedNodes.remove(node.getName());
}
}
return true;
} else {
return false;
}
}",0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
} else {
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
} else {
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"public static void dump(ImmutableConfiguration configuration, PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"public DataSource getDataSource() {
return dataSource;
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
// todo: support included properties ?
}",0,False
"public static Double toDouble(Object value) throws ConversionException {
Number n = toNumber(value, Double.class);
if (n instanceof Double) {
return (Double) n;
} else {
return new Double(n.doubleValue());
}
}",0,False
"private void setProperty(FileSystemConfigBuilder builder, FileSystemOptions options, String key, Object value) {
String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
Method method = builder.getClass().getMethod(methodName, paramTypes);
Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (Exception ex) {
log.warn(""Cannot access property '"" + key + ""'! Ignoring."", ex);
}
}",0,False
private final String protocol;,0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
private final Configuration configuration;,0,False
private AutoSaveListener autoSaveListener;,0,False
"public static Integer toInteger(Object value) throws ConversionException {
Number n = toNumber(value, Integer.class);
if (n instanceof Integer) {
return (Integer) n;
} else {
return new Integer(n.intValue());
}
}",0,False
"public void addDataValue(String value) {
addValue(Base64.decodeBase64(value.getBytes()));
}",0,False
"@Override
protected String normalizeURI(String uriref) {
ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
String resolved = (ci != null) ? String.valueOf(ci.interpolate(uriref)) : uriref;
return super.normalizeURI(resolved);
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"public short getShort(String key, short defaultValue) {
return getShort(key, new Short(defaultValue)).shortValue();
}",0,False
"public byte getByte(String key, byte defaultValue) {
return getByte(key, new Byte(defaultValue)).byteValue();
}",0,False
"public void save(OutputStream out, String encoding) throws ConfigurationException {
Writer writer = null;
if (encoding != null) {
try {
writer = new OutputStreamWriter(out, encoding);
} catch (UnsupportedEncodingException e) {
throw new ConfigurationException(""The requested encoding is not supported, try the default encoding."", e);
}
}
if (writer == null) {
writer = new OutputStreamWriter(out);
}
save(writer);
}",0,False
"@Override
protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertiesConfiguration();
} else {
return new PropertiesConfiguration();
}
}",0,False
"public boolean isEmpty() {
boolean empty = true;
StringBuilder query = new StringBuilder(""SELECT count(*) FROM "" + table);
if (nameColumn != null) {
query.append("" WHERE "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
if (nameColumn != null) {
pstmt.setString(1, name);
}
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
empty = rs.getInt(1) == 0;
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, null, null, e);
} finally {
close(conn, pstmt);
}
return empty;
}",0,False
"@Override
protected Object createBeanInstance(Class<?> beanClass, BeanDeclaration data) throws Exception {
String fileName = ((ConfigurationDeclaration) data).getConfiguration().getString(ATTR_FILENAME);
if (fileName != null && fileName.toLowerCase().trim().endsWith(fileExtension)) {
return super.createBeanInstance(fetchMatchingClass(), data);
} else {
return super.createBeanInstance(fetchDefaultClass(), data);
}
}",0,False
"public String getPath(File file, URL url, String basePath, String fileName) {
String path = null;
if (file != null) {
path = file.getAbsolutePath();
}
if (path == null) {
if (url != null) {
path = url.getPath();
} else {
try {
path = getURL(basePath, fileName).getPath();
} catch (Exception e) {
;
}
}
}
return path;
}",0,False
private ConfigurationNode rootNode;,0,False
private ReloadingStrategy fileStrategy;,0,False
"private ReloadingStrategy createReloadingStrategy() {
if (fileStrategy == null) {
return null;
}
try {
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
} catch (Exception ex) {
return null;
}
}",0,False
"private AbstractHierarchicalFileConfiguration getConfiguration() {
if (pattern == null) {
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path)) {
return configurationsMap.get(path);
}
if (path.equals(pattern)) {
XMLConfiguration configuration = new XMLConfiguration() {
@Override
public void load() throws ConfigurationException {
}
@Override
public void save() throws ConfigurationException {
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null) {
Log log = LogFactory.getLog(loggerName);
if (log != null) {
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null) {
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try {
configuration.load();
} catch (ConfigurationException ce) {
if (isThrowable(ce)) {
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}",0,False
"public static Float toFloat(Object value) throws ConversionException {
Number n = toNumber(value, Float.class);
if (n instanceof Float) {
return (Float) n;
} else {
return new Float(n.floatValue());
}
}",0,False
"static Object toInternetAddress(Object value) throws ConversionException {
if (value.getClass().getName().equals(INTERNET_ADDRESS_CLASSNAME)) {
return value;
} else if (value instanceof String) {
try {
Constructor<?> ctor = Class.forName(INTERNET_ADDRESS_CLASSNAME).getConstructor(new Class[] { String.class });
return ctor.newInstance(new Object[] { value });
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"", e);
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"");
}
}",0,False
"@Override
public void save(Writer out) throws ConfigurationException {
PrintWriter writer = new PrintWriter(out);
String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
writer.println(""<?xml version=\""1.0\"" encoding=\"""" + encoding + ""\""?>"");
writer.println(""<!DOCTYPE properties SYSTEM \""http://java.sun.com/dtd/properties.dtd\"">"");
writer.println(""<properties>"");
if (getHeader() != null) {
writer.println(""  <comment>"" + StringEscapeUtils.escapeXml(getHeader()) + ""</comment>"");
}
Iterator<String> keys = getKeys();
while (keys.hasNext()) {
String key = keys.next();
Object value = getProperty(key);
if (value instanceof List) {
writeProperty(writer, key, (List<?>) value);
} else {
writeProperty(writer, key, value);
}
}
writer.println(""</properties>"");
writer.flush();
}",0,False
"public void setValue(Object value) throws ConfigurationRuntimeException {
try {
if (!(value instanceof String)) {
this.value = value;
return;
}
String val = (String) value;
String name = StringUtils.removeStartIgnoreCase(val, CLASS);
Class<?> clazz = ClassUtils.getClass(name);
if (name.length() == val.length()) {
this.value = clazz.newInstance();
} else {
this.value = clazz;
}
} catch (Exception e) {
throw new ConfigurationRuntimeException(""Unable to create "" + value, e);
}
}",0,False
"private void printValue(PrintWriter out, int indentLevel, Object value) {
String padding = StringUtils.repeat("" "", indentLevel * INDENT_SIZE);
if (value instanceof Date) {
synchronized (PListNode.format) {
out.println(padding + ""<date>"" + PListNode.format.format((Date) value) + ""</date>"");
}
} else if (value instanceof Calendar) {
printValue(out, indentLevel, ((Calendar) value).getTime());
} else if (value instanceof Number) {
if (value instanceof Double || value instanceof Float || value instanceof BigDecimal) {
out.println(padding + ""<real>"" + value.toString() + ""</real>"");
} else {
out.println(padding + ""<integer>"" + value.toString() + ""</integer>"");
}
} else if (value instanceof Boolean) {
if (((Boolean) value).booleanValue()) {
out.println(padding + ""<true/>"");
} else {
out.println(padding + ""<false/>"");
}
} else if (value instanceof List) {
out.println(padding + ""<array>"");
Iterator<?> it = ((List<?>) value).iterator();
while (it.hasNext()) {
printValue(out, indentLevel + 1, it.next());
}
out.println(padding + ""</array>"");
} else if (value instanceof HierarchicalConfiguration) {
printNode(out, indentLevel, ((HierarchicalConfiguration) value).getRoot());
} else if (value instanceof Configuration) {
out.println(padding + ""<dict>"");
Configuration config = (Configuration) value;
Iterator<String> it = config.getKeys();
while (it.hasNext()) {
String key = it.next();
Node node = new Node(key);
node.setValue(config.getProperty(key));
printNode(out, indentLevel + 1, node);
if (it.hasNext()) {
out.println();
}
}
out.println(padding + ""</dict>"");
} else if (value instanceof Map) {
Map<String, Object> map = transformMap((Map<?, ?>) value);
;
printValue(out, indentLevel, new MapConfiguration(map));
} else if (value instanceof byte[]) {
String base64 = new String(Base64.encodeBase64((byte[]) value));
out.println(padding + ""<data>"" + StringEscapeUtils.escapeXml(base64) + ""</data>"");
} else if (value != null) {
out.println(padding + ""<string>"" + StringEscapeUtils.escapeXml(String.valueOf(value)) + ""</string>"");
} else {
out.println(padding + ""<string/>"");
}
}",0,False
"public void addDataValue(String value) {
addValue(Base64.decodeBase64(value.getBytes()));
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = (String) catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = ConfigurationUtils.locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"public boolean removeNode(ConfigurationNode node) {
if (nodes != null && node != null && nodes.contains(node)) {
detachNode(node);
nodes.remove(node);
List<ConfigurationNode> lst = namedNodes.get(node.getName());
if (lst != null) {
lst.remove(node);
if (lst.isEmpty()) {
namedNodes.remove(node.getName());
}
}
return true;
} else {
return false;
}
}",0,False
private ConfigurationNode node;,0,False
"@Override
public void visitBeforeChildren(ImmutableNode node, NodeHandler<ImmutableNode> handler) {
ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
} else {
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
EntityResolver resolver = new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler();
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
getNodeModel().mergeRoot(handler.getResultBuilder().createNode(), null, null, null, this);
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"@Override
protected String normalizeURI(String uriref) {
ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
String resolved = (ci != null) ? String.valueOf(ci.interpolate(uriref)) : uriref;
return super.normalizeURI(resolved);
}",0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue)).floatValue();
}",0,False
"protected Object resolveContainerStore(String key) {
Object value = getProperty(key);
if (value != null) {
if (value instanceof List) {
List list = (List) value;
value = list.isEmpty() ? null : list.get(0);
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
value = array.length == 0 ? null : array[0];
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
value = array.length == 0 ? null : array[0] ? Boolean.TRUE : Boolean.FALSE;
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
value = array.length == 0 ? null : new Byte(array[0]);
} else if (value instanceof short[]) {
short[] array = (short[]) value;
value = array.length == 0 ? null : new Short(array[0]);
} else if (value instanceof int[]) {
int[] array = (int[]) value;
value = array.length == 0 ? null : new Integer(array[0]);
} else if (value instanceof long[]) {
long[] array = (long[]) value;
value = array.length == 0 ? null : new Long(array[0]);
} else if (value instanceof float[]) {
float[] array = (float[]) value;
value = array.length == 0 ? null : new Float(array[0]);
} else if (value instanceof double[]) {
double[] array = (double[]) value;
value = array.length == 0 ? null : new Double(array[0]);
}
}
return value;
}",0,False
"protected Object resolveContainerStore(String key) {
Object value = getProperty(key);
if (value != null) {
if (value instanceof List) {
List list = (List) value;
value = list.isEmpty() ? null : list.get(0);
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
value = array.length == 0 ? null : array[0];
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
value = array.length == 0 ? null : array[0] ? Boolean.TRUE : Boolean.FALSE;
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
value = array.length == 0 ? null : new Byte(array[0]);
} else if (value instanceof short[]) {
short[] array = (short[]) value;
value = array.length == 0 ? null : new Short(array[0]);
} else if (value instanceof int[]) {
int[] array = (int[]) value;
value = array.length == 0 ? null : new Integer(array[0]);
} else if (value instanceof long[]) {
long[] array = (long[]) value;
value = array.length == 0 ? null : new Long(array[0]);
} else if (value instanceof float[]) {
float[] array = (float[]) value;
value = array.length == 0 ? null : new Float(array[0]);
} else if (value instanceof double[]) {
double[] array = (double[]) value;
value = array.length == 0 ? null : new Double(array[0]);
}
}
return value;
}",0,False
"protected Object resolveContainerStore(String key) {
Object value = getProperty(key);
if (value != null) {
if (value instanceof List) {
List list = (List) value;
value = list.isEmpty() ? null : list.get(0);
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
value = array.length == 0 ? null : array[0];
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
value = array.length == 0 ? null : array[0] ? Boolean.TRUE : Boolean.FALSE;
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
value = array.length == 0 ? null : new Byte(array[0]);
} else if (value instanceof short[]) {
short[] array = (short[]) value;
value = array.length == 0 ? null : new Short(array[0]);
} else if (value instanceof int[]) {
int[] array = (int[]) value;
value = array.length == 0 ? null : new Integer(array[0]);
} else if (value instanceof long[]) {
long[] array = (long[]) value;
value = array.length == 0 ? null : new Long(array[0]);
} else if (value instanceof float[]) {
float[] array = (float[]) value;
value = array.length == 0 ? null : new Float(array[0]);
} else if (value instanceof double[]) {
double[] array = (double[]) value;
value = array.length == 0 ? null : new Double(array[0]);
}
}
return value;
}",0,False
"public void save(OutputStream out, String encoding) throws ConfigurationException {
Writer writer = null;
if (encoding != null) {
try {
writer = new OutputStreamWriter(out, encoding);
} catch (UnsupportedEncodingException e) {
throw new ConfigurationException(""The requested encoding is not supported, try the default encoding."", e);
}
}
if (writer == null) {
writer = new OutputStreamWriter(out);
}
save(writer);
}",0,False
"private Collection parseAt(String at) {
if (at == null) {
return null;
}
Collection result = new ArrayList();
DefaultConfigurationKey.KeyIterator it = new DefaultConfigurationKey(AT_ENGINE, at).iterator();
while (it.hasNext()) {
result.add(it.nextKey());
}
return result;
}",0,False
"protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertyListConfiguration();
} else {
return new PropertyListConfiguration();
}
}",0,False
"public Iterator getKeys() {
Collection keys = new ArrayList();
StringBuffer query = new StringBuffer(""SELECT DISTINCT "" + keyColumn + "" FROM "" + table);
if (nameColumn != null) {
query.append("" WHERE "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
if (nameColumn != null) {
pstmt.setString(1, name);
}
ResultSet rs = pstmt.executeQuery();
while (rs.next()) {
keys.add(rs.getString(1));
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, null, null, e);
} finally {
closeQuietly(conn, pstmt);
}
return keys.iterator();
}",0,False
"public Object getProperty(String key) {
Object result = null;
StringBuffer query = new StringBuffer(""SELECT * FROM "");
query.append(table).append("" WHERE "");
query.append(keyColumn).append(""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
List results = new ArrayList();
while (rs.next()) {
Object val = rs.getObject(valueColumn);
if (isDelimiterParsingDisabled()) {
results.add(val);
} else {
CollectionUtils.addAll(results, PropertyConverter.toIterator(val, getListDelimiter()));
}
}
if (!results.isEmpty()) {
result = (results.size() > 1) ? results : results.get(0);
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
closeQuietly(conn, pstmt);
}
return result;
}",0,False
"public void clearProperty(String key) {
StringBuffer query = new StringBuffer(""DELETE FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
pstmt.executeUpdate();
} catch (SQLException e) {
fireError(EVENT_CLEAR_PROPERTY, key, null, e);
} finally {
closeQuietly(conn, pstmt);
}
}",0,False
"protected Object createBeanInstance(Class beanClass, BeanDeclaration data) throws Exception {
String fileName = ((ConfigurationDeclaration) data).getConfiguration().getString(ATTR_FILENAME);
if (fileName != null && fileName.toLowerCase().trim().endsWith(fileExtension)) {
return super.createBeanInstance(fetchMatchingClass(), data);
} else {
return super.createBeanInstance(fetchDefaultClass(), data);
}
}",0,False
"public void clearTree(String key) {
fireEvent(EVENT_CLEAR_TREE, key, null, true);
List nodes = fetchNodeList(key);
for (Iterator it = nodes.iterator(); it.hasNext(); ) {
removeNode((ConfigurationNode) it.next());
}
fireEvent(EVENT_CLEAR_TREE, key, nodes, false);
}",0,False
"public static Short toShort(Object value) throws ConversionException {
Number n = toNumber(value, Short.class);
if (n instanceof Short) {
return (Short) n;
} else {
return new Short(n.shortValue());
}
}",0,False
"private void load(InputSource source) throws ConfigurationException {
try {
URL sourceURL = getDelegate().getURL();
if (sourceURL != null) {
source.setSystemId(sourceURL.toString());
}
DocumentBuilder builder = createDocumentBuilder();
Document newDocument = builder.parse(source);
Document oldDocument = document;
document = null;
initProperties(newDocument, oldDocument == null);
document = (oldDocument == null) ? newDocument : oldDocument;
} catch (Exception e) {
throw new ConfigurationException(e.getMessage(), e);
}
}",0,False
"public void set(String name, Object value) {
if (log.isTraceEnabled()) {
log.trace(""set("" + name + "","" + value + "")"");
}
if (value == null) {
throw new NullPointerException(""Error trying to set property to null."");
}
if (value instanceof List) {
List list = (List) value;
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
getConfiguration().addProperty(name, iterator.next());
}
} else if (value instanceof int[]) {
int[] array = (int[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Integer(array[i]));
}
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, BooleanUtils.toBooleanObject(array[i]));
}
} else if (value instanceof char[]) {
char[] array = (char[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Character(array[i]));
}
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Byte(array[i]));
}
} else if (value instanceof short[]) {
short[] array = (short[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Short(array[i]));
}
} else if (value instanceof long[]) {
long[] array = (long[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Long(array[i]));
}
} else if (value instanceof float[]) {
float[] array = (float[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Float(array[i]));
}
} else if (value instanceof double[]) {
double[] array = (double[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Double(array[i]));
}
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, array[i]);
}
} else {
getConfiguration().setProperty(name, value);
}
}",0,False
"public String getMessage() {
if (!specialConstructor) {
return super.getMessage();
}
String expected = """";
int maxSize = 0;
for (int i = 0; i < expectedTokenSequences.length; i++) {
if (maxSize < expectedTokenSequences[i].length) {
maxSize = expectedTokenSequences[i].length;
}
for (int j = 0; j < expectedTokenSequences[i].length; j++) {
expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
}
if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
expected += ""..."";
}
expected += eol + ""    "";
}
String retval = ""Encountered \"""";
Token tok = currentToken.next;
for (int i = 0; i < maxSize; i++) {
if (i != 0)
retval += "" "";
if (tok.kind == 0) {
retval += tokenImage[0];
break;
}
retval += add_escapes(tok.image);
tok = tok.next;
}
retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn;
retval += ""."" + eol;
if (expectedTokenSequences.length == 1) {
retval += ""Was expecting:"" + eol + ""    "";
} else {
retval += ""Was expecting one of:"" + eol + ""    "";
}
retval += expected;
return retval;
}",0,False
"final public Object Element() throws ParseException {
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ARRAY_BEGIN:
return Array();
case DICT_BEGIN:
return Dictionary();
case STRING:
case QUOTED_STRING:
return String();
case DATA:
return Data();
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}",0,False
"final public String String() throws ParseException {
Token token = null;
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
return unescapeQuotes(removeQuotes(token.image));
case STRING:
token = jj_consume_token(STRING);
return token.image;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}",0,False
"protected void ExpandBuff(boolean wrapAround) {
char[] newbuffer = new char[bufsize + 2048];
int[] newbufline = new int[bufsize + 2048];
int[] newbufcolumn = new int[bufsize + 2048];
try {
if (wrapAround) {
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
} else {
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
} catch (Throwable t) {
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}",0,False
"protected void FillBuff() throws java.io.IOException {
if (maxNextCharInd == available) {
if (available == bufsize) {
if (tokenBegin > 2048) {
bufpos = maxNextCharInd = 0;
available = tokenBegin;
} else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
} else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
inputStream.close();
throw new java.io.IOException();
} else
maxNextCharInd += i;
return;
} catch (java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
}
}",0,False
public Token specialToken;,0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"public void addRealValue(String value) {
addValue(new Double(value));
}",0,False
"@Override
public void visitBeforeChildren(final ImmutableNode node, final NodeHandler<ImmutableNode> handler) {
final ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
final Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
final ByteArrayOutputStream os = new ByteArrayOutputStream();
final PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}",0,False
"private FileSystemOptions getOptions(final String scheme) {
if (scheme == null) {
return null;
}
final FileSystemOptions opts = new FileSystemOptions();
final FileSystemConfigBuilder builder;
try {
builder = getManager().getFileSystemConfigBuilder(scheme);
} catch (final Exception ex) {
return null;
}
final FileOptionsProvider provider = getFileOptionsProvider();
if (provider != null) {
final Map<String, Object> map = provider.getOptions();
if (map == null) {
return null;
}
int count = 0;
for (final Map.Entry<String, Object> entry : map.entrySet()) {
try {
String key = entry.getKey();
if (FileOptionsProvider.CURRENT_USER.equals(key)) {
key = ""creatorName"";
}
setProperty(builder, opts, key, entry.getValue());
++count;
} catch (final Exception ex) {
continue;
}
}
if (count > 0) {
return opts;
}
}
return null;
}",0,False
"@Override
public org.apache.xml.resolver.Catalog getPrivateCatalog() {
org.apache.xml.resolver.Catalog catalog = staticCatalog;
if (catalog == null || !getUseStaticCatalog()) {
try {
catalog = new Catalog();
catalog.setCatalogManager(this);
catalog.setupReaders();
catalog.loadSystemCatalogs();
} catch (final Exception ex) {
ex.printStackTrace();
}
if (getUseStaticCatalog()) {
staticCatalog = catalog;
}
}
return catalog;
}",0,False
"private static <T> T[] defensiveCopy(final T[] src) {
return src != null ? src.clone() : null;
}",0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue)).floatValue();
}",0,False
"public short getShort(String key, short defaultValue) {
return getShort(key, new Short(defaultValue)).shortValue();
}",0,False
"public static void dump(Configuration configuration, PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"@Override
protected Object performOperation() throws SQLException {
PreparedStatement pstmt = initStatement(String.format(SQL_GET_PROPERTY, table, keyColumn), true, key);
ResultSet rs = pstmt.executeQuery();
return rs.next();
}",0,False
"private AbstractHierarchicalFileConfiguration getConfiguration() {
if (pattern == null) {
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path)) {
return configurationsMap.get(path);
}
if (path.equals(pattern)) {
XMLConfiguration configuration = new XMLConfiguration() {
@Override
public void load() throws ConfigurationException {
}
@Override
public void save() throws ConfigurationException {
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null) {
Log log = LogFactory.getLog(loggerName);
if (log != null) {
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null) {
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try {
configuration.load();
} catch (ConfigurationException ce) {
if (isThrowable(ce)) {
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}",0,False
"private ReloadingStrategy createReloadingStrategy() {
if (getReloadingStrategy() == null) {
return null;
}
try {
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(getReloadingStrategy());
strategy.setConfiguration(null);
return strategy;
} catch (Exception ex) {
return null;
}
}",0,False
"public void load(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"public String getPublicID() {
return publicID;
}",0,False
"private CombinedNode constructCombinedNode() {
initSubHandlers();
if (getNumberOfConfigurations() < 1) {
return new CombinedNode();
} else {
Iterator<ConfigData> it = configurations.iterator();
CombinedNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = getNodeCombiner().combine(node, getNodeHandler(), it.next().getTransformedRoot(), getNodeHandler());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node, getNodeHandler());
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"protected void performReloadCheck() {
for (ConfigData cd : configurations) {
try {
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
} catch (Exception ex) {
;
}
}
}",0,False
"public Byte convert(Object value, Object... params) throws ConversionException {
Number n = toNumber(value, Byte.class);
if (n instanceof Byte) {
return (Byte) n;
} else {
return new Byte(n.byteValue());
}
}",0,False
"public Float convert(Object value, Object... params) throws ConversionException {
Number n = toNumber(value, Float.class);
if (n instanceof Float) {
return (Float) n;
} else {
return new Float(n.floatValue());
}
}",0,False
"private FileSystemOptions getOptions(String scheme) {
FileSystemOptions opts = new FileSystemOptions();
FileSystemConfigBuilder builder;
try {
builder = VFS.getManager().getFileSystemConfigBuilder(scheme);
} catch (Exception ex) {
return null;
}
FileOptionsProvider provider = getFileOptionsProvider();
if (provider != null) {
Map<String, Object> map = provider.getOptions();
if (map == null) {
return null;
}
int count = 0;
for (Map.Entry<String, Object> entry : map.entrySet()) {
try {
String key = entry.getKey();
if (FileOptionsProvider.CURRENT_USER.equals(key)) {
key = ""creatorName"";
}
setProperty(builder, opts, key, entry.getValue());
++count;
} catch (Exception ex) {
continue;
}
}
if (count > 0) {
return opts;
}
}
return null;
}",0,False
"public void ReInit(SimpleCharStream stream) {
jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}",0,False
"public void SwitchTo(int lexState) {
if (lexState >= 1 || lexState < 0)
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
else
curLexState = lexState;
}",0,False
public Token currentToken;,0,False
"public char[] GetSuffix(int len) {
char[] ret = new char[len];
if ((bufpos + 1) >= len)
System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
else {
System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
}
return ret;
}",0,False
"public String GetImage() {
if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
}",0,False
"public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
}",0,False
"protected void UpdateLineColumn(char c) {
column++;
if (prevCharIsLF) {
prevCharIsLF = false;
line += (column = 1);
} else if (prevCharIsCR) {
prevCharIsCR = false;
if (c == '\n') {
prevCharIsLF = true;
} else
line += (column = 1);
}
switch(c) {
case '\r':
prevCharIsCR = true;
break;
case '\n':
prevCharIsLF = true;
break;
case '\t':
column--;
column += (tabSize - (column % tabSize));
break;
default:
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}",0,False
"public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
ReInit(dstream, encoding, 1, 1, 4096);
}",0,False
public int endColumn;,0,False
"final public ConfigurationNode Property() throws ParseException {
String key = null;
Object value = null;
ConfigurationNode node = new DefaultConfigurationNode();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{
if (true)
return node;
}
throw new Error(""Missing return statement in function"");
}",0,False
"private int jjMoveNfa_0(int startState, int curPos) {
int startsAt = 0;
jjnewStateCnt = 14;
int i = 1;
jjstateSet[0] = startState;
int kind = 0x7fffffff;
for (; ; ) {
if (++jjround == 0x7fffffff) {
ReInitRounds();
}
if (curChar < 64) {
long l = 1L << curChar;
do {
switch(jjstateSet[--i]) {
case 15:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x7ff280100000000L & l) != 0L) {
jjCheckNAddTwoStates(4, 5);
} else if (curChar == 62) {
if (kind > 20) {
kind = 20;
}
}
break;
case 6:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x3ff000100002600L & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
} else if (curChar == 42) {
jjstateSet[jjnewStateCnt++] = 3;
} else if (curChar == 62) {
if (kind > 19) {
kind = 19;
}
}
break;
case 14:
if ((0xfffffffbffffffffL & l) != 0L) {
jjCheckNAddStates(0, 2);
} else if (curChar == 34) {
if (kind > 22) {
kind = 22;
}
}
break;
case 3:
case 8:
if ((0xd7ffecfaffffd9ffL & l) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 0:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
} else if (curChar == 34) {
jjCheckNAddStates(0, 2);
}
if (curChar == 60) {
jjstateSet[jjnewStateCnt++] = 6;
}
if (curChar == 60) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 1:
if ((0x3ff000100002600L & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 2:
if (curChar == 62 && kind > 19) {
kind = 19;
}
break;
case 4:
if ((0x7ff280100000000L & l) != 0L) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 5:
if (curChar == 62 && kind > 20) {
kind = 20;
}
break;
case 7:
if (curChar == 60) {
jjstateSet[jjnewStateCnt++] = 6;
}
break;
case 9:
case 11:
if (curChar == 34) {
jjCheckNAddStates(0, 2);
}
break;
case 10:
if ((0xfffffffbffffffffL & l) != 0L) {
jjCheckNAddStates(0, 2);
}
break;
case 13:
if (curChar == 34 && kind > 22) {
kind = 22;
}
break;
default:
break;
}
} while (i != startsAt);
} else if (curChar < 128) {
long l = 1L << (curChar & 077);
do {
switch(jjstateSet[--i]) {
case 15:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if (curChar == 90) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 6:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x7e0000007eL & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 14:
jjCheckNAddStates(0, 2);
if (curChar == 92) {
jjstateSet[jjnewStateCnt++] = 11;
}
break;
case 3:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if (curChar == 68) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 0:
case 8:
if ((0xd7ffffffffffffffL & l) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 1:
if ((0x7e0000007eL & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 4:
if (curChar == 90) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 10:
jjCheckNAddStates(0, 2);
break;
case 12:
if (curChar == 92) {
jjstateSet[jjnewStateCnt++] = 11;
}
break;
default:
break;
}
} while (i != startsAt);
} else {
int i2 = (curChar & 0xff) >> 6;
long l2 = 1L << (curChar & 077);
do {
switch(jjstateSet[--i]) {
case 15:
case 8:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 6:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 14:
case 10:
if ((jjbitVec0[i2] & l2) != 0L) {
jjCheckNAddStates(0, 2);
}
break;
case 3:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 0:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
default:
break;
}
} while (i != startsAt);
}
if (kind != 0x7fffffff) {
jjmatchedKind = kind;
jjmatchedPos = curPos;
kind = 0x7fffffff;
}
++curPos;
if ((i = jjnewStateCnt) == (startsAt = 14 - (jjnewStateCnt = startsAt))) {
return curPos;
}
try {
curChar = input_stream.readChar();
} catch (java.io.IOException e) {
return curPos;
}
}
}",0,False
"protected void UpdateLineColumn(char c) {
column++;
if (prevCharIsLF) {
prevCharIsLF = false;
line += (column = 1);
} else if (prevCharIsCR) {
prevCharIsCR = false;
if (c == '\n') {
prevCharIsLF = true;
} else
line += (column = 1);
}
switch(c) {
case '\r':
prevCharIsCR = true;
break;
case '\n':
prevCharIsLF = true;
break;
case '\t':
column--;
column += (tabSize - (column % tabSize));
break;
default:
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}",0,False
"protected void FillBuff() throws java.io.IOException {
if (maxNextCharInd == available) {
if (available == bufsize) {
if (tokenBegin > 2048) {
bufpos = maxNextCharInd = 0;
available = tokenBegin;
} else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
} else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
inputStream.close();
throw new java.io.IOException();
} else
maxNextCharInd += i;
return;
} catch (java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
}
}",0,False
"public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
}",0,False
"public void ReInit(java.io.Reader dstream) {
ReInit(dstream, 1, 1, 4096);
}",0,False
"private String getName(File file) {
String name = configuration.getURL().toString();
if (name == null) {
if (file != null) {
name = file.getAbsolutePath();
} else {
name = ""base: "" + configuration.getBasePath() + ""file: "" + configuration.getFileName();
}
}
return name;
}",0,False
"public void init() {
if (configuration.getURL() == null && configuration.getFileName() == null) {
return;
}
if (this.configuration == null) {
throw new IllegalStateException(""No configuration has been set for this strategy"");
}
updateLastModified();
}",0,False
"public List<ConfigurationNode> getSubNodes(String name) {
if (name == null) {
return getSubNodes();
}
List<ConfigurationNode> result;
if (nodes == null) {
result = null;
} else {
result = namedNodes.get(name);
}
if (result == null) {
return Collections.emptyList();
} else {
return Collections.unmodifiableList(result);
}
}",0,False
"public void load(InputStream in, String encoding) throws ConfigurationException {
Reader reader = null;
if (encoding != null) {
try {
reader = new InputStreamReader(in, encoding);
} catch (UnsupportedEncodingException e) {
throw new ConfigurationException(""The requested encoding is not supported, try the default encoding."", e);
}
}
if (reader == null) {
reader = new InputStreamReader(in);
}
load(reader);
}",0,False
private List<ConfigData> configurations;,0,False
private List<ConfigData> configurations;,0,False
"private ConfigurationNode constructCombinedNode() {
if (getNumberOfConfigurations() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
} else {
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = getNodeCombiner().combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"@Override
protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertyListConfiguration();
} else {
return new PropertyListConfiguration();
}
}",0,False
"public static URL locate(FileSystem fileSystem, String base, String name) {
if (LOG.isDebugEnabled()) {
StringBuilder buf = new StringBuilder();
buf.append(""ConfigurationUtils.locate(): base is "").append(base);
buf.append("", name is "").append(name);
LOG.debug(buf.toString());
}
if (name == null) {
return null;
}
URL url = fileSystem.locateFromURL(base, name);
if (url == null) {
File file = new File(name);
if (file.isAbsolute() && file.exists()) {
try {
url = toURL(file);
LOG.debug(""Loading configuration from the absolute path "" + name);
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
}
if (url == null) {
try {
File file = constructFile(base, name);
if (file != null && file.exists()) {
url = toURL(file);
}
if (url != null) {
LOG.debug(""Loading configuration from the path "" + file);
}
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
try {
File file = constructFile(System.getProperty(""user.home""), name);
if (file != null && file.exists()) {
url = toURL(file);
}
if (url != null) {
LOG.debug(""Loading configuration from the home path "" + file);
}
} catch (MalformedURLException e) {
LOG.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
url = locateFromClasspath(name);
}
return url;
}",0,False
"public boolean containsKey(String key) {
boolean found = false;
StringBuilder query = new StringBuilder(""SELECT * FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
found = rs.next();
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
return found;
}",0,False
"public Object getProperty(String key) {
Object result = null;
StringBuilder query = new StringBuilder(""SELECT * FROM "");
query.append(table).append("" WHERE "");
query.append(keyColumn).append(""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
List<Object> results = new ArrayList<Object>();
while (rs.next()) {
Object value = rs.getObject(valueColumn);
if (isDelimiterParsingDisabled()) {
results.add(value);
} else {
Iterator<?> it = PropertyConverter.toIterator(value, getListDelimiter());
while (it.hasNext()) {
results.add(it.next());
}
}
}
if (!results.isEmpty()) {
result = (results.size() > 1) ? results : results.get(0);
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
return result;
}",0,False
"public String getPath(File file, URL url, String basePath, String fileName) {
String path = null;
if (file != null) {
path = file.getAbsolutePath();
}
if (path == null) {
if (url != null) {
path = url.getPath();
} else {
try {
path = getURL(basePath, fileName).getPath();
} catch (Exception e) {
;
}
}
}
return path;
}",0,False
"@Override
public void setRootNode(ConfigurationNode rootNode) {
if (configs != null) {
this.getCurrentConfig().setRootNode(rootNode);
} else {
super.setRootNode(rootNode);
}
}",0,False
private final Object reloadLock;,0,False
"public Lock(String name) {
this.name = name;
synchronized (counterLock) {
instanceId = ++counter;
}
}",0,False
"@Override
public void setRootNode(ConfigurationNode rootNode) {
if (init) {
this.getConfiguration().setRootNode(rootNode);
} else {
super.setRootNode(rootNode);
}
}",0,False
"public static Long toLong(Object value) throws ConversionException {
Number n = toNumber(value, Long.class);
if (n instanceof Long) {
return (Long) n;
} else {
return new Long(n.longValue());
}
}",0,False
"@Override
public ConfigurationNode getRootNode() {
if (getSubnodeKey() != null) {
try {
List<ConfigurationNode> nodes = getParent().fetchNodeList(getSubnodeKey());
if (nodes.size() != 1) {
setSubnodeKey(null);
} else {
ConfigurationNode currentRoot = nodes.get(0);
if (currentRoot != super.getRootNode()) {
fireEvent(EVENT_SUBNODE_CHANGED, null, null, true);
setRootNode(currentRoot);
fireEvent(EVENT_SUBNODE_CHANGED, null, null, false);
}
return currentRoot;
}
} catch (Exception ex) {
setSubnodeKey(null);
}
}
return super.getRootNode();
}",0,False
private final String protocol;,0,False
"private void setProperty(FileSystemConfigBuilder builder, FileSystemOptions options, String key, Object value) {
String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
Method method = builder.getClass().getMethod(methodName, paramTypes);
Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (Exception ex) {
return;
}
}",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"private XMLNode convertToXMLNode(ConfigurationNode node) {
if (node instanceof XMLNode) {
return (XMLNode) node;
}
XMLNode nd = (XMLNode) createNode(node.getName());
nd.setValue(node.getValue());
nd.setAttribute(node.isAttribute());
for (ConfigurationNode child : node.getChildren()) {
nd.addChild(convertToXMLNode(child));
}
for (ConfigurationNode attr : node.getAttributes()) {
nd.addAttribute(convertToXMLNode(attr));
}
return nd;
}",0,False
"public void setValue(Object value) throws ConfigurationRuntimeException {
try {
if (!(value instanceof String)) {
this.value = value;
return;
}
String val = (String) value;
String name = StringUtils.removeStartIgnoreCase(val, CLASS);
Class<?> clazz = ClassUtils.getClass(name);
if (name.length() == val.length()) {
this.value = clazz.newInstance();
} else {
this.value = clazz;
}
} catch (Exception e) {
throw new ConfigurationRuntimeException(""Unable to create "" + value, e);
}
}",0,False
"private void printValue(PrintWriter out, int indentLevel, Object value) {
String padding = StringUtils.repeat("" "", indentLevel * INDENT_SIZE);
if (value instanceof Date) {
synchronized (PListNode.format) {
out.println(padding + ""<date>"" + PListNode.format.format((Date) value) + ""</date>"");
}
} else if (value instanceof Calendar) {
printValue(out, indentLevel, ((Calendar) value).getTime());
} else if (value instanceof Number) {
if (value instanceof Double || value instanceof Float || value instanceof BigDecimal) {
out.println(padding + ""<real>"" + value.toString() + ""</real>"");
} else {
out.println(padding + ""<integer>"" + value.toString() + ""</integer>"");
}
} else if (value instanceof Boolean) {
if (((Boolean) value).booleanValue()) {
out.println(padding + ""<true/>"");
} else {
out.println(padding + ""<false/>"");
}
} else if (value instanceof List) {
out.println(padding + ""<array>"");
Iterator<?> it = ((List<?>) value).iterator();
while (it.hasNext()) {
printValue(out, indentLevel + 1, it.next());
}
out.println(padding + ""</array>"");
} else if (value instanceof HierarchicalConfiguration) {
printNode(out, indentLevel, ((HierarchicalConfiguration) value).getRoot());
} else if (value instanceof Configuration) {
out.println(padding + ""<dict>"");
Configuration config = (Configuration) value;
Iterator<String> it = config.getKeys();
while (it.hasNext()) {
String key = it.next();
Node node = new Node(key);
node.setValue(config.getProperty(key));
printNode(out, indentLevel + 1, node);
if (it.hasNext()) {
out.println();
}
}
out.println(padding + ""</dict>"");
} else if (value instanceof Map) {
Map<String, Object> map = transformMap((Map<?, ?>) value);
;
printValue(out, indentLevel, new MapConfiguration(map));
} else if (value instanceof byte[]) {
String base64 = new String(Base64.encodeBase64((byte[]) value));
out.println(padding + ""<data>"" + StringEscapeUtils.escapeXml(base64) + ""</data>"");
} else if (value != null) {
out.println(padding + ""<string>"" + StringEscapeUtils.escapeXml(String.valueOf(value)) + ""</string>"");
} else {
out.println(padding + ""<string/>"");
}
}",0,False
"public List<ConfigurationNode> getSubNodes(String name) {
if (name == null) {
return getSubNodes();
}
List<ConfigurationNode> result;
if (nodes == null) {
result = null;
} else {
result = namedNodes.get(name);
}
if (result == null) {
return Collections.emptyList();
} else {
return Collections.unmodifiableList(result);
}
}",0,False
"protected void performReloadCheck() {
for (Iterator it = configurations.iterator(); it.hasNext(); ) {
try {
((ConfigData) it.next()).getConfiguration().getProperty(PROP_RELOAD_CHECK);
} catch (Exception ex) {
;
}
}
}",0,True
protected Configuration configuration;,0,False
"protected void addPropertyDirect(String key, Object obj) {
StringBuffer query = new StringBuffer(""INSERT INTO "" + table);
if (nameColumn != null) {
query.append("" ("" + nameColumn + "", "" + keyColumn + "", "" + valueColumn + "") VALUES (?, ?, ?)"");
} else {
query.append("" ("" + keyColumn + "", "" + valueColumn + "") VALUES (?, ?)"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
int index = 1;
if (nameColumn != null) {
pstmt.setString(index++, name);
}
pstmt.setString(index++, key);
pstmt.setString(index++, String.valueOf(obj));
pstmt.executeUpdate();
} catch (SQLException e) {
fireError(EVENT_ADD_PROPERTY, key, obj, e);
} finally {
close(conn, pstmt);
}
}",0,False
"public void clearProperty(String key) {
StringBuffer query = new StringBuffer(""DELETE FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
pstmt.executeUpdate();
} catch (SQLException e) {
fireError(EVENT_CLEAR_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
}",0,False
"public boolean containsKey(String key) {
boolean found = false;
StringBuffer query = new StringBuffer(""SELECT * FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
found = rs.next();
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
close(conn, pstmt);
}
return found;
}",0,False
"public void setRootNode(ConfigurationNode rootNode) {
if (configs != null) {
this.getCurrentConfig().setRootNode(rootNode);
} else {
super.setRootNode(rootNode);
}
}",0,False
"static boolean isEnum(Class cls) {
if (!SystemUtils.isJavaVersionAtLeast(JAVA_VERSION_1_5)) {
return false;
}
try {
Method isEnumMethod = Class.class.getMethod(""isEnum"", new Class[] {});
return ((Boolean) isEnumMethod.invoke(cls, new Object[] {})).booleanValue();
} catch (Exception e) {
throw new RuntimeException(e.getMessage());
}
}",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
public Token currentToken;,0,False
"public void ReInit(java.io.InputStream stream) {
jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}",0,False
"final public byte[] Data() throws ParseException {
Token token;
token = jj_consume_token(DATA);
{
if (true)
return filterData(token.image);
}
throw new Error(""Missing return statement in function"");
}",0,False
"final private void jj_rescan_token() {
jj_rescan = true;
for (int i = 0; i < 1; i++) {
JJCalls p = jj_2_rtns[i];
do {
if (p.gen > jj_gen) {
jj_la = p.arg;
jj_lastpos = jj_scanpos = p.first;
switch(i) {
case 0:
jj_3_1();
break;
}
}
p = p.next;
} while (p != null);
}
jj_rescan = false;
}",0,False
"private final int jjMoveNfa_0(int startState, int curPos) {
int[] nextStates;
int startsAt = 0;
jjnewStateCnt = 14;
int i = 1;
jjstateSet[0] = startState;
int j, kind = 0x7fffffff;
for (; ; ) {
if (++jjround == 0x7fffffff) {
ReInitRounds();
}
if (curChar < 64) {
long l = 1L << curChar;
MatchLoop: do {
switch(jjstateSet[--i]) {
case 15:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x7ff280100000000L & l) != 0L) {
jjCheckNAddTwoStates(4, 5);
} else if (curChar == 62) {
if (kind > 20) {
kind = 20;
}
}
break;
case 6:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x3ff000100002600L & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
} else if (curChar == 42) {
jjstateSet[jjnewStateCnt++] = 3;
} else if (curChar == 62) {
if (kind > 19) {
kind = 19;
}
}
break;
case 14:
if ((0xfffffffbffffffffL & l) != 0L) {
jjCheckNAddStates(0, 2);
} else if (curChar == 34) {
if (kind > 22) {
kind = 22;
}
}
break;
case 3:
case 8:
if ((0xd7ffecfaffffd9ffL & l) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 0:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
} else if (curChar == 34) {
jjCheckNAddStates(0, 2);
}
if (curChar == 60) {
jjstateSet[jjnewStateCnt++] = 6;
}
if (curChar == 60) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 1:
if ((0x3ff000100002600L & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 2:
if (curChar == 62 && kind > 19) {
kind = 19;
}
break;
case 4:
if ((0x7ff280100000000L & l) != 0L) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 5:
if (curChar == 62 && kind > 20) {
kind = 20;
}
break;
case 7:
if (curChar == 60) {
jjstateSet[jjnewStateCnt++] = 6;
}
break;
case 9:
case 11:
if (curChar == 34) {
jjCheckNAddStates(0, 2);
}
break;
case 10:
if ((0xfffffffbffffffffL & l) != 0L) {
jjCheckNAddStates(0, 2);
}
break;
case 13:
if (curChar == 34 && kind > 22) {
kind = 22;
}
break;
default:
break;
}
} while (i != startsAt);
} else if (curChar < 128) {
long l = 1L << (curChar & 077);
MatchLoop: do {
switch(jjstateSet[--i]) {
case 15:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if (curChar == 90) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 6:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x7e0000007eL & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 14:
jjCheckNAddStates(0, 2);
if (curChar == 92) {
jjstateSet[jjnewStateCnt++] = 11;
}
break;
case 3:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if (curChar == 68) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 0:
case 8:
if ((0xd7ffffffffffffffL & l) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 1:
if ((0x7e0000007eL & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 4:
if (curChar == 90) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 10:
jjCheckNAddStates(0, 2);
break;
case 12:
if (curChar == 92) {
jjstateSet[jjnewStateCnt++] = 11;
}
break;
default:
break;
}
} while (i != startsAt);
} else {
int i2 = (curChar & 0xff) >> 6;
long l2 = 1L << (curChar & 077);
MatchLoop: do {
switch(jjstateSet[--i]) {
case 15:
case 8:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 6:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 14:
case 10:
if ((jjbitVec0[i2] & l2) != 0L) {
jjCheckNAddStates(0, 2);
}
break;
case 3:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 0:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
default:
break;
}
} while (i != startsAt);
}
if (kind != 0x7fffffff) {
jjmatchedKind = kind;
jjmatchedPos = curPos;
kind = 0x7fffffff;
}
++curPos;
if ((i = jjnewStateCnt) == (startsAt = 14 - (jjnewStateCnt = startsAt))) {
return curPos;
}
try {
curChar = input_stream.readChar();
} catch (java.io.IOException e) {
return curPos;
}
}
}",0,False
"public char[] GetSuffix(int len) {
char[] ret = new char[len];
if ((bufpos + 1) >= len)
System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
else {
System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
}
return ret;
}",0,False
"public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length) {
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}",0,False
"public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
}",0,False
"protected int getMaxPosition() {
return reverse ? getStartOffset() + 1 : subNodes.size() - getStartOffset();
}",0,False
"public static void dump(final ImmutableConfiguration configuration, final PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"@Override
public void read(final InputStream in) throws ConfigurationException, IOException {
load(new InputSource(in));
}",0,False
"private FileSystemOptions getOptions(final String scheme) {
if (scheme == null) {
return null;
}
final FileSystemOptions opts = new FileSystemOptions();
final FileSystemConfigBuilder builder;
try {
builder = getManager().getFileSystemConfigBuilder(scheme);
} catch (final Exception ex) {
return null;
}
final FileOptionsProvider provider = getFileOptionsProvider();
if (provider != null) {
final Map<String, Object> map = provider.getOptions();
if (map == null) {
return null;
}
int count = 0;
for (final Map.Entry<String, Object> entry : map.entrySet()) {
try {
String key = entry.getKey();
if (FileOptionsProvider.CURRENT_USER.equals(key)) {
key = ""creatorName"";
}
setProperty(builder, opts, key, entry.getValue());
++count;
} catch (final Exception ex) {
continue;
}
}
if (count > 0) {
return opts;
}
}
return null;
}",0,False
private final String protocol;,0,False
"public long getLong(String key, long defaultValue) {
return getLong(key, new Long(defaultValue)).longValue();
}",0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue)).floatValue();
}",0,False
"private boolean hasDelimiter() {
int count = 0;
for (int idx = keyBuffer.length() - 1; idx >= 0 && keyBuffer.charAt(idx) == PROPERTY_DELIMITER; idx--) {
count++;
}
return count % 2 == 1;
}",0,False
"public boolean containsKey(String key) {
boolean found = false;
StringBuffer query = new StringBuffer(""SELECT * FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
found = rs.next();
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
closeQuietly(conn, pstmt);
}
return found;
}",0,False
"private void load(InputSource source) throws ConfigurationException {
try {
URL sourceURL = getDelegate().getURL();
if (sourceURL != null) {
source.setSystemId(sourceURL.toString());
}
DocumentBuilder builder = createDocumentBuilder();
Document newDocument = builder.parse(source);
Document oldDocument = document;
document = null;
initProperties(newDocument, oldDocument == null);
document = (oldDocument == null) ? newDocument : oldDocument;
} catch (Exception e) {
throw new ConfigurationException(e.getMessage(), e);
}
}",0,False
"public void load(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
// todo: support included properties ?
}",0,False
"final public byte[] Data() throws ParseException {
Token token;
token = jj_consume_token(DATA);
return filterData(token.image);
}",0,False
"final public PropertyListConfiguration Dictionary() throws ParseException {
PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1: while (true) {
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration) {
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
} else {
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++) {
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
return configuration;
}",0,False
"protected void FillBuff() throws java.io.IOException {
if (maxNextCharInd == available) {
if (available == bufsize) {
if (tokenBegin > 2048) {
bufpos = maxNextCharInd = 0;
available = tokenBegin;
} else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
} else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
inputStream.close();
throw new java.io.IOException();
} else
maxNextCharInd += i;
return;
} catch (java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
}
}",0,False
"public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length) {
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}",0,False
"public void addDataValue(String value) {
addValue(Base64.decodeBase64(value.getBytes()));
}",0,False
"protected File getFile() {
return (configuration.getURL() != null) ? fileFromURL(configuration.getURL()) : configuration.getFile();
}",0,False
"public boolean removeNodes(String name) {
if (nodes != null && name != null) {
List lst = (List) namedNodes.remove(name);
if (lst != null) {
detachNodes(lst);
nodes.removeAll(lst);
return true;
}
}
return false;
}",0,False
"@Override
public void visitBeforeChildren(ImmutableNode node, NodeHandler<ImmutableNode> handler) {
ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"@Override
public void read(InputStream in) throws ConfigurationException, IOException {
load(new InputSource(in));
}",0,False
"private static Class<?> getDefaultClass(Object bean, String propName) {
try {
PropertyDescriptor desc = BEAN_UTILS_BEAN.getPropertyUtils().getPropertyDescriptor(bean, propName);
if (desc == null) {
return null;
}
return desc.getPropertyType();
} catch (Exception ex) {
return null;
}
}",0,False
private final Configuration configuration;,0,False
private ExpressionEngine conversionExpressionEngine;,0,False
private ResultSet resultSet;,0,False
"private void setProperty(FileSystemConfigBuilder builder, FileSystemOptions options, String key, Object value) {
String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
Method method = builder.getClass().getMethod(methodName, paramTypes);
Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (Exception ex) {
return;
}
}",0,False
"@Override
public BeanInfo[] getAdditionalBeanInfo() {
return additionalBeanInfo;
}",0,False
"public static Long toLong(Object value) throws ConversionException {
Number n = toNumber(value, Long.class);
if (n instanceof Long) {
return (Long) n;
} else {
return new Long(n.longValue());
}
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = ConfigurationUtils.locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = ConfigurationUtils.locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"public NodePointer getNodePointer() {
if (getPosition() < 1 && !setPosition(1)) {
return null;
}
return createNodePointer(subNodes.get(positionToIndex(getPosition())));
}",0,False
private ConfigurationNode node;,0,False
"protected PreparedStatement createStatement(String sql, boolean nameCol) throws SQLException {
String statement;
if (nameCol && configurationNameColumn != null) {
StringBuilder buf = new StringBuilder(sql);
buf.append("" AND "").append(configurationNameColumn).append(""=?"");
statement = buf.toString();
} else {
statement = sql;
}
pstmt = getConnection().prepareStatement(statement);
return pstmt;
}",0,False
private ReloadingController reloadingController;,0,False
"@Override
public void read(Reader in) throws ConfigurationException {
EntityResolver resolver = new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler();
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
getNodeModel().mergeRoot(handler.getResultBuilder().createNode(), null, null, null, this);
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"private void printNode(PrintWriter out, int indentLevel, ImmutableNode node) {
String padding = StringUtils.repeat("" "", indentLevel * INDENT_SIZE);
if (node.getNodeName() != null) {
out.println(padding + ""<key>"" + StringEscapeUtils.escapeXml10(node.getNodeName()) + ""</key>"");
}
List<ImmutableNode> children = node.getChildren();
if (!children.isEmpty()) {
out.println(padding + ""<dict>"");
Iterator<ImmutableNode> it = children.iterator();
while (it.hasNext()) {
ImmutableNode child = it.next();
printNode(out, indentLevel + 1, child);
if (it.hasNext()) {
out.println();
}
}
out.println(padding + ""</dict>"");
} else if (node.getValue() == null) {
out.println(padding + ""<dict/>"");
} else {
Object value = node.getValue();
printValue(out, indentLevel, value);
}
}",0,False
"@Override
protected String normalizeURI(String uriref) {
ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
String resolved = (ci != null) ? String.valueOf(ci.interpolate(uriref)) : uriref;
return super.normalizeURI(resolved);
}",0,False
"@Override
public void visitBeforeChildren(ImmutableNode node, NodeHandler<ImmutableNode> handler) {
ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"@Override
protected Boolean performOperation() throws SQLException {
PreparedStatement pstmt = initStatement(String.format(SQL_GET_PROPERTY, table, keyColumn), true, key);
ResultSet rs = pstmt.executeQuery();
return rs.next();
}",0,False
private ConfigurationSourceData sourceData;,0,False
"public static Integer toInteger(Object value) throws ConversionException {
Number n = toNumber(value, Integer.class);
if (n instanceof Integer) {
return (Integer) n;
} else {
return new Integer(n.intValue());
}
}",0,False
"public static Byte toByte(Object value) throws ConversionException {
Number n = toNumber(value, Byte.class);
if (n instanceof Byte) {
return (Byte) n;
} else {
return new Byte(n.byteValue());
}
}",0,False
private final EventType<? extends Event> eventType;,0,False
"public void setValue(Object value) throws ConfigurationRuntimeException {
try {
if (!(value instanceof String)) {
this.value = value;
return;
}
String val = (String) value;
String name = StringUtils.removeStartIgnoreCase(val, CLASS);
Class<?> clazz = ClassUtils.getClass(name);
if (name.length() == val.length()) {
this.value = clazz.newInstance();
} else {
this.value = clazz;
}
} catch (Exception e) {
throw new ConfigurationRuntimeException(""Unable to create "" + value, e);
}
}",0,False
"public void setValue(Object value) throws ConfigurationRuntimeException {
try {
if (!(value instanceof String)) {
this.value = value;
return;
}
String val = (String) value;
String name = StringUtils.removeStartIgnoreCase(val, CLASS);
Class<?> clazz = ClassUtils.getClass(name);
if (name.length() == val.length()) {
this.value = clazz.newInstance();
} else {
this.value = clazz;
}
} catch (Exception e) {
throw new ConfigurationRuntimeException(""Unable to create "" + value, e);
}
}",0,False
"private void createPath(File file) {
if (file != null) {
if (!file.exists()) {
File parent = file.getParentFile();
if (parent != null && !parent.exists()) {
parent.mkdirs();
}
}
}
}",0,False
"private void printValue(PrintWriter out, int indentLevel, Object value) {
String padding = StringUtils.repeat("" "", indentLevel * INDENT_SIZE);
if (value instanceof Date) {
synchronized (PListNodeBuilder.FORMAT) {
out.println(padding + ""<date>"" + PListNodeBuilder.FORMAT.format((Date) value) + ""</date>"");
}
} else if (value instanceof Calendar) {
printValue(out, indentLevel, ((Calendar) value).getTime());
} else if (value instanceof Number) {
if (value instanceof Double || value instanceof Float || value instanceof BigDecimal) {
out.println(padding + ""<real>"" + value.toString() + ""</real>"");
} else {
out.println(padding + ""<integer>"" + value.toString() + ""</integer>"");
}
} else if (value instanceof Boolean) {
if (((Boolean) value).booleanValue()) {
out.println(padding + ""<true/>"");
} else {
out.println(padding + ""<false/>"");
}
} else if (value instanceof List) {
out.println(padding + ""<array>"");
for (Object o : (List<?>) value) {
printValue(out, indentLevel + 1, o);
}
out.println(padding + ""</array>"");
} else if (value instanceof HierarchicalConfiguration) {
@SuppressWarnings(""unchecked"")
HierarchicalConfiguration<ImmutableNode> config = (HierarchicalConfiguration<ImmutableNode>) value;
printNode(out, indentLevel, config.getNodeModel().getNodeHandler().getRootNode());
} else if (value instanceof Configuration) {
out.println(padding + ""<dict>"");
Configuration config = (Configuration) value;
Iterator<String> it = config.getKeys();
while (it.hasNext()) {
String key = it.next();
ImmutableNode node = new ImmutableNode.Builder().name(key).value(config.getProperty(key)).create();
printNode(out, indentLevel + 1, node);
if (it.hasNext()) {
out.println();
}
}
out.println(padding + ""</dict>"");
} else if (value instanceof Map) {
Map<String, Object> map = transformMap((Map<?, ?>) value);
printValue(out, indentLevel, new MapConfiguration(map));
} else if (value instanceof byte[]) {
String base64 = new String(Base64.encodeBase64((byte[]) value));
out.println(padding + ""<data>"" + StringEscapeUtils.escapeXml(base64) + ""</data>"");
} else if (value != null) {
out.println(padding + ""<string>"" + StringEscapeUtils.escapeXml(String.valueOf(value)) + ""</string>"");
} else {
out.println(padding + ""<string/>"");
}
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
EntityResolver resolver = new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler();
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
getNodeModel().mergeRoot(handler.getResultBuilder().createNode(), null, null, null, this);
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"@Override
public void visitBeforeChildren(final ImmutableNode node, final NodeHandler<ImmutableNode> handler) {
final ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
final Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
final ByteArrayOutputStream os = new ByteArrayOutputStream();
final PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}",0,False
"private ImmutableNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
final Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
final ByteArrayOutputStream os = new ByteArrayOutputStream();
final PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}",0,False
"protected PreparedStatement createStatement(final String sql, final boolean nameCol) throws SQLException {
final String statement;
if (nameCol && configurationNameColumn != null) {
final StringBuilder buf = new StringBuilder(sql);
buf.append("" AND "").append(configurationNameColumn).append(""=?"");
statement = buf.toString();
} else {
statement = sql;
}
pstmt = getConnection().prepareStatement(statement);
return pstmt;
}",0,False
"@Override
public void read(final Reader in) throws ConfigurationException {
final SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
final SAXParser parser = factory.newSAXParser();
final XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver((publicId, systemId) -> new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd"")));
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (final Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
// todo: support included properties ?
}",0,False
private final ImmutableConfiguration configuration;,0,False
"private ConfigurationBuilderEvent createEventWithChangedSource(final ConfigurationBuilderEvent event) {
if (ConfigurationBuilderResultCreatedEvent.RESULT_CREATED.equals(event.getEventType())) {
return new ConfigurationBuilderResultCreatedEvent(this, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED, ((ConfigurationBuilderResultCreatedEvent) event).getConfiguration());
}
@SuppressWarnings(""unchecked"")
final EventType<? extends ConfigurationBuilderEvent> type = (EventType<? extends ConfigurationBuilderEvent>) event.getEventType();
return new ConfigurationBuilderEvent(this, type);
}",0,False
"@Override
public CombinedConfiguration getConfiguration() throws ConfigurationException {
final CombinedConfiguration result = super.getConfiguration();
reloadingController.resetReloadingState();
return result;
}",0,False
"private void setProperty(final FileSystemConfigBuilder builder, final FileSystemOptions options, final String key, final Object value) {
final String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
final Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
final Method method = builder.getClass().getMethod(methodName, paramTypes);
final Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (final Exception ex) {
log.warn(""Cannot access property '"" + key + ""'! Ignoring."", ex);
}
}",0,False
"@Override
protected String normalizeURI(final String uriref) {
final ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
final String resolved = ci != null ? String.valueOf(ci.interpolate(uriref)) : uriref;
return super.normalizeURI(resolved);
}",0,False
private final QueryResult<T> attributeResult;,0,False
"@Override
@SuppressWarnings(""unchecked"")
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
if (bean instanceof NodeWrapper) {
final NodeWrapper<?> wrapper = (NodeWrapper<?>) bean;
return new ConfigurationNodePointer((ConfigurationNodePointer) parent, wrapper.getNode(), wrapper.getNodeHandler());
}
return null;
}",0,False
"private ConfigurationNode constructCombinedNode() {
if (getNumberOfConfigurationsInternal() < 1) {
if (getLogger().isDebugEnabled()) {
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
} else {
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext()) {
node = nodeCombiner.combine(node, it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled()) {
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}",0,False
"public static void dump(Configuration configuration, PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
private final ConfigurationInterpolator localSubst;,0,False
"@Override
protected void setPropertyInternal(String key, Object value) {
getConfig().setProperty(key, value);
}",0,False
"public void read(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
private ConfigurationSourceData sourceData;,0,False
"public static Integer toInteger(Object value) throws ConversionException {
Number n = toNumber(value, Integer.class);
if (n instanceof Integer) {
return (Integer) n;
} else {
return new Integer(n.intValue());
}
}",0,False
"public static Double toDouble(Object value) throws ConversionException {
Number n = toNumber(value, Double.class);
if (n instanceof Double) {
return (Double) n;
} else {
return new Double(n.doubleValue());
}
}",0,False
"public static Float toFloat(Object value) throws ConversionException {
Number n = toNumber(value, Float.class);
if (n instanceof Float) {
return (Float) n;
} else {
return new Float(n.floatValue());
}
}",0,False
"private void setProperty(FileSystemConfigBuilder builder, FileSystemOptions options, String key, Object value) {
String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
Class<?>[] paramTypes = new Class<?>[2];
paramTypes[0] = FileSystemOptions.class;
paramTypes[1] = value.getClass();
try {
Method method = builder.getClass().getMethod(methodName, paramTypes);
Object[] params = new Object[2];
params[0] = options;
params[1] = value;
method.invoke(builder, params);
} catch (Exception ex) {
return;
}
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"public boolean removeNode(ConfigurationNode node) {
if (nodes != null && node != null && nodes.contains(node)) {
detachNode(node);
nodes.remove(node);
List<ConfigurationNode> lst = namedNodes.get(node.getName());
if (lst != null) {
lst.remove(node);
if (lst.isEmpty()) {
namedNodes.remove(node.getName());
}
}
return true;
} else {
return false;
}
}",0,False
"public void reload() {
synchronized (reloadLock) {
if (noReload == 0) {
try {
enterNoReload();
if (strategy.reloadingRequired()) {
if (getLogger().isInfoEnabled()) {
getLogger().info(""Reloading configuration. URL is "" + getURL());
}
fireEvent(EVENT_RELOAD, null, getURL(), true);
setDetailEvents(false);
boolean autoSaveBak = this.isAutoSave();
this.setAutoSave(false);
try {
clear();
load();
} finally {
this.setAutoSave(autoSaveBak);
setDetailEvents(true);
}
fireEvent(EVENT_RELOAD, null, getURL(), false);
strategy.reloadingPerformed();
}
} catch (Exception e) {
fireError(EVENT_RELOAD, null, null, e);
} finally {
exitNoReload();
}
}
}
}",0,False
"private void createPath(File file) {
if (file != null) {
if (!file.exists()) {
File parent = file.getParentFile();
if (parent != null && !parent.exists()) {
parent.mkdirs();
}
}
}
}",0,False
"protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertiesConfiguration();
} else {
return new PropertiesConfiguration();
}
}",0,False
protected Configuration configuration;,0,False
"public boolean isEmpty() {
boolean empty = true;
StringBuffer query = new StringBuffer(""SELECT count(*) FROM "" + table);
if (nameColumn != null) {
query.append("" WHERE "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
if (nameColumn != null) {
pstmt.setString(1, name);
}
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
empty = rs.getInt(1) == 0;
}
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, null, null, e);
} finally {
close(conn, pstmt);
}
return empty;
}",0,False
"void extractProperties15() {
try {
Method method = System.class.getMethod(METHOD_NAME, null);
environment = (Map) method.invoke(null, null);
} catch (Exception ex) {
throw new ConfigurationRuntimeException(""Error when accessing environment properties"", ex);
}
}",0,False
private ConfigurationNode rootNode;,0,False
public Token currentToken;,0,False
"protected byte[] filterData(String s) throws ParseException {
if (s == null) {
return null;
}
if (s.startsWith(""<"") && s.endsWith("">"") && s.length() >= 2) {
s = s.substring(1, s.length() - 1);
}
s = StringUtils.replaceChars(s, "" \t\n\r"", """");
if (s.length() % 2 != 0) {
s = ""0"" + s;
}
try {
return Hex.decodeHex(s.toCharArray());
} catch (Exception e) {
throw (ParseException) new ParseException(""Unable to parse the byte[] : "" + e.getMessage());
}
}",0,False
"public void ReInit(SimpleCharStream stream, int lexState) {
ReInit(stream);
SwitchTo(lexState);
}",0,False
"public char[] GetSuffix(int len) {
char[] ret = new char[len];
if ((bufpos + 1) >= len)
System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
else {
System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
}
return ret;
}",0,False
"public char BeginToken() throws java.io.IOException {
tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
}",0,False
"public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
}",0,False
"public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {
ReInit(dstream, startline, startcolumn, 4096);
}",0,False
"public void ReInit(java.io.Reader dstream) {
ReInit(dstream, 1, 1, 4096);
}",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"public double getDouble(String key, double defaultValue) {
return getDouble(key, new Double(defaultValue)).doubleValue();
}",0,False
"protected Object resolveContainerStore(String key) {
Object value = getProperty(key);
if (value != null) {
if (value instanceof List) {
List list = (List) value;
value = list.isEmpty() ? null : list.get(0);
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
value = array.length == 0 ? null : array[0];
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
value = array.length == 0 ? null : array[0] ? Boolean.TRUE : Boolean.FALSE;
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
value = array.length == 0 ? null : new Byte(array[0]);
} else if (value instanceof short[]) {
short[] array = (short[]) value;
value = array.length == 0 ? null : new Short(array[0]);
} else if (value instanceof int[]) {
int[] array = (int[]) value;
value = array.length == 0 ? null : new Integer(array[0]);
} else if (value instanceof long[]) {
long[] array = (long[]) value;
value = array.length == 0 ? null : new Long(array[0]);
} else if (value instanceof float[]) {
float[] array = (float[]) value;
value = array.length == 0 ? null : new Float(array[0]);
} else if (value instanceof double[]) {
double[] array = (double[]) value;
value = array.length == 0 ? null : new Double(array[0]);
}
}
return value;
}",0,False
"public void load(InputStream in, String encoding) throws ConfigurationException {
Reader reader = null;
if (encoding != null) {
try {
reader = new InputStreamReader(in, encoding);
} catch (UnsupportedEncodingException e) {
throw new ConfigurationException(""The requested encoding is not supported, try the default encoding."", e);
}
}
if (reader == null) {
reader = new InputStreamReader(in);
}
load(reader);
}",0,False
"public static URL locate(String base, String name) {
if (log.isDebugEnabled()) {
StringBuffer buf = new StringBuffer();
buf.append(""ConfigurationUtils.locate(): base is "").append(base);
buf.append("", name is "").append(name);
log.debug(buf.toString());
}
if (name == null) {
return null;
}
URL url = null;
try {
if (base == null) {
url = new URL(name);
} else {
URL baseURL = new URL(base);
url = new URL(baseURL, name);
InputStream in = null;
try {
in = url.openStream();
} finally {
if (in != null) {
in.close();
}
}
}
log.debug(""Loading configuration from the URL "" + url);
} catch (IOException e) {
url = null;
}
if (url == null) {
File file = new File(name);
if (file.isAbsolute() && file.exists()) {
try {
url = file.toURL();
log.debug(""Loading configuration from the absolute path "" + name);
} catch (MalformedURLException e) {
log.warn(""Could not obtain URL from file"", e);
}
}
}
if (url == null) {
try {
File file = constructFile(base, name);
if (file != null && file.exists()) {
url = file.toURL();
}
if (url != null) {
log.debug(""Loading configuration from the path "" + file);
}
} catch (MalformedURLException e) {
log.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
try {
File file = constructFile(System.getProperty(""user.home""), name);
if (file != null && file.exists()) {
url = file.toURL();
}
if (url != null) {
log.debug(""Loading configuration from the home path "" + file);
}
} catch (MalformedURLException e) {
log.warn(""Could not obtain URL from file"", e);
}
}
if (url == null) {
url = locateFromClasspath(name);
}
return url;
}",0,False
"public boolean containsKey(String key) {
boolean found = false;
StringBuffer query = new StringBuffer(""SELECT * FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
ResultSet rs = pstmt.executeQuery();
found = rs.next();
} catch (SQLException e) {
fireError(EVENT_READ_PROPERTY, key, null, e);
} finally {
closeQuietly(conn, pstmt);
}
return found;
}",0,False
"protected Object createBeanInstance(Class beanClass, BeanDeclaration data) throws Exception {
String fileName = ((ConfigurationDeclaration) data).getConfiguration().getString(ATTR_FILENAME);
if (fileName != null && fileName.toLowerCase().trim().endsWith(fileExtension)) {
return super.createBeanInstance(fetchMatchingClass(), data);
} else {
return super.createBeanInstance(fetchDefaultClass(), data);
}
}",0,False
"public static Double toDouble(Object value) throws ConversionException {
Number n = toNumber(value, Double.class);
if (n instanceof Double) {
return (Double) n;
} else {
return new Double(n.doubleValue());
}
}",0,False
"public static Float toFloat(Object value) throws ConversionException {
Number n = toNumber(value, Float.class);
if (n instanceof Float) {
return (Float) n;
} else {
return new Float(n.floatValue());
}
}",0,False
private Document document;,0,False
"public void load(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"public static void initBean(Object bean, BeanDeclaration data) throws ConfigurationRuntimeException {
Map properties = data.getBeanProperties();
if (properties != null) {
for (Iterator it = properties.keySet().iterator(); it.hasNext(); ) {
String propName = (String) it.next();
initProperty(bean, propName, properties.get(propName));
}
}
Map nestedBeans = data.getNestedBeanDeclarations();
if (nestedBeans != null) {
for (Iterator it = nestedBeans.keySet().iterator(); it.hasNext(); ) {
String propName = (String) it.next();
initProperty(bean, propName, createBean((BeanDeclaration) nestedBeans.get(propName), null));
}
}
}",0,False
"public void set(String name, Object value) {
if (log.isTraceEnabled()) {
log.trace(""set("" + name + "","" + value + "")"");
}
if (value == null) {
throw new NullPointerException(""Error trying to set property to null."");
}
if (value instanceof List) {
List list = (List) value;
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
getConfiguration().addProperty(name, iterator.next());
}
} else if (value instanceof int[]) {
int[] array = (int[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Integer(array[i]));
}
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, BooleanUtils.toBooleanObject(array[i]));
}
} else if (value instanceof char[]) {
char[] array = (char[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Character(array[i]));
}
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Byte(array[i]));
}
} else if (value instanceof short[]) {
short[] array = (short[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Short(array[i]));
}
} else if (value instanceof long[]) {
long[] array = (long[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Long(array[i]));
}
} else if (value instanceof float[]) {
float[] array = (float[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Float(array[i]));
}
} else if (value instanceof double[]) {
double[] array = (double[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Double(array[i]));
}
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, array[i]);
}
} else {
getConfiguration().setProperty(name, value);
}
}",0,False
"public void set(String name, Object value) {
if (log.isTraceEnabled()) {
log.trace(""set("" + name + "","" + value + "")"");
}
if (value == null) {
throw new NullPointerException(""Error trying to set property to null."");
}
if (value instanceof List) {
List list = (List) value;
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
getConfiguration().addProperty(name, iterator.next());
}
} else if (value instanceof int[]) {
int[] array = (int[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Integer(array[i]));
}
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, BooleanUtils.toBooleanObject(array[i]));
}
} else if (value instanceof char[]) {
char[] array = (char[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Character(array[i]));
}
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Byte(array[i]));
}
} else if (value instanceof short[]) {
short[] array = (short[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Short(array[i]));
}
} else if (value instanceof long[]) {
long[] array = (long[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Long(array[i]));
}
} else if (value instanceof float[]) {
float[] array = (float[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Float(array[i]));
}
} else if (value instanceof double[]) {
double[] array = (double[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Double(array[i]));
}
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, array[i]);
}
} else {
getConfiguration().setProperty(name, value);
}
}",0,False
"public void set(String name, Object value) {
if (log.isTraceEnabled()) {
log.trace(""set("" + name + "","" + value + "")"");
}
if (value == null) {
throw new NullPointerException(""Error trying to set property to null."");
}
if (value instanceof List) {
List list = (List) value;
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
getConfiguration().addProperty(name, iterator.next());
}
} else if (value instanceof int[]) {
int[] array = (int[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Integer(array[i]));
}
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, BooleanUtils.toBooleanObject(array[i]));
}
} else if (value instanceof char[]) {
char[] array = (char[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Character(array[i]));
}
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Byte(array[i]));
}
} else if (value instanceof short[]) {
short[] array = (short[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Short(array[i]));
}
} else if (value instanceof long[]) {
long[] array = (long[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Long(array[i]));
}
} else if (value instanceof float[]) {
float[] array = (float[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Float(array[i]));
}
} else if (value instanceof double[]) {
double[] array = (double[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Double(array[i]));
}
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, array[i]);
}
} else {
getConfiguration().setProperty(name, value);
}
}",0,False
"public void set(String name, Object value) {
if (log.isTraceEnabled()) {
log.trace(""set("" + name + "","" + value + "")"");
}
if (value == null) {
throw new NullPointerException(""Error trying to set property to null."");
}
if (value instanceof List) {
List list = (List) value;
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
getConfiguration().addProperty(name, iterator.next());
}
} else if (value instanceof int[]) {
int[] array = (int[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Integer(array[i]));
}
} else if (value instanceof boolean[]) {
boolean[] array = (boolean[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, BooleanUtils.toBooleanObject(array[i]));
}
} else if (value instanceof char[]) {
char[] array = (char[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Character(array[i]));
}
} else if (value instanceof byte[]) {
byte[] array = (byte[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Byte(array[i]));
}
} else if (value instanceof short[]) {
short[] array = (short[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Short(array[i]));
}
} else if (value instanceof long[]) {
long[] array = (long[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Long(array[i]));
}
} else if (value instanceof float[]) {
float[] array = (float[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Float(array[i]));
}
} else if (value instanceof double[]) {
double[] array = (double[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, new Double(array[i]));
}
} else if (value instanceof Object[]) {
Object[] array = (Object[]) value;
for (int i = 0; i < array.length; i++) {
getConfiguration().addProperty(name, array[i]);
}
} else {
getConfiguration().setProperty(name, value);
}
}",0,False
public Token currentToken;,0,False
"final public byte[] Data() throws ParseException {
Token token;
token = jj_consume_token(DATA);
return filterData(token.image);
}",0,False
"final public Node Property() throws ParseException {
Node node = new Node();
String key = String();
node.setName(key);
jj_consume_token(EQUAL);
Object value = Element();
node.setValue(value);
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
return node;
}",0,False
public PrintStream debugStream = System.out;,0,False
"private final void ReInitRounds() {
int i;
jjround = 0x80000001;
for (i = 9; i-- > 0; ) jjrounds[i] = 0x80000000;
}",0,False
"public void addDataValue(String value) {
addValue(Base64.decodeBase64(value.getBytes()));
}",0,False
"public void addRealValue(String value) {
addValue(new Double(value));
}",0,False
"private void printValue(PrintWriter out, int indentLevel, Object value) {
String padding = StringUtils.repeat("" "", indentLevel * INDENT_SIZE);
if (value instanceof Date) {
out.println(padding + ""<date>"" + PListNode.format.format((Date) value) + ""</date>"");
} else if (value instanceof Calendar) {
printValue(out, indentLevel, ((Calendar) value).getTime());
} else if (value instanceof Number) {
if (value instanceof Double || value instanceof Float || value instanceof BigDecimal) {
out.println(padding + ""<real>"" + value.toString() + ""</real>"");
} else {
out.println(padding + ""<integer>"" + value.toString() + ""</integer>"");
}
} else if (value instanceof Boolean) {
if (((Boolean) value).booleanValue()) {
out.println(padding + ""<true/>"");
} else {
out.println(padding + ""<false/>"");
}
} else if (value instanceof List) {
out.println(padding + ""<array>"");
Iterator it = ((List) value).iterator();
while (it.hasNext()) {
printValue(out, indentLevel + 1, it.next());
}
out.println(padding + ""</array>"");
} else if (value instanceof HierarchicalConfiguration) {
printNode(out, indentLevel, ((HierarchicalConfiguration) value).getRoot());
} else if (value instanceof Configuration) {
out.println(padding + ""<dict>"");
Configuration config = (Configuration) value;
Iterator it = config.getKeys();
while (it.hasNext()) {
String key = (String) it.next();
Node node = new Node(key);
node.setValue(config.getProperty(key));
printNode(out, indentLevel + 1, node);
if (it.hasNext()) {
out.println();
}
}
out.println(padding + ""</dict>"");
} else if (value instanceof Map) {
Map map = (Map) value;
printValue(out, indentLevel, new MapConfiguration(map));
} else if (value instanceof byte[]) {
String base64 = new String(Base64.encodeBase64((byte[]) value));
out.println(padding + ""<data>"" + StringEscapeUtils.escapeXml(base64) + ""</data>"");
} else {
out.println(padding + ""<string>"" + StringEscapeUtils.escapeXml(String.valueOf(value)) + ""</string>"");
}
}",0,False
"protected File getFile() {
return (configuration.getURL() != null) ? fileFromURL(configuration.getURL()) : configuration.getFile();
}",0,False
"@Override
public void visitBeforeChildren(ImmutableNode node, NodeHandler<ImmutableNode> handler) {
ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(false);
factory.setValidating(true);
try {
SAXParser parser = factory.newSAXParser();
XMLReader xmlReader = parser.getXMLReader();
xmlReader.setEntityResolver(new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
}
});
xmlReader.setContentHandler(new XMLPropertiesHandler());
xmlReader.parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
private final ImmutableConfiguration configuration;,0,False
private AutoSaveListener autoSaveListener;,0,False
private ConfigurationSourceData sourceData;,0,False
"private ConfigurationBuilderEvent createEventWithChangedSource(ConfigurationBuilderEvent event) {
if (ConfigurationBuilderResultCreatedEvent.RESULT_CREATED.equals(event.getEventType())) {
return new ConfigurationBuilderResultCreatedEvent(this, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED, ((ConfigurationBuilderResultCreatedEvent) event).getConfiguration());
}
@SuppressWarnings(""unchecked"")
EventType<? extends ConfigurationBuilderEvent> type = (EventType<? extends ConfigurationBuilderEvent>) event.getEventType();
return new ConfigurationBuilderEvent(this, type);
}",0,False
private ReloadingController reloadingController;,0,False
"public static Float toFloat(Object value) throws ConversionException {
Number n = toNumber(value, Float.class);
if (n instanceof Float) {
return (Float) n;
} else {
return new Float(n.floatValue());
}
}",0,False
"static Object toInternetAddress(Object value) throws ConversionException {
if (value.getClass().getName().equals(INTERNET_ADDRESS_CLASSNAME)) {
return value;
} else if (value instanceof String) {
try {
Constructor<?> ctor = Class.forName(INTERNET_ADDRESS_CLASSNAME).getConstructor(String.class);
return ctor.newInstance(value);
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"", e);
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"");
}
}",0,False
"public void setValue(Object value) throws ConfigurationRuntimeException {
try {
if (!(value instanceof String)) {
this.value = value;
return;
}
String val = (String) value;
String name = StringUtils.removeStartIgnoreCase(val, CLASS);
Class<?> clazz = ClassUtils.getClass(name);
if (name.length() == val.length()) {
this.value = clazz.newInstance();
} else {
this.value = clazz;
}
} catch (Exception e) {
throw new ConfigurationRuntimeException(""Unable to create "" + value, e);
}
}",0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue)).floatValue();
}",0,False
"@Override
protected FileConfiguration createConfiguration(Attributes attributes) throws Exception {
String filename = attributes.getValue(ATTR_FILENAME);
if (filename != null && filename.toLowerCase().trim().endsWith("".xml"")) {
return new XMLPropertiesConfiguration();
} else {
return new PropertiesConfiguration();
}
}",0,False
"@Override
protected void clearPropertyDirect(String key) {
StringBuilder query = new StringBuilder(""DELETE FROM "" + table + "" WHERE "" + keyColumn + ""=?"");
if (nameColumn != null) {
query.append("" AND "" + nameColumn + ""=?"");
}
Connection conn = null;
PreparedStatement pstmt = null;
try {
conn = getConnection();
pstmt = conn.prepareStatement(query.toString());
pstmt.setString(1, key);
if (nameColumn != null) {
pstmt.setString(2, name);
}
pstmt.executeUpdate();
commitIfRequired(conn);
} catch (SQLException e) {
fireError(EVENT_CLEAR_PROPERTY, key, null, e);
} finally {
close(conn, pstmt, null);
}
}",0,False
private NodeCombiner nodeCombiner;,0,False
private NodeCombiner nodeCombiner;,0,False
private final Object reloadLock;,0,False
private final Object reloadLock;,0,False
"private ReloadingStrategy createReloadingStrategy() {
if (fileStrategy == null) {
return null;
}
try {
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
} catch (Exception ex) {
return null;
}
}",0,False
"public static Byte toByte(Object value) throws ConversionException {
Number n = toNumber(value, Byte.class);
if (n instanceof Byte) {
return (Byte) n;
} else {
return new Byte(n.byteValue());
}
}",0,False
private final String protocol;,0,False
"private XMLNode convertToXMLNode(ConfigurationNode node) {
if (node instanceof XMLNode) {
return (XMLNode) node;
}
XMLNode nd = (XMLNode) createNode(node.getName());
nd.setValue(node.getValue());
nd.setAttribute(node.isAttribute());
for (ConfigurationNode child : node.getChildren()) {
nd.addChild(convertToXMLNode(child));
}
for (ConfigurationNode attr : node.getAttributes()) {
nd.addAttribute(convertToXMLNode(attr));
}
return nd;
}",0,False
"private void printValue(PrintWriter out, int indentLevel, Object value) {
String padding = StringUtils.repeat("" "", indentLevel * INDENT_SIZE);
if (value instanceof Date) {
synchronized (PListNode.FORMAT) {
out.println(padding + ""<date>"" + PListNode.FORMAT.format((Date) value) + ""</date>"");
}
} else if (value instanceof Calendar) {
printValue(out, indentLevel, ((Calendar) value).getTime());
} else if (value instanceof Number) {
if (value instanceof Double || value instanceof Float || value instanceof BigDecimal) {
out.println(padding + ""<real>"" + value.toString() + ""</real>"");
} else {
out.println(padding + ""<integer>"" + value.toString() + ""</integer>"");
}
} else if (value instanceof Boolean) {
if (((Boolean) value).booleanValue()) {
out.println(padding + ""<true/>"");
} else {
out.println(padding + ""<false/>"");
}
} else if (value instanceof List) {
out.println(padding + ""<array>"");
Iterator<?> it = ((List<?>) value).iterator();
while (it.hasNext()) {
printValue(out, indentLevel + 1, it.next());
}
out.println(padding + ""</array>"");
} else if (value instanceof HierarchicalConfiguration) {
printNode(out, indentLevel, ((HierarchicalConfiguration) value).getRoot());
} else if (value instanceof Configuration) {
out.println(padding + ""<dict>"");
Configuration config = (Configuration) value;
Iterator<String> it = config.getKeys();
while (it.hasNext()) {
String key = it.next();
Node node = new Node(key);
node.setValue(config.getProperty(key));
printNode(out, indentLevel + 1, node);
if (it.hasNext()) {
out.println();
}
}
out.println(padding + ""</dict>"");
} else if (value instanceof Map) {
Map<String, Object> map = transformMap((Map<?, ?>) value);
printValue(out, indentLevel, new MapConfiguration(map));
} else if (value instanceof byte[]) {
String base64 = new String(Base64.encodeBase64((byte[]) value));
out.println(padding + ""<data>"" + StringEscapeUtils.escapeXml(base64) + ""</data>"");
} else if (value != null) {
out.println(padding + ""<string>"" + StringEscapeUtils.escapeXml(String.valueOf(value)) + ""</string>"");
} else {
out.println(padding + ""<string/>"");
}
}",0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = ConfigurationUtils.locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = (url == null) ? fileName : url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
private ConfigurationNode node;,0,False
private final ImmutableConfiguration configuration;,0,False
private AutoSaveListener autoSaveListener;,0,False
"static Object toInternetAddress(final Object value) throws ConversionException {
if (value.getClass().getName().equals(INTERNET_ADDRESS_CLASSNAME)) {
return value;
} else if (value instanceof String) {
try {
final Constructor<?> ctor = Class.forName(INTERNET_ADDRESS_CLASSNAME).getConstructor(String.class);
return ctor.newInstance(value);
} catch (final Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"", e);
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"");
}
}",0,False
private final String protocol;,0,False
"public float getFloat(String key, float defaultValue) {
return getFloat(key, new Float(defaultValue));
}",0,False
"public double getDouble(String key, double defaultValue) {
return getDouble(key, new Double(defaultValue));
}",0,False
"public void load(InputStream in, String encoding) throws ConfigurationException {
Reader reader = null;
if (encoding != null) {
try {
reader = new InputStreamReader(in, encoding);
} catch (UnsupportedEncodingException e) {
throw new ConfigurationException(""The requested encoding is not supported, try the default encoding."", e);
}
}
if (reader == null) {
reader = new InputStreamReader(in);
}
load(reader);
}",0,False
"@Override
protected Object performOperation() throws SQLException {
PreparedStatement pstmt = initStatement(String.format(SQL_GET_PROPERTY, table, keyColumn), true, key);
ResultSet rs = pstmt.executeQuery();
return rs.next();
}",0,False
"@Override
protected Object performOperation() throws SQLException {
PreparedStatement ps = initStatement(String.format(SQL_IS_EMPTY, table), true);
ResultSet rs = ps.executeQuery();
return rs.next() ? rs.getInt(1) : null;
}",0,False
"public Object createBean(Class<?> beanClass, BeanDeclaration data, Object param) throws Exception {
ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
String tagName = decl.getNode().getName();
ConfigurationProvider provider = decl.getConfigurationBuilder().providerForTag(tagName);
if (provider == null) {
throw new ConfigurationRuntimeException(""No ConfigurationProvider registered for tag "" + tagName);
}
try {
return provider.getConfiguration(decl);
} catch (Exception ex) {
if (!decl.isOptional()) {
throw ex;
} else {
if (logger.isDebugEnabled()) {
logger.debug(""Load failed for optional configuration "" + tagName + "": "" + ex.getMessage());
}
decl.getConfigurationBuilder().fireError(EVENT_ERR_LOAD_OPTIONAL, decl.getConfiguration().getString(ATTR_NAME), null, ex);
if (decl.isForceCreate()) {
try {
return provider.getEmptyConfiguration(decl);
} catch (Exception ex2) {
;
}
}
return null;
}
}
}",0,False
"public void save(Writer out) throws ConfigurationException {
PrintWriter writer = new PrintWriter(out);
String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
writer.println(""<?xml version=\""1.0\"" encoding=\"""" + encoding + ""\""?>"");
writer.println(""<!DOCTYPE properties SYSTEM \""http://java.sun.com/dtd/properties.dtd\"">"");
writer.println(""<properties>"");
if (getHeader() != null) {
writer.println(""  <comment>"" + StringEscapeUtils.escapeXml(getHeader()) + ""</comment>"");
}
Iterator<String> keys = getKeys();
while (keys.hasNext()) {
String key = keys.next();
Object value = getProperty(key);
if (value instanceof List) {
writeProperty(writer, key, (List) value);
} else {
writeProperty(writer, key, value);
}
}
writer.println(""</properties>"");
writer.flush();
}",0,False
"public T getRootNode() {
if (getSubnodeKey() != null) {
try {
NodeList<T> nodes = getParent().fetchNodeList(getSubnodeKey());
if (nodes.size() != 1 || !nodes.isNode(0)) {
setSubnodeKey(null);
} else {
T currentRoot = nodes.getNode(0);
if (currentRoot != rootNode) {
fireEvent(EVENT_SUBNODE_CHANGED, null, null, true);
rootNode = currentRoot;
fireEvent(EVENT_SUBNODE_CHANGED, null, null, false);
}
return currentRoot;
}
} catch (Exception ex) {
setSubnodeKey(null);
}
}
return rootNode;
}",0,False
"@SuppressWarnings(""unchecked"")
@Override
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) {
T node1 = ((ConfigurationNodePointer<T>) pointer1).getConfigurationNode();
T node2 = ((ConfigurationNodePointer<T>) pointer2).getConfigurationNode();
for (T child : getNodeHandler().getChildren(getConfigurationNode())) {
if (child == node1) {
return -1;
} else if (child == node2) {
return 1;
}
}
return 0;
}",0,False
"@SuppressWarnings(""unchecked"")
@Override
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) {
return new ConfigurationNodeIteratorChildren<T>(this, test, reverse, (ConfigurationNodePointer<T>) startWith);
}",0,False
"private void createPath(File file) {
if (file != null) {
if (!file.exists()) {
File parent = file.getParentFile();
if (parent != null && !parent.exists()) {
parent.mkdirs();
}
}
}
}",0,False
"protected void UpdateLineColumn(char c) {
column++;
if (prevCharIsLF) {
prevCharIsLF = false;
line += (column = 1);
} else if (prevCharIsCR) {
prevCharIsCR = false;
if (c == '\n') {
prevCharIsLF = true;
} else
line += (column = 1);
}
switch(c) {
case '\r':
prevCharIsCR = true;
break;
case '\n':
prevCharIsLF = true;
break;
case '\t':
column--;
column += (tabSize - (column % tabSize));
break;
default:
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}",0,False
"public char[] GetSuffix(int len) {
char[] ret = new char[len];
if ((bufpos + 1) >= len)
System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
else {
System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
}
return ret;
}",0,False
"public static synchronized byte[] decodeBase64(String base64String) {
instance.put(null, base64String);
return instance.getByteArray(null, null);
}",0,False
"protected byte[] filterData(String s) throws ParseException {
if (s == null) {
return null;
}
if (s.startsWith(""<"") && s.endsWith("">"") && s.length() >= 2) {
s = s.substring(1, s.length() - 1);
}
s = StringUtils.replaceChars(s, "" \t\n\r"", """");
if (s.length() % 2 != 0) {
s = ""0"" + s;
}
try {
return Hex.decodeHex(s.toCharArray());
} catch (Exception e) {
throw (ParseException) new ParseException(""Unable to parse the byte[] : "" + e.getMessage());
}
}",0,False
"final public String String() throws ParseException {
Token token = null;
String value = null;
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
{
if (true)
return unescapeQuotes(removeQuotes(token.image));
}
break;
case STRING:
token = jj_consume_token(STRING);
{
if (true)
return token.image;
}
break;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
throw new Error(""Missing return statement in function"");
}",0,False
"final public PropertyListConfiguration Dictionary() throws ParseException {
PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
ConfigurationNode child = null;
jj_consume_token(DICT_BEGIN);
label_1: while (true) {
switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof AbstractHierarchicalConfiguration) {
AbstractHierarchicalConfiguration conf = (AbstractHierarchicalConfiguration) child.getValue();
ConfigurationNode root = (ConfigurationNode) conf.getRootNode();
root.setName(child.getName());
children.add(root);
} else {
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++) {
child = (ConfigurationNode) children.get(i);
configuration.getRootNode().addChild(child);
}
{
if (true)
return configuration;
}
throw new Error(""Missing return statement in function"");
}",0,False
"public void ReInit(SimpleCharStream stream) {
jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}",0,False
"private int jjMoveNfa_0(int startState, int curPos) {
int startsAt = 0;
jjnewStateCnt = 14;
int i = 1;
jjstateSet[0] = startState;
int kind = 0x7fffffff;
for (; ; ) {
if (++jjround == 0x7fffffff) {
ReInitRounds();
}
if (curChar < 64) {
long l = 1L << curChar;
do {
switch(jjstateSet[--i]) {
case 15:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x7ff280100000000L & l) != 0L) {
jjCheckNAddTwoStates(4, 5);
} else if (curChar == 62) {
if (kind > 20) {
kind = 20;
}
}
break;
case 6:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x3ff000100002600L & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
} else if (curChar == 42) {
jjstateSet[jjnewStateCnt++] = 3;
} else if (curChar == 62) {
if (kind > 19) {
kind = 19;
}
}
break;
case 14:
if ((0xfffffffbffffffffL & l) != 0L) {
jjCheckNAddStates(0, 2);
} else if (curChar == 34) {
if (kind > 22) {
kind = 22;
}
}
break;
case 3:
case 8:
if ((0xd7ffecfaffffd9ffL & l) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 0:
if ((0xd7ffecfaffffd9ffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
} else if (curChar == 34) {
jjCheckNAddStates(0, 2);
}
if (curChar == 60) {
jjstateSet[jjnewStateCnt++] = 6;
}
if (curChar == 60) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 1:
if ((0x3ff000100002600L & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 2:
if (curChar == 62 && kind > 19) {
kind = 19;
}
break;
case 4:
if ((0x7ff280100000000L & l) != 0L) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 5:
if (curChar == 62 && kind > 20) {
kind = 20;
}
break;
case 7:
if (curChar == 60) {
jjstateSet[jjnewStateCnt++] = 6;
}
break;
case 9:
case 11:
if (curChar == 34) {
jjCheckNAddStates(0, 2);
}
break;
case 10:
if ((0xfffffffbffffffffL & l) != 0L) {
jjCheckNAddStates(0, 2);
}
break;
case 13:
if (curChar == 34 && kind > 22) {
kind = 22;
}
break;
default:
break;
}
} while (i != startsAt);
} else if (curChar < 128) {
long l = 1L << (curChar & 077);
do {
switch(jjstateSet[--i]) {
case 15:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if (curChar == 90) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 6:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if ((0x7e0000007eL & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 14:
jjCheckNAddStates(0, 2);
if (curChar == 92) {
jjstateSet[jjnewStateCnt++] = 11;
}
break;
case 3:
if ((0xd7ffffffffffffffL & l) != 0L) {
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
}
if (curChar == 68) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 0:
case 8:
if ((0xd7ffffffffffffffL & l) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 1:
if ((0x7e0000007eL & l) != 0L) {
jjCheckNAddTwoStates(1, 2);
}
break;
case 4:
if (curChar == 90) {
jjCheckNAddTwoStates(4, 5);
}
break;
case 10:
jjCheckNAddStates(0, 2);
break;
case 12:
if (curChar == 92) {
jjstateSet[jjnewStateCnt++] = 11;
}
break;
default:
break;
}
} while (i != startsAt);
} else {
int i2 = (curChar & 0xff) >> 6;
long l2 = 1L << (curChar & 077);
do {
switch(jjstateSet[--i]) {
case 15:
case 8:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 6:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 14:
case 10:
if ((jjbitVec0[i2] & l2) != 0L) {
jjCheckNAddStates(0, 2);
}
break;
case 3:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
case 0:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 21) {
kind = 21;
}
jjCheckNAdd(8);
break;
default:
break;
}
} while (i != startsAt);
}
if (kind != 0x7fffffff) {
jjmatchedKind = kind;
jjmatchedPos = curPos;
kind = 0x7fffffff;
}
++curPos;
if ((i = jjnewStateCnt) == (startsAt = 14 - (jjnewStateCnt = startsAt))) {
return curPos;
}
try {
curChar = input_stream.readChar();
} catch (java.io.IOException e) {
return curPos;
}
}
}",0,False
"public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length) {
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}",0,False
"protected void ExpandBuff(boolean wrapAround) {
char[] newbuffer = new char[bufsize + 2048];
int[] newbufline = new int[bufsize + 2048];
int[] newbufcolumn = new int[bufsize + 2048];
try {
if (wrapAround) {
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
} else {
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
} catch (Throwable t) {
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}",0,False
public int endColumn;,0,False
"public void load(Reader in) throws ConfigurationException {
if (!(getRootNode() instanceof PListNode)) {
initRoot();
}
EntityResolver resolver = new EntityResolver() {
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler(getRootNode());
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"public static Synchronizer cloneSynchronizer(Synchronizer sync) {
if (sync == null) {
throw new IllegalArgumentException(""Synchronizer must not be null!"");
}
if (NoOpSynchronizer.INSTANCE == sync) {
return sync;
}
try {
return sync.getClass().newInstance();
} catch (Exception ex) {
LOG.info(""Cannot create new instance of "" + sync.getClass());
}
try {
return (Synchronizer) clone(sync);
} catch (CloneNotSupportedException cnex) {
throw new ConfigurationRuntimeException(""Cannot clone Synchronizer "" + sync);
}
}",0,False
"@Override
public void read(InputStream in) throws ConfigurationException, IOException {
load(new InputSource(in));
}",0,False
private final ImmutableConfiguration configuration;,0,False
"public static Double toDouble(Object value) throws ConversionException {
Number n = toNumber(value, Double.class);
if (n instanceof Double) {
return (Double) n;
} else {
return new Double(n.doubleValue());
}
}",0,False
"static Object toInternetAddress(Object value) throws ConversionException {
if (value.getClass().getName().equals(INTERNET_ADDRESS_CLASSNAME)) {
return value;
} else if (value instanceof String) {
try {
Constructor<?> ctor = Class.forName(INTERNET_ADDRESS_CLASSNAME).getConstructor(String.class);
return ctor.newInstance(value);
} catch (Exception e) {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"", e);
}
} else {
throw new ConversionException(""The value "" + value + "" can't be converted to a InternetAddress"");
}
}",0,False
private final String protocol;,0,False
"@Override
public void loadSystemCatalogs() throws IOException {
fs = ((CatalogManager) catalogManager).getFileSystem();
String base = ((CatalogManager) catalogManager).getBaseDir();
@SuppressWarnings(""unchecked"")
Vector<String> catalogs = catalogManager.getCatalogFiles();
if (catalogs != null) {
for (int count = 0; count < catalogs.size(); count++) {
String fileName = catalogs.elementAt(count);
URL url = null;
InputStream is = null;
try {
url = locate(fs, base, fileName);
if (url != null) {
is = fs.getInputStream(url);
}
} catch (ConfigurationException ce) {
String name = url.toString();
catalogManager.debug.message(DEBUG_ALL, ""Unable to get input stream for "" + name + "". "" + ce.getMessage());
}
if (is != null) {
String mimeType = fileNameMap.getContentTypeFor(fileName);
try {
if (mimeType != null) {
parseCatalog(mimeType, is);
continue;
}
} catch (Exception ex) {
catalogManager.debug.message(DEBUG_ALL, ""Exception caught parsing input stream for "" + fileName + "". "" + ex.getMessage());
} finally {
is.close();
}
}
parseCatalog(base, fileName);
}
}
}",0,False
"@Override
public org.apache.xml.resolver.Catalog getPrivateCatalog() {
org.apache.xml.resolver.Catalog catalog = staticCatalog;
if (catalog == null || !getUseStaticCatalog()) {
try {
catalog = new Catalog();
catalog.setCatalogManager(this);
catalog.setupReaders();
catalog.loadSystemCatalogs();
} catch (Exception ex) {
ex.printStackTrace();
}
if (getUseStaticCatalog()) {
staticCatalog = catalog;
}
}
return catalog;
}",0,False
"@Override
@SuppressWarnings(""unchecked"")
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) {
if (bean instanceof NodeWrapper) {
NodeWrapper<?> wrapper = (NodeWrapper<?>) bean;
return new ConfigurationNodePointer((ConfigurationNodePointer) parent, wrapper.getNode(), wrapper.getNodeHandler());
}
return null;
}",0,False
"@Override
public void visitBeforeChildren(ImmutableNode node, NodeHandler<ImmutableNode> handler) {
ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
updateNode(node, refHandler);
insertNewChildNodes(node, refHandler);
}",0,False
"private void insertNewChildNodes(ImmutableNode node, ReferenceNodeHandler refHandler) {
Collection<ImmutableNode> subNodes = new LinkedList<>(refHandler.getChildren(node));
Iterator<ImmutableNode> children = subNodes.iterator();
ImmutableNode sibling1;
ImmutableNode nd = null;
while (children.hasNext()) {
do {
sibling1 = nd;
nd = children.next();
} while (refHandler.getReference(nd) != null && children.hasNext());
if (refHandler.getReference(nd) == null) {
List<ImmutableNode> newNodes = new LinkedList<>();
newNodes.add(nd);
while (children.hasNext()) {
nd = children.next();
if (refHandler.getReference(nd) == null) {
newNodes.add(nd);
} else {
break;
}
}
ImmutableNode sibling2 = (refHandler.getReference(nd) == null) ? null : nd;
for (ImmutableNode insertNode : newNodes) {
if (refHandler.getReference(insertNode) == null) {
insert(insertNode, node, sibling1, sibling2, refHandler);
sibling1 = insertNode;
}
}
}
}
}",0,False
"public static void dump(ImmutableConfiguration configuration, PrintStream out) {
dump(configuration, new PrintWriter(out));
}",0,False
"public DataSource getDataSource() {
return dataSource;
}",0,False
"public void save(Document document, Node parent) {
Element properties = document.createElement(""properties"");
parent.appendChild(properties);
if (getHeader() != null) {
Element comment = document.createElement(""comment"");
properties.appendChild(comment);
comment.setTextContent(StringEscapeUtils.escapeXml(getHeader()));
}
Iterator<String> keys = getKeys();
while (keys.hasNext()) {
String key = keys.next();
Object value = getProperty(key);
if (value instanceof List) {
writeProperty(document, properties, key, (List<?>) value);
} else {
writeProperty(document, properties, key, value);
}
}
}",0,False
"private ConfigurationBuilderEvent createEventWithChangedSource(ConfigurationBuilderEvent event) {
if (ConfigurationBuilderResultCreatedEvent.RESULT_CREATED.equals(event.getEventType())) {
return new ConfigurationBuilderResultCreatedEvent(this, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED, ((ConfigurationBuilderResultCreatedEvent) event).getConfiguration());
}
@SuppressWarnings(""unchecked"")
EventType<? extends ConfigurationBuilderEvent> type = (EventType<? extends ConfigurationBuilderEvent>) event.getEventType();
return new ConfigurationBuilderEvent(this, type);
}",0,False
"@Override
public void read(Reader in) throws ConfigurationException {
EntityResolver resolver = new EntityResolver() {
@Override
public InputSource resolveEntity(String publicId, String systemId) {
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
}
};
XMLPropertyListHandler handler = new XMLPropertyListHandler();
try {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser parser = factory.newSAXParser();
parser.getXMLReader().setEntityResolver(resolver);
parser.getXMLReader().setContentHandler(handler);
parser.getXMLReader().parse(new InputSource(in));
getNodeModel().mergeRoot(handler.getResultBuilder().createNode(), null, null, null, this);
} catch (Exception e) {
throw new ConfigurationException(""Unable to parse the configuration file"", e);
}
}",0,False
"@Override
public org.apache.xml.resolver.Catalog getPrivateCatalog() {
org.apache.xml.resolver.Catalog catalog = staticCatalog;
if (catalog == null || !getUseStaticCatalog()) {
try {
catalog = new Catalog();
catalog.setCatalogManager(this);
catalog.setupReaders();
catalog.loadSystemCatalogs();
} catch (Exception ex) {
ex.printStackTrace();
}
if (getUseStaticCatalog()) {
staticCatalog = catalog;
}
}
return catalog;
}",0,False
private final QueryResult<T> attributeResult;,0,False
"@Override
@SuppressWarnings(""unchecked"")
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) {
if (bean instanceof NodeWrapper) {
NodeWrapper<?> wrapper = (NodeWrapper<?>) bean;
return new ConfigurationNodePointer((ConfigurationNodePointer) parent, wrapper.getNode(), wrapper.getNodeHandler());
}
return null;
}",0,False
"@Override
public String getUsername() {
return this.userName;
}",0,True
"@Override
public byte[] getBytes(final String columnName) throws SQLException {
try {
return resultSet.getBytes(columnName);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
"@Override
public long executeLargeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
"@Override
public long executeLargeUpdate(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
"@Override
public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
"@Override
public long[] executeLargeBatch() throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeBatch();
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
"@Override
public long executeLargeUpdate(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
"protected void initializeConnection(final Connection conn) throws SQLException {
final Collection<String> sqls = connectionInitSqls;
if (conn.isClosed()) {
throw new SQLException(""initializeConnection: connection closed"");
}
if (null != sqls) {
try (Statement stmt = conn.createStatement()) {
for (final String sql : sqls) {
Objects.requireNonNull(sql, ""null connectionInitSqls element"");
stmt.execute(sql);
}
}
}
}",0,True
"public static void closeQuietly(final AutoCloseable autoCloseable) {
if (autoCloseable != null) {
try {
autoCloseable.close();
} catch (final Exception e) {
}
}
}",0,True
"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
"@Override
protected void finalize() throws Throwable {
try {
connection.close();
} catch (final Exception ignored) {
}
if (logicalConnection != null && !logicalConnection.isClosed()) {
throw new SQLException(""PooledConnection was gc'ed, without its last Connection being closed."");
}
}",0,True
"@Override
public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
try {
validateLifetime(pooledObject);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pconn = pooledObject.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pconn);
if (null == validationQuery) {
int timeoutSeconds = validationQueryTimeoutSeconds;
if (timeoutSeconds < 0) {
timeoutSeconds = 0;
}
try {
conn = pconn.getConnection();
valid = conn.isValid(timeoutSeconds);
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pconn);
try {
conn = pconn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly(rset);
Utils.closeQuietly(stmt);
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
}
return valid;
}",0,False
"@Override
public String getUsername() {
return this.userName;
}",0,True
"@Override
public synchronized String getUrl() {
return this.connectionString;
}",0,False
"@Override
public byte[] getBytes(final int parameterIndex) throws SQLException {
checkOpen();
try {
return getDelegateCallableStatement().getBytes(parameterIndex);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
"@Override
public byte[] getBytes(final int columnIndex) throws SQLException {
try {
return resultSet.getBytes(columnIndex);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
"@Override
public synchronized void close() throws SQLException {
if (isClosedInternal()) {
return;
}
boolean isUnderlyingConnectionClosed;
try {
isUnderlyingConnectionClosed = getDelegateInternal().isClosed();
} catch (final SQLException e) {
try {
pool.invalidateObject(this);
} catch (final IllegalStateException ise) {
passivate();
getInnermostDelegate().close();
} catch (final Exception ignored) {
}
throw new SQLException(""Cannot close connection (isClosed check failed)"", e);
}
if (isUnderlyingConnectionClosed) {
// Abnormal close: underlying connection closed unexpectedly, so we
try {
pool.invalidateObject(this);
} catch (final IllegalStateException e) {
passivate();
getInnermostDelegate().close();
} catch (final Exception e) {
throw new SQLException(""Cannot close connection (invalidating pooled object failed)"", e);
}
} else {
// Normal close: underlying connection is still open, so we
try {
pool.returnObject(this);
} catch (final IllegalStateException e) {
passivate();
getInnermostDelegate().close();
} catch (final SQLException | RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Cannot close connection (return to pool failed)"", e);
}
}
}",0,False
"@Deprecated
public void validate(final String sql, final int timeoutSeconds) throws SQLException {
validate(sql, Duration.ofSeconds(timeoutSeconds));
}",0,False
"public void validateConnection(final PoolableConnection conn) throws SQLException {
if (conn.isClosed()) {
throw new SQLException(""validateConnection: connection closed"");
}
conn.validate(validationQuery, validationQueryTimeoutDuration);
}",0,False
"@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
"@Override
public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
try {
validateLifetime(pooledObject);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pooledConn = pooledObject.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pooledConn);
if (null == validationQuery) {
Duration timeoutDuration = validationQueryTimeoutDuration;
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
try {
conn = pooledConn.getConnection();
valid = conn.isValid((int) timeoutDuration.getSeconds());
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pooledConn);
try {
conn = pooledConn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) rset);
Utils.closeQuietly((AutoCloseable) stmt);
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
}
return valid;
}",0,False
"@Override
public synchronized void end(final Xid xid, final int flag) throws XAException {
Objects.requireNonNull(xid, ""xid"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
}",0,False
"public char[] getUserPassword() {
return userPassword;
}",1,True
"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue());
}",0,False
"private void validatePropertyNames(final Reference ref, final Name name, final List<String> warnings, final List<String> infoMessages) {
final List<String> allPropsAsList = Arrays.asList(ALL_PROPERTIES);
final String nameString = name != null ? ""Name = "" + name.toString() + "" "" : """";
if (NUPROP_WARNTEXT != null && !NUPROP_WARNTEXT.isEmpty()) {
for (final String propertyName : NUPROP_WARNTEXT.keySet()) {
final RefAddr ra = ref.get(propertyName);
if (ra != null && !allPropsAsList.contains(ra.getType())) {
final StringBuilder stringBuilder = new StringBuilder(nameString);
final String propertyValue = ra.getContent().toString();
stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append("" You have set value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property, which is being ignored."");
warnings.add(stringBuilder.toString());
}
}
}
final Enumeration<RefAddr> allRefAddrs = ref.getAll();
while (allRefAddrs.hasMoreElements()) {
final RefAddr ra = allRefAddrs.nextElement();
final String propertyName = ra.getType();
if (!(allPropsAsList.contains(propertyName) || NUPROP_WARNTEXT.containsKey(propertyName) || SILENT_PROPERTIES.contains(propertyName))) {
final String propertyValue = ra.getContent().toString();
final StringBuilder stringBuilder = new StringBuilder(nameString);
stringBuilder.append(""Ignoring unknown property: "").append(""value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property"");
infoMessages.add(stringBuilder.toString());
}
}
}",0,True
"@Override
public int executeUpdate(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
"public synchronized void setPool(final ObjectPool<PoolableConnection> pool) {
if (null != this.pool && pool != this.pool) {
try {
this.pool.close();
} catch (final Exception e) {
}
}
this.pool = pool;
}",0,False
"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnNames)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
"@Override
public void close() throws SQLException {
if (isClosed()) {
return;
}
final List<Exception> thrownList = new ArrayList<>();
try {
if (connection != null) {
connection.removeTrace(this);
connection = null;
}
final List<AbandonedTrace> resultSetList = getTrace();
if (resultSetList != null) {
final int size = resultSetList.size();
final ResultSet[] resultSets = resultSetList.toArray(Utils.EMPTY_RESULT_SET_ARRAY);
for (final ResultSet resultSet : resultSets) {
if (resultSet != null) {
try {
resultSet.close();
} catch (final Exception e) {
if (connection != null) {
connection.handleExceptionNoThrow(e);
}
thrownList.add(e);
}
}
}
clearTrace();
}
if (statement != null) {
try {
statement.close();
} catch (final Exception e) {
if (connection != null) {
connection.handleExceptionNoThrow(e);
}
thrownList.add(e);
}
}
} finally {
closed = true;
statement = null;
if (!thrownList.isEmpty()) {
throw new SQLExceptionList(thrownList);
}
}
}",1,False
"private void closeConnectionPool() {
final GenericObjectPool<?> oldPool = connectionPool;
connectionPool = null;
try {
if (oldPool != null) {
oldPool.close();
}
} catch (final Exception e) {
}
}",1,False
"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[] { bodyText };
if (paramTypes.length == 0) {
paramTypes = new Class[] { String.class };
}
} else {
parameters = new Object[0];
paramTypes = new Class<?>[0];
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0,False
"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0,False
"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0,False
"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className' ar 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0,False
"// TODO: Consider making following four constants static in 2.0
public final String DFLT_PLUGIN_CLASS_ATTR_NS = null;",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"public Object[] peekParams() {
try {
return (params.peek());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0,False
"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0,False
"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0,False
"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0,False
"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
protected static String versionNumber = null;,0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"@Override
public String toString() {
Formatter formatter = new Formatter().format(""CallMethodRule[methodName=%s, paramCount=%s, paramTypes={"", this.methodName, this.paramTypes.length);
if (this.paramTypes != null) {
for (int i = 0; i < this.paramTypes.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(this.paramTypes[i].getName());
}
}
return formatter.format(""}]"").toString();
}",0,False
"public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
if (saxLog.isDebugEnabled()) {
saxLog.debug(""resolveEntity('"" + publicId + ""', '"" + systemId + ""')"");
}
if (publicId != null)
this.publicId = publicId;
String entityURL = null;
if (publicId != null) {
entityURL = (String) entityValidator.get(publicId);
}
if (schemaLocation != null && entityURL == null && systemId != null) {
entityURL = (String) entityValidator.get(systemId);
}
if (entityURL == null) {
if (systemId == null) {
if (log.isDebugEnabled()) {
log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
}
return (null);
} else {
if (log.isDebugEnabled()) {
log.debug("" Trying to resolve using system ID '"" + systemId + ""'"");
}
entityURL = systemId;
}
}
if (log.isDebugEnabled()) {
log.debug("" Resolving to alternate DTD '"" + entityURL + ""'"");
}
try {
return createInputSourceFromURL(entityURL);
} catch (Exception e) {
throw createSAXException(e);
}
}",0,False
private String currChildNamespaceURI = null;,0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0,False
protected static String versionNumber = null;,0,False
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0,False
"@Override
public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0,False
"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"@Override
public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0,False
private final int cacheSize = 255;,0,False
"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0,False
"public static Annotation[] getAnnotationsArrayValue(Annotation annotation) {
Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0,False
"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0,False
"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0,False
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"@Override
public String toString() {
Formatter formatter = new Formatter().format(""CallMethodRule[methodName=%s, paramCount=%s, paramTypes={"", this.methodName, this.paramTypes.length);
if (this.paramTypes != null) {
for (int i = 0; i < this.paramTypes.length; i++) {
if (i > 0) {
formatter.format("", "");
}
formatter.format(this.paramTypes[i].getName());
}
}
return formatter.format(""}]"").toString();
}",0,False
"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0,False
protected String namespaceURI = null;,0,False
private String currChildNamespaceURI = null;,0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
private FromXmlRuleSet ruleSet;,0,False
"public void end() throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = (Object[]) digester.popParams();
if (digester.log.isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
digester.log.trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
;
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = digester.peek(targetOffset);
} else {
target = digester.peek(digester.getCount() + targetOffset);
}
if (target == null) {
StringBuffer sb = new StringBuffer();
sb.append(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(digester.getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (digester.log.isDebugEnabled()) {
StringBuffer sb = new StringBuffer(""[CallMethodRule]{"");
sb.append(digester.match);
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
digester.log.debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0,False
private String currChildNamespaceURI = null;,0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
@Override
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
@Override
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
@Override
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0,False
"public static Annotation[] getAnnotationsArrayValue(final Annotation annotation) {
final Object value = getAnnotationValue(annotation);
if (value != null && value.getClass().isArray() && Annotation.class.isAssignableFrom(value.getClass().getComponentType())) {
return (Annotation[]) value;
}
return null;
}",0,False
"protected LinkedRuleBuilder forPattern(final String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0,False
"public Date getUpdated() {
return updated;
}",0,False
"public void setUpdated(final Date updated) {
this.updated = updated;
}",0,False
"public void setUpdated(final Date updated) {
this.updated = updated;
}",0,False
"private void execute() throws IOException {
final FileReader inRaw = new FileReader(source);
final FileWriter out = new FileWriter(dest);
final BufferedReader in = new BufferedReader(inRaw);
while (true) {
final String inStr = in.readLine();
if (inStr == null) {
break;
}
final String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0,False
"public void print() {
System.out.println(""Person #"" + id);
System.out.println(""  category="" + category);
System.out.println(""  name="" + name);
for (final String type : emails.keySet()) {
final String address = emails.get(type);
System.out.println(""  email (type "" + type + "") : "" + address);
}
for (final Address addr : addresses) {
addr.print(System.out, 2);
}
}",0,False
"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0,False
"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0,False
"public void setUpdated(Date updated) {
this.updated = updated;
}",0,False
"private static java.io.Reader getInputData(String filename) throws java.io.IOException {
java.io.File srcfile = new java.io.File(filename);
java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(1000);
byte[] buf = new byte[100];
java.io.FileInputStream fis = new java.io.FileInputStream(srcfile);
for (; ; ) {
int nread = fis.read(buf);
if (nread == -1) {
break;
}
baos.write(buf, 0, nread);
}
fis.close();
return new java.io.StringReader(baos.toString());
}",0,False
"public String transform(String s) {
if (toLower) {
return s.toLowerCase();
}
return s.toUpperCase();
}",0,False
"private void execute() throws IOException {
FileReader inRaw = new FileReader(source);
FileWriter out = new FileWriter(dest);
BufferedReader in = new BufferedReader(inRaw);
while (true) {
String inStr = in.readLine();
if (inStr == null)
break;
String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0,False
"private void execute() throws IOException {
FileReader inRaw = new FileReader(source);
FileWriter out = new FileWriter(dest);
BufferedReader in = new BufferedReader(inRaw);
while (true) {
String inStr = in.readLine();
if (inStr == null)
break;
String outStr = transformer.transform(inStr);
out.write(outStr);
out.write('\n');
}
inRaw.close();
out.close();
System.out.println(""Contents of file "" + source + "" have been transformed, and"" + "" written to file "" + dest + ""."");
}",0,False
"public String transform(String s) {
StringBuilder buf = new StringBuilder(s);
while (true) {
int idx = buf.indexOf(from);
if (idx == -1) {
break;
}
buf.replace(idx, idx + from.length(), to);
}
return buf.toString();
}",0,False
"public void render(OutputStream stream, String encoding) throws UnsupportedEncodingException {
PrintWriter pw = null;
if (encoding == null) {
pw = new PrintWriter(stream);
} else {
pw = new PrintWriter(new OutputStreamWriter(stream, encoding));
}
render(pw, encoding);
pw.flush();
}",0,False
protected static String versionNumber = null;,0,False
"private static String getXercesVersion() {
String versionNumber = ""1.0"";
try {
Class versionClass = Class.forName(""org.apache.xerces.impl.Version"");
Method method = versionClass.getMethod(""getVersion"", (Class[]) null);
String version = (String) method.invoke(null, (Object[]) null);
versionNumber = version.substring(""Xerces-J"".length(), version.lastIndexOf("".""));
} catch (Exception ex) {
}
return versionNumber;
}",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(""[CallMethodRule]("" + i + "")"" + parameters[i]);
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
StringBuilder sb = new StringBuilder();
sb.append(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call target is null ("");
sb.append(""targetOffset="");
sb.append(targetOffset);
sb.append("",stackdepth="");
sb.append(getDigester().getCount());
sb.append("")"");
throw new org.xml.sax.SAXException(sb.toString());
}
if (getDigester().getLogger().isDebugEnabled()) {
StringBuilder sb = new StringBuilder(""[CallMethodRule]{"");
sb.append(getDigester().getMatch());
sb.append(""} Call "");
sb.append(target.getClass().getName());
sb.append(""."");
sb.append(methodName);
sb.append(""("");
for (int i = 0; i < paramValues.length; i++) {
if (i > 0) {
sb.append("","");
}
if (paramValues[i] == null) {
sb.append(""null"");
} else {
sb.append(paramValues[i].toString());
}
sb.append(""/"");
if (paramTypes[i] == null) {
sb.append(""null"");
} else {
sb.append(paramTypes[i].getName());
}
}
sb.append("")"");
getDigester().getLogger().debug(sb.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0,False
private String currChildNamespaceURI = null;,0,False
"public MethodArgument(int index, Class<?> parameterType, Annotation[] annotations) {
this.index = index;
this.parameterType = parameterType;
this.annotations = annotations;
}",0,False
"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0,False
"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0,False
"protected LinkedRuleBuilder forPattern(String pattern) {
return memoryRulesBinder.forPattern(pattern);
}",0,False
"@Override
public void end(String namespace, String name) throws Exception {
Object[] parameters = null;
if (paramCount > 0) {
parameters = getDigester().popParams();
if (getDigester().getLogger().isTraceEnabled()) {
for (int i = 0, size = parameters.length; i < size; i++) {
getDigester().getLogger().trace(format(""[CallMethodRule]{%s} parameters[%s]=%s"", getDigester().getMatch(), i, parameters[i]));
}
}
if (paramCount == 1 && parameters[0] == null) {
return;
}
} else if (paramTypes != null && paramTypes.length != 0) {
if (bodyText == null) {
return;
}
parameters = new Object[1];
parameters[0] = bodyText;
if (paramTypes.length == 0) {
paramTypes = new Class[1];
paramTypes[0] = String.class;
}
} else {
}
Object[] paramValues = new Object[paramTypes.length];
for (int i = 0; i < paramTypes.length; i++) {
if (parameters[i] == null || (parameters[i] instanceof String && !String.class.isAssignableFrom(paramTypes[i]))) {
paramValues[i] = ConvertUtils.convert((String) parameters[i], paramTypes[i]);
} else {
paramValues[i] = parameters[i];
}
}
Object target;
if (targetOffset >= 0) {
target = getDigester().peek(targetOffset);
} else {
target = getDigester().peek(getDigester().getCount() + targetOffset);
}
if (target == null) {
throw new SAXException(format(""[CallMethodRule]{%s} Call target is null (targetOffset=%s, stackdepth=%s)"", getDigester().getMatch(), targetOffset, getDigester().getCount()));
}
if (getDigester().getLogger().isDebugEnabled()) {
Formatter formatter = new Formatter().format(""[CallMethodRule]{%s} Call %s.%s("", getDigester().getMatch(), target.getClass().getName(), methodName);
for (int i = 0; i < paramValues.length; i++) {
formatter.format(""%s%s/%s"", (i > 0 ? "", "" : """"), paramValues[i], paramTypes[i].getName());
}
formatter.format("")"");
getDigester().getLogger().debug(formatter.toString());
}
Object result = null;
if (useExactMatch) {
result = MethodUtils.invokeExactMethod(target, methodName, paramValues, paramTypes);
} else {
result = MethodUtils.invokeMethod(target, methodName, paramValues, paramTypes);
}
processMethodCallResult(result);
}",0,False
"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0,False
private String currChildNamespaceURI = null;,0,False
"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0,False
"@SuppressWarnings(""unchecked"")
private <A extends Annotation, E extends AnnotatedElement, R extends Rule> void handle(A annotation, E element) {
Class<?> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(DigesterRuleList.class)) {
Annotation[] annotations = getAnnotationsArrayValue(annotation);
if (annotations != null && annotations.length > 0) {
for (Annotation ptr : annotations) {
handle(ptr, element);
}
}
} else if (annotationType.isAnnotationPresent(DigesterRule.class)) {
DigesterRule digesterRule = annotationType.getAnnotation(DigesterRule.class);
Class<? extends AnnotationHandler<Annotation, AnnotatedElement>> handlerType = (Class<? extends AnnotationHandler<Annotation, AnnotatedElement>>) digesterRule.handledBy();
try {
AnnotationHandler<Annotation, AnnotatedElement> handler = annotationHandlerFactory.newInstance(handlerType);
handler.handle(annotation, element, this.rulesBinder);
} catch (Exception e) {
rulesBinder.addError(e);
}
}
}",0,False
"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0,False
"@Override
protected FactoryCreateRule createRule() {
if (type == null && attributeName == null && creationFactory == null) {
reportError(""factoryCreate()"", ""at least one between 'className', 'attributeName' or 'creationFactory' has to be specified"");
}
if (type != null || attributeName != null) {
return new FactoryCreateRule(type, attributeName, ignoreCreateExceptions);
}
return new FactoryCreateRule(creationFactory, ignoreCreateExceptions);
}",0,False
"public SAXParser getParser() {
if (parser != null) {
return (parser);
}
try {
if (validating && (schemaLocation != null)) {
Properties properties = new Properties();
properties.put(""SAXParserFactory"", getFactory());
if (schemaLocation != null) {
properties.put(""schemaLocation"", schemaLocation);
properties.put(""schemaLanguage"", schemaLanguage);
}
parser = ParserFeatureSetterFactory.newSAXParser(properties);
} else {
parser = getFactory().newSAXParser();
}
} catch (Exception e) {
log.error(""Digester.getParser: "", e);
return (null);
}
return (parser);
}",0,False
private String currChildNamespaceURI = null;,0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
private FromXmlRuleSet ruleSet;,0,False
"public Object[] popParams() {
try {
if (log.isTraceEnabled()) {
log.trace(""Popping params"");
}
return (params.pop());
} catch (EmptyStackException e) {
log.warn(""Empty stack (returning null)"");
return (null);
}
}",0,False
"protected final void bindRulesFrom(final Class<?> type) {
if (type == null || type.getPackage().getName().startsWith(JAVA_PACKAGE) || rulesBinder.isAlreadyBound(type)) {
return;
}
visitElements(type);
if (!type.isInterface()) {
visitElements(new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return type.getDeclaredConstructors();
}
});
visitElements(new PrivilegedAction<Field[]>() {
public Field[] run() {
return type.getDeclaredFields();
}
});
}
visitElements(new PrivilegedAction<Method[]>() {
public Method[] run() {
return type.getDeclaredMethods();
}
});
rulesBinder.markAsBound(type);
bindRulesFrom(type.getSuperclass());
}",0,False
"@Override
public void begin(String namespace, String name, Attributes attributes) throws Exception {
String fileName = attributes.getValue(""url"");
if (fileName != null && fileName.length() > 0) {
final URL xmlRulesResource;
if (fileName.startsWith(CLASSPATH_URL_PREFIX)) {
String path = fileName.substring(CLASSPATH_URL_PREFIX.length());
if ('/' == path.charAt(0)) {
path = path.substring(1);
}
xmlRulesResource = this.targetRulesBinder.getContextClassLoader().getResource(path);
if (xmlRulesResource == null) {
targetRulesBinder.addError(""Resource '%s' not found, please make sure it is in the classpath"", path);
return;
}
} else {
try {
xmlRulesResource = new URL(fileName);
} catch (MalformedURLException e) {
targetRulesBinder.addError(""An error occurred while inculing file from '%s': %s"", fileName, e.getMessage());
return;
}
}
if (memoryRulesBinder.getIncludedFiles().add(xmlRulesResource.toString())) {
install(new FromXmlRulesModule() {
@Override
protected void loadRules() {
loadXMLRules(xmlRulesResource);
}
});
} else {
targetRulesBinder.addError(""Circular file inclusion detected for XML rules: %s"", xmlRulesResource);
}
}
String className = attributes.getValue(""class"");
if (className != null && className.length() > 0) {
try {
Class<?> cls = Class.forName(className);
if (!RulesModule.class.isAssignableFrom(cls)) {
targetRulesBinder.addError(""Class '%s' if not a '%s' implementation"", className, RulesModule.class.getName());
return;
}
RulesModule rulesSource = (RulesModule) cls.newInstance();
install(rulesSource);
} catch (Exception e) {
targetRulesBinder.addError(""Impossible to include programmatic rules from class '%s': %s"", className, e.getMessage());
}
}
}",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",1,False
private String namespaceURI;,1,False
"Object createProxy() {
Object[] constructorArguments = new Object[templateConstructorArguments.length];
arraycopy(templateConstructorArguments, 0, constructorArguments, 0, constructorArguments.length);
digester.pushParams(constructorArguments);
DeferredConstructionCallback callback = new DeferredConstructionCallback(constructor, constructorArguments);
Object result;
if (factory == null) {
synchronized (this) {
// check again for null now that we're in the synchronized block:
if (factory == null) {
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(clazz);
enhancer.setCallback(callback);
enhancer.setClassLoader(digester.getClassLoader());
enhancer.setInterceptDuringConstruction(false);
if (hasDefaultConstructor) {
result = enhancer.create();
} else {
result = enhancer.create(constructor.getParameterTypes(), constructorArguments);
}
factory = (Factory) result;
return result;
}
}
}
if (hasDefaultConstructor) {
result = factory.newInstance(callback);
} else {
result = factory.newInstance(constructor.getParameterTypes(), constructorArguments, new Callback[] { callback });
}
return result;
}",1,False
private FromXmlRuleSet ruleSet;,1,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",1,False
"public static String DFLT_FILENAME_ATTR = ""file"";",1,False
private Object[] defaultConstructorArguments;,0,False
"public static String DFLT_FALSEVAL = ""false"";",1,False
"private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
throw new ParseException(""Invalid RFC 2047 encoded-word: "" + word);
}
int charsetPos = word.indexOf('?', 2);
if (charsetPos == -1) {
throw new ParseException(""Missing charset in RFC 2047 encoded-word: "" + word);
}
String charset = word.substring(2, charsetPos).toLowerCase();
int encodingPos = word.indexOf('?', charsetPos + 1);
if (encodingPos == -1) {
throw new ParseException(""Missing encoding in RFC 2047 encoded-word: "" + word);
}
String encoding = word.substring(charsetPos + 1, encodingPos);
int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
if (encodedTextPos == -1) {
throw new ParseException(""Missing encoded text in RFC 2047 encoded-word: "" + word);
}
String encodedText = word.substring(encodingPos + 1, encodedTextPos);
if (encodedText.length() == 0) {
return """";
}
try {
ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
byte[] encodedData = encodedText.getBytes(US_ASCII_CHARSET);
if (encoding.equals(BASE64_ENCODING_MARKER)) {
Base64Decoder.decode(encodedData, out);
} else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
QuotedPrintableDecoder.decode(encodedData, out);
} else {
throw new UnsupportedEncodingException(""Unknown RFC 2047 encoding: "" + encoding);
}
byte[] decodedData = out.toByteArray();
return new String(decodedData, javaCharset(charset));
} catch (IOException e) {
throw new UnsupportedEncodingException(""Invalid RFC 2047 encoding"");
}
}",1,False
protected int lineCount = 0;,1,True
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
private File dfosFile;,1,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
private boolean opened;,1,False
"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",1,False
"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (final UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",1,True
"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",1,False
"protected Map parseHeaders(String headerPart) {
Map headers = new HashMap();
char[] buffer = new char[MAX_HEADER_SIZE];
boolean done = false;
int j = 0;
int i;
String header, headerName, headerValue;
try {
while (!done) {
i = 0;
while (i < 2 || buffer[i - 2] != '\r' || buffer[i - 1] != '\n') {
buffer[i++] = headerPart.charAt(j++);
}
header = new String(buffer, 0, i - 2);
if (header.equals("""")) {
done = true;
} else {
if (header.indexOf(':') == -1) {
continue;
}
headerName = header.substring(0, header.indexOf(':')).trim().toLowerCase();
headerValue = header.substring(header.indexOf(':') + 1).trim();
if (getHeader(headers, headerName) != null) {
headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
} else {
headers.put(headerName, headerValue);
}
}
}
} catch (IndexOutOfBoundsException e) {
}
return headers;
}",0,False
"public byte[] getBoundary(final String contentType) {
final ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
final Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
final String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (final UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,True
"@Deprecated
protected final String getHeader(Map<String, String> headers, String name) {
return headers.get(name.toLowerCase());
}",1,False
"@Override
public String getString() {
byte[] rawdata = new byte[0];
try {
rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = defaultCharset;
}
return new String(rawdata, charset);
} catch (final IOException e) {
return new String(rawdata);
}
}",0,False
"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0,False
"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0,False
"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,False
"@Deprecated
public MultipartStream() {
this(null, null, null);
}",0,False
"public Map<String, String> parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0,False
"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0,False
"@Override
@Deprecated
public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0,False
"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0,False
"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,False
"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0,False
"public Map<String, String> parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap<String, String>();
}
HashMap<String, String> params = new HashMap<String, String>();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0,False
"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0,False
"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0,False
"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0,False
"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List<String> headerValueList = headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return headerValueList.get(0);
}",0,False
"protected String getFileName(Map headers) {
String fileName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null) {
String cdl = cd.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0,False
private boolean opened;,0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"public void close() throws IOException {
if (closed) {
return;
}
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
closed = true;
}",0,False
"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public void close() throws IOException {
if (closed) {
return;
}
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
closed = true;
}",0,False
"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0,False
"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0,False
"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,False
"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(""Header section has more than "" + HEADER_PART_SIZE_MAX + "" bytes (maybe it is not properly terminated)"");
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0,False
"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0,False
"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public Iterator getHeaders(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return Collections.EMPTY_LIST.iterator();
}
return headerValueList.iterator();
}",0,False
"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0,False
"protected FileItemHeaders getParsedHeaders(String headerPart) {
final int len = headerPart.length();
FileItemHeadersImpl headers = newFileItemHeaders();
int start = 0;
for (; ; ) {
int end = parseEndOfLine(headerPart, start);
if (start == end) {
break;
}
String header = headerPart.substring(start, end);
start = end + 2;
while (start < len) {
int nonWs = start;
while (nonWs < len) {
char c = headerPart.charAt(nonWs);
if (c != ' ' && c != '\t') {
break;
}
++nonWs;
}
if (nonWs == start) {
break;
}
end = parseEndOfLine(headerPart, nonWs);
header += "" "" + headerPart.substring(nonWs, end);
start = end + 2;
}
parseHeaderLine(headers, header);
}
return headers;
}",0,False
private boolean opened;,0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"public String readHeaders() throws MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(""Header section has more than "" + HEADER_PART_SIZE_MAX + "" bytes (maybe it is not properly terminated)"");
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0,False
"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0,False
"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}",0,False
"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0,False
"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0,False
"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0,False
"public static String asString(InputStream pStream) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
copy(pStream, baos, true);
return baos.toString();
}",0,False
"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0,False
"public static final boolean isMultipartContent(RequestContext ctx) {
String contentType = ctx.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0,False
"private boolean findNextItem() throws IOException {
if (eof) {
return false;
}
if (currentItem != null) {
currentItem.close();
currentItem = null;
}
for (; ; ) {
boolean nextPart;
if (skipPreamble) {
nextPart = multi.skipPreamble();
} else {
nextPart = multi.readBoundary();
}
if (!nextPart) {
if (currentFieldName == null) {
eof = true;
return false;
}
multi.setBoundary(boundary);
currentFieldName = null;
continue;
}
FileItemHeaders headers = getParsedHeaders(multi.readHeaders());
if (currentFieldName == null) {
String fieldName = getFieldName(headers);
if (fieldName != null) {
String subContentType = headers.getHeader(CONTENT_TYPE);
if (subContentType != null && subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
currentFieldName = fieldName;
byte[] subBoundary = getBoundary(subContentType);
multi.setBoundary(subBoundary);
skipPreamble = true;
continue;
}
String fileName = getFileName(headers);
currentItem = new FileItemStreamImpl(fileName, fieldName, headers.getHeader(CONTENT_TYPE), fileName == null, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
} else {
String fileName = getFileName(headers);
if (fileName != null) {
currentItem = new FileItemStreamImpl(fileName, currentFieldName, headers.getHeader(CONTENT_TYPE), false, getContentLength(headers));
notifier.noteItem();
itemValid = true;
return true;
}
}
multi.discardBodyData();
}
}",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0,False
"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public synchronized void addHeader(String name, String value) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
headerValueList = new ArrayList();
headerNameToValueListMap.put(nameLower, headerValueList);
headerNameList.add(nameLower);
}
headerValueList.add(value);
}",0,False
"public Iterator getHeaders(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return Collections.EMPTY_LIST.iterator();
}
return headerValueList.iterator();
}",0,False
"public List parseRequest(RequestContext ctx) throws FileUploadException {
try {
FileItemIterator iter = getItemIterator(ctx);
List items = new ArrayList();
FileItemFactory fac = getFileItemFactory();
if (fac == null) {
throw new NullPointerException(""No FileItemFactory has been set."");
}
while (iter.hasNext()) {
FileItemStream item = iter.next();
FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), item.getName());
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(""Processing of "" + MULTIPART_FORM_DATA + "" request failed. "" + e.getMessage(), e);
}
if (fileItem instanceof FileItemHeadersSupport) {
final FileItemHeaders fih = item.getHeaders();
((FileItemHeadersSupport) fileItem).setHeaders(fih);
}
items.add(fileItem);
}
return items;
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
}
}",0,False
"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = (String) params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0,False
"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0,False
"public void setFileItemFactory(FileItemFactory factory) {
this.fileItemFactory = (DefaultFileItemFactory) factory;
}",0,False
"protected Map parseHeaders(String headerPart) {
FileItemHeaders headers = getParsedHeaders(headerPart);
Map result = new HashMap();
for (Iterator iter = headers.getHeaderNames(); iter.hasNext(); ) {
String headerName = (String) iter.next();
Iterator iter2 = headers.getHeaders(headerName);
String headerValue = (String) iter2.next();
while (iter2.hasNext()) {
headerValue += "","" + iter2.next();
}
result.put(headerName, headerValue);
}
return result;
}",0,False
"private String getFileName(String pContentDisposition) {
String fileName = null;
if (pContentDisposition != null) {
String cdl = pContentDisposition.toLowerCase();
if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(pContentDisposition, ';');
if (params.containsKey(""filename"")) {
fileName = (String) params.get(""filename"");
if (fileName != null) {
fileName = fileName.trim();
} else {
fileName = """";
}
}
}
}
return fileName;
}",0,False
"protected final String getHeader(Map headers, String name) {
return (String) headers.get(name.toLowerCase());
}",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"public Map parse(final char[] chars, int offset, int length, char separator) {
if (chars == null) {
return new HashMap();
}
HashMap params = new HashMap();
this.chars = chars;
this.pos = offset;
this.len = length;
String paramName = null;
String paramValue = null;
while (hasChar()) {
paramName = parseToken(new char[] { '=', separator });
paramValue = null;
if (hasChar() && (chars[pos] == '=')) {
pos++;
paramValue = parseQuotedToken(new char[] { separator });
}
if (hasChar() && (chars[pos] == separator)) {
pos++;
}
if ((paramName != null) && (paramName.length() > 0)) {
if (this.lowerCaseNames) {
paramName = paramName.toLowerCase();
}
params.put(paramName, paramValue);
}
}
return params;
}",0,False
"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public String getHeader(String name) {
String nameLower = name.toLowerCase();
List headerValueList = (List) headerNameToValueListMap.get(nameLower);
if (null == headerValueList) {
return null;
}
return (String) headerValueList.get(0);
}",0,False
private boolean opened;,0,False
"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0,False
"protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
List<FileItem> items = new ArrayList<FileItem>();
boolean successful = false;
try {
FileItemIterator iter = getItemIterator(ctx);
FileItemFactory fileItemFactory = Objects.requireNonNull(getFileItemFactory(), ""No FileItemFactory has been set."");
final byte[] buffer = new byte[Streams.DEFAULT_BUFFER_SIZE];
while (iter.hasNext()) {
final FileItemStream item = iter.next();
final String fileName = ((FileItemStreamImpl) item).getName();
FileItem fileItem = fileItemFactory.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);
items.add(fileItem);
try {
Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
} catch (IOException e) {
throw new IOFileUploadException(format(""Processing of %s request failed. %s"", MULTIPART_FORM_DATA, e.getMessage()), e);
}
final FileItemHeaders fih = item.getHeaders();
fileItem.setHeaders(fih);
}
successful = true;
return items;
} catch (FileUploadException e) {
throw e;
} catch (IOException e) {
throw new FileUploadException(e.getMessage(), e);
} finally {
if (!successful) {
for (FileItem fileItem : items) {
try {
fileItem.delete();
} catch (Exception ignored) {
}
}
}
}
}",0,False
"public byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"public String readHeaders() throws FileUploadIOException, MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (FileUploadIOException e) {
throw e;
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", Integer.valueOf(HEADER_PART_SIZE_MAX)));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0,False
"@Override
public byte[] get() {
if (isInMemory()) {
if (cachedContent == null && dfos != null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
IOUtils.readFully(fis, fileData);
} catch (IOException e) {
fileData = null;
} finally {
IOUtils.closeQuietly(fis);
}
return fileData;
}",0,True
"protected String getFieldName(Map headers) {
String fieldName = null;
String cd = getHeader(headers, CONTENT_DISPOSITION);
if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(cd, ';');
fieldName = (String) params.get(""name"");
if (fieldName != null) {
fieldName = fieldName.trim();
}
}
return fieldName;
}",0,False
"public void close() throws IOException {
if (closed) {
return;
}
for (; ; ) {
int av = available();
if (av == 0) {
av = makeAvailable();
if (av == 0) {
break;
}
}
skip(av);
}
closed = true;
}",0,False
"public static final boolean isMultipartContent(HttpServletRequest request) {
if (!""post"".equals(request.getMethod().toLowerCase())) {
return false;
}
String contentType = request.getContentType();
if (contentType == null) {
return false;
}
if (contentType.toLowerCase().startsWith(MULTIPART)) {
return true;
}
return false;
}",0,False
"public boolean hasNext() throws FileUploadException, IOException {
if (eof) {
return false;
}
if (itemValid) {
return true;
}
try {
return findNextItem();
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0,False
"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,False
"public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}",0,False
"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0,False
"public String readHeaders() throws FileUploadIOException, MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (FileUploadIOException e) {
throw e;
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", Integer.valueOf(HEADER_PART_SIZE_MAX)));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"@Override
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}",0,False
"public boolean hasNext() throws FileUploadException, IOException {
if (eof) {
return false;
}
if (itemValid) {
return true;
}
try {
return findNextItem();
} catch (FileUploadIOException e) {
throw (FileUploadException) e.getCause();
}
}",0,False
"protected byte[] getBoundary(String contentType) {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
String boundaryStr = params.get(""boundary"");
if (boundaryStr == null) {
return null;
}
byte[] boundary;
try {
boundary = boundaryStr.getBytes(""ISO-8859-1"");
} catch (UnsupportedEncodingException e) {
boundary = boundaryStr.getBytes();
}
return boundary;
}",0,False
private boolean opened;,0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
InputStream fis = null;
try {
fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}",0,False
"public String readHeaders() throws FileUploadIOException, MalformedStreamException {
int i = 0;
byte b;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
int size = 0;
while (i < HEADER_SEPARATOR.length) {
try {
b = readByte();
} catch (FileUploadIOException e) {
throw e;
} catch (IOException e) {
throw new MalformedStreamException(""Stream ended unexpectedly"");
}
if (++size > HEADER_PART_SIZE_MAX) {
throw new MalformedStreamException(format(""Header section has more than %s bytes (maybe it is not properly terminated)"", Integer.valueOf(HEADER_PART_SIZE_MAX)));
}
if (b == HEADER_SEPARATOR[i]) {
i++;
} else {
i = 0;
}
baos.write(b);
}
String headers = null;
if (headerEncoding != null) {
try {
headers = baos.toString(headerEncoding);
} catch (UnsupportedEncodingException e) {
headers = baos.toString();
}
} else {
headers = baos.toString();
}
return headers;
}",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0,False
"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0,False
"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0,True
"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0,True
"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0,True
private File outputDirectory;,0,False
"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0,False
"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0,False
"private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}",0,False
"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0,False
"protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0,False
private boolean excludeTransitive;,0,False
"public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0,False
"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0,False
protected boolean outputAbsoluteArtifactFilename;,0,False
"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
protected File outputFile;,0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
"protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.getLocal());
return resolveDependencyArtifacts(pomProject);
}",0,False
"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0,False
"protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}",0,False
"public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}",0,False
"private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0,False
"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0,False
"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0,False
"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
protected List reactorProjects;,0,False
private List remotePluginRepositories;,0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0,False
"protected void doExecute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
// don't allow them to have absolute paths when they attach.
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
// make the string valid for filtering
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
project.getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
} else if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0,False
"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0,False
"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0,False
"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0,False
"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0,False
"@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0,False
"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0,False
"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0,False
"private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}",0,False
"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0,False
"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
"public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}",0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}",0,False
"public void execute() throws MojoExecutionException {
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(File.pathSeparatorChar);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (cpFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString);
} else {
this.getLog().info(""Skipped writting classpath file '"" + cpFile + ""'.  No changes found."");
}
}
}",0,False
"private void storeClasspathFile(String cpString) throws MojoExecutionException {
try {
Writer w = new BufferedWriter(new FileWriter(cpFile));
try {
w.write(cpString);
getLog().info(""Written classpath file '"" + cpFile + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + cpFile + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + cpFile + ""': "" + ex.toString(), ex);
}
}",0,False
private String prefix;,0,False
"private String readClasspathFile() throws IOException {
if (!cpFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(cpFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}",0,False
"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0,False
"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0,False
private boolean regenerateFile;,0,False
"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0,False
"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}",0,False
"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0,False
"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0,False
"@Override
protected void doExecute() throws MojoExecutionException {
results = this.getDependencySets(false, includeParents);
String output = getOutput(outputAbsoluteArtifactFilename, outputScope, sort);
try {
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
} catch (IOException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0,False
"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0,False
"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
protected boolean outputAbsoluteArtifactFilename;,0,False
private String groupId;,0,False
private boolean excludeTransitive;,0,False
private boolean excludeTransitive;,0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0,False
"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0,False
"public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}",0,False
"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0,False
"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0,False
protected MavenProject project;,0,False
"protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
protected List<MavenProject> reactorProjects;,0,False
"public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
Reader reader = null;
try {
reader = ReaderFactory.newXmlReader(project.getFile());
model = pomReader.read(reader);
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
} finally {
IOUtil.close(reader);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}",0,True
"public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}",0,False
"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0,False
boolean outputFilterFile;,0,False
boolean attach;,0,False
"private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}",0,False
"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0,False
private boolean excludeTransitive;,0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public Set<Artifact> translate(Set<Artifact> artifacts, Log log) {
Set<Artifact> results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet<Artifact>();
for (Artifact artifact : artifacts) {
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0,True
private File markersDirectory;,0,False
private boolean excludeTransitive;,0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}",0,False
"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}",0,False
"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0,False
"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0,False
"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0,False
"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}",0,False
"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0,False
"private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
protected MavenProject project;,0,False
protected boolean outputAbsoluteArtifactFilename;,0,False
"protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}",0,False
protected File outputFile;,0,False
private ProjectDependencyAnalyzer analyzer;,0,False
"public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}",0,False
"public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}",0,False
"private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0,False
"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0,False
"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}",0,False
"protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0,False
"@Parameter(defaultValue = ""${reactorProjects}"", readonly = true, required = true)
protected List<MavenProject> reactorProjects;",0,True
"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0,False
"public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}",0,False
"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0,False
"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0,False
"public FileMapper[] getFileMappers() {
return this.fileMappers;
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0,False
protected List reactorProjects;,0,False
"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
public boolean silent;,0,False
protected MavenProject project;,0,False
"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
"private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}",0,False
"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0,False
"protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter "" + ""cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
try (BufferedReader r = new BufferedReader(new FileReader(outputFile))) {
for (String line = r.readLine(); line != null; line = r.readLine()) {
sb.append(line);
}
return sb.toString();
}
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"private StringBuilder buildArtifactListOutput(Set<Artifact> artifacts, boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
List<String> artifactStringList = new ArrayList<>();
for (Artifact artifact : artifacts) {
MessageBuilder messageBuilder = MessageUtils.buffer();
messageBuilder.a(""   "");
if (theOutputScope) {
messageBuilder.a(artifact.toString());
} else {
messageBuilder.a(artifact.getId());
}
if (outputAbsoluteArtifactFilename) {
try {
String artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
messageBuilder.a(':').a(artifactFilename);
} catch (NullPointerException e) {
}
}
if (theOutputScope && artifact.isOptional()) {
messageBuilder.a("" (optional)"");
}
if (artifact.getFile() != null) {
ModuleDescriptor moduleDescriptor = getModuleDescriptor(artifact.getFile());
if (moduleDescriptor != null) {
messageBuilder.project("" -- module "" + moduleDescriptor.name);
if (moduleDescriptor.automatic) {
if (""MANIFEST"".equals(moduleDescriptor.moduleNameSource)) {
messageBuilder.strong("" [auto]"");
} else {
messageBuilder.warning("" (auto)"");
}
}
}
}
artifactStringList.add(messageBuilder.toString() + System.lineSeparator());
}
if (theSort) {
Collections.sort(artifactStringList);
}
for (String artifactString : artifactStringList) {
sb.append(artifactString);
}
return sb;
}",0,False
"@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
DependencyUtil.write(output, outputFile, appendOutput, getLog());
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}",0,False
"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0,False
"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0,False
"protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}",0,False
"@Parameter
protected boolean ignorePermissions;",0,False
"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0,False
"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Parameter
protected boolean ignorePermissions;",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"public AbstractDependencyMojo() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
}",0,False
protected boolean overWriteSnapshots;,0,False
private boolean excludeTransitive;,0,False
private List remotePluginRepositories;,0,False
"public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}",0,False
"public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",0,False
"protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers, boolean overwrite) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.setOverwrite(overwrite);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}",0,False
"private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0,False
"public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}",0,False
"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0,False
"public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}",0,False
"@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}",1,False
"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
if (!manager.getScope().equals(node.getDependency().getScope())) {
artifactProperties.put(PRE_MANAGED_SCOPE, node.getDependency().getScope());
artifactProperties.put(MANAGED_SCOPE, manager.getScope());
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
node.getDependency().setArtifact(node.getDependency().getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0,False
"public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}",0,False
"private void fillMissingArtifactVersion(ArtifactItem artifact) throws MojoExecutionException {
if (!findDependencyVersion(artifact, project.getDependencies(), false) && (project.getDependencyManagement() == null || !findDependencyVersion(artifact, project.getDependencyManagement().getDependencies(), false)) && !findDependencyVersion(artifact, project.getDependencies(), true) && (project.getDependencyManagement() == null || !findDependencyVersion(artifact, project.getDependencyManagement().getDependencies(), true))) {
throw new MojoExecutionException(""Unable to find artifact version of "" + artifact.getGroupId() + "":"" + artifact.getArtifactId() + "" in either dependency list or in project's dependency management."");
}
}",0,False
"protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}",0,False
"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getPluginArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0,False
"protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
if (this.localRepositoryDirectory != null) {
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(super.getLocal().getId(), ""file://"" + this.localRepositoryDirectory.getAbsolutePath(), super.getLocal().getLayout(), super.getLocal().getSnapshots(), super.getLocal().getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
return this.overrideLocalRepository;
}
this.overrideLocalRepository = super.getLocal();
return this.overrideLocalRepository;
}",0,False
private List remotePluginRepositories;,1,False
"protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}",0,False
private MavenProject project;,0,False
"public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}",0,False
"protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}",0,False
"public void execute() throws MojoExecutionException {
try {
ArtifactResolutionResult result = this.artifactCollector.collect(project.getArtifacts(), project.getArtifact(), this.getLocal(), this.remoteRepos, this.artifactMetadataSource, new ScopeArtifactFilter(Artifact.SCOPE_TEST), new ArrayList());
HashSet repos = new HashSet();
for (Iterator<ResolutionNode> i = result.getArtifactResolutionNodes().iterator(); i.hasNext(); ) {
ResolutionNode node = i.next();
repos.addAll(node.getRemoteRepositories());
}
this.getLog().info(""Repositories Used by this build:"");
for (Iterator i = repos.iterator(); i.hasNext(); ) {
this.getLog().info(i.next().toString());
}
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Unable to resolve artifacts"", e);
}
}",0,False
"private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
if (!manager.getScope().equals(node.getDependency().getScope())) {
artifactProperties.put(PRE_MANAGED_SCOPE, node.getDependency().getScope());
artifactProperties.put(MANAGED_SCOPE, manager.getScope());
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
node.getDependency().setArtifact(node.getDependency().getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}",0,False
"public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
writer.close();
writer = null;
} finally {
IOUtil.close(writer);
}
}",0,False
"private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
w.close();
w = null;
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}",0,False
private boolean excludeTransitive;,1,False
"private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}",0,False
"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0,False
"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0,False
"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0,False
"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0,False
"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0,False
"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0,False
"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
"public int[] startSubnegotiationLocal() {
return null;
}",0,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0,False
private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
"public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, method.getAuthName()))) {
return false;
}
switch(method) {
case PLAIN:
{
int result = sendData(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case CRAM_MD5:
{
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
int result = sendData(new String(Base64.encodeBase64(toEncode)));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case LOGIN:
{
if (sendData(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT) {
return false;
}
int result = sendData(new String(Base64.encodeBase64(password.getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
}
return false;
}",0,False
"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0,False
"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
"public boolean login(String username, String timestamp, String secret) throws IOException, NoSuchAlgorithmException {
int i;
byte[] digest;
StringBuilder buffer, digestBuffer;
MessageDigest md5;
if (getState() != AUTHORIZATION_STATE) {
return false;
}
md5 = MessageDigest.getInstance(""MD5"");
timestamp += secret;
digest = md5.digest(timestamp.getBytes());
digestBuffer = new StringBuilder(128);
for (i = 0; i < digest.length; i++) {
int digit = digest[i] & 0xff;
if (digit <= 15) {
digestBuffer.append(""0"");
}
digestBuffer.append(Integer.toHexString(digit));
}
buffer = new StringBuilder(256);
buffer.append(username);
buffer.append(' ');
buffer.append(digestBuffer.toString());
if (sendCommand(POP3Command.APOP, buffer.toString()) != POP3Reply.OK) {
return false;
}
setState(TRANSACTION_STATE);
return true;
}",0,False
"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0,False
"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0,False
"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0,False
"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0,False
"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0,False
"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0,False
"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
"public int[] startSubnegotiationRemote() {
return null;
}",0,False
"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0,False
"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0,False
"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0,False
"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0,False
"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
"public IOException getIOException() {
return (IOException) getCause();
}",0,False
"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0,False
"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0,False
"public static boolean enableEndpointNameVerification(SSLSocket socket) {
try {
Class<?> cls = Class.forName(""javax.net.ssl.SSLParameters"");
Method setEndpointIdentificationAlgorithm = cls.getDeclaredMethod(""setEndpointIdentificationAlgorithm"", String.class);
Method getSSLParameters = SSLSocket.class.getDeclaredMethod(""getSSLParameters"");
Method setSSLParameters = SSLSocket.class.getDeclaredMethod(""setSSLParameters"", cls);
if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
Object sslParams = getSSLParameters.invoke(socket);
if (sslParams != null) {
setEndpointIdentificationAlgorithm.invoke(sslParams, ""HTTPS"");
setSSLParameters.invoke(socket, sslParams);
return true;
}
}
} catch (SecurityException e) {
} catch (ClassNotFoundException e) {
} catch (NoSuchMethodException e) {
} catch (IllegalArgumentException e) {
} catch (IllegalAccessException e) {
} catch (InvocationTargetException e) {
}
return false;
}",0,False
"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0,False
"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
"public IOException getIOException() {
return (IOException) getCause();
}",0,False
"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0,False
"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0,False
"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0,False
"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
"public int[] startSubnegotiationLocal() {
return null;
}",0,False
"public int[] startSubnegotiationRemote() {
return null;
}",0,False
"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0,False
"public String getTime() throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader reader;
reader = new BufferedReader(new InputStreamReader(_input_));
while (true) {
read = reader.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
return result.toString();
}",0,False
"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0,False
"public int execMIC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_MIC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_MIC, """");
}
}",0,False
"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = _socket_.getInetAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (!isClientMode) {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
}",0,False
"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
}",0,False
"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
}",0,False
"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0,False
"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0,False
"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0,False
"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0,False
"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0,False
"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0,False
"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0,False
"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0,False
"@Deprecated
public static String STORE_TYPE;",0,False
"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0,False
"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0,False
"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0,False
"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0,False
"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0,False
"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0,False
"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _fileName.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_fileName.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0,False
"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0,False
"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0,False
"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0,False
"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0,False
"public IOException getIOException() {
return (IOException) getCause();
}",0,False
"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0,False
"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0,False
"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0,False
"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0,False
"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0,False
"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0,False
"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0,False
"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0,False
"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0,False
"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0,False
"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
"public int[] startSubnegotiationLocal() {
return null;
}",0,False
"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0,False
private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
"public String getTime() throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader reader;
reader = new BufferedReader(new InputStreamReader(_input_));
while (true) {
read = reader.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
return result.toString();
}",0,False
"public String getTime(InetAddress host, int port) throws IOException {
DatagramPacket sendPacket, receivePacket;
sendPacket = new DatagramPacket(__dummyData, __dummyData.length, host, port);
receivePacket = new DatagramPacket(__timeData, __timeData.length);
_socket_.send(sendPacket);
_socket_.receive(receivePacket);
return new String(receivePacket.getData(), 0, receivePacket.getLength());
}",0,False
"public int execADAT(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ADAT, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ADAT);
}
}",0,False
"public int execMIC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_MIC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_MIC, """");
}
}",0,False
"public int execCONF(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_CONF, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_CONF, """");
}
}",0,False
"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0,False
"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
"public boolean auth(AuthenticatingSMTPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!SMTPReply.isPositiveIntermediate(sendCommand(SMTPCommand.AUTH, AUTH_METHOD.getAuthName(method)))) {
return false;
}
if (method.equals(AUTH_METHOD.PLAIN)) {
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))));
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(4).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(toEncode))));
} else if (method.equals(AUTH_METHOD.LOGIN)) {
if (!SMTPReply.isPositiveIntermediate(sendCommand(new String(Base64.encodeBase64(username.getBytes()))))) {
return false;
}
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(password.getBytes()))));
} else {
return false;
}
}",0,False
"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
"public void run() {
int ch;
__threaded = true;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0,False
"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
"public FTPHTTPClient(String proxyHost, int proxyPort, String proxyUser, String proxyPass) {
this.proxyHost = proxyHost;
this.proxyPort = proxyPort;
this.proxyUsername = proxyUser;
this.proxyPassword = proxyPass;
try {
CRLF = ""\r\n"".getBytes(getControlEncoding());
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",1,False
"public String toDateString() {
DateFormat formatter = null;
if (simpleFormatter != null) {
formatter = simpleFormatter.get();
}
if (formatter == null) {
formatter = new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);
formatter.setTimeZone(TimeZone.getDefault());
simpleFormatter = new SoftReference<DateFormat>(formatter);
}
Date ntpDate = getDate();
synchronized (formatter) {
return formatter.format(ntpDate);
}
}",1,False
public final String identifier;,0,False
"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
}",0,False
private final Charset charset;,1,False
public int size;,0,False
"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",1,False
"public static void main(String[] args) throws Exception {
if (args.length == 0) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
}
CodeSource codeSource = Main.class.getProtectionDomain().getCodeSource();
Map<String, String> map = new HashMap<String, String>();
if (codeSource != null) {
final String sourceFile = codeSource.getLocation().getFile();
if (sourceFile.endsWith("".jar"")) {
if (args.length == 0) {
System.out.println(""\nClasses found in the jar:"");
}
JarFile jf = new JarFile(sourceFile);
Enumeration<JarEntry> e = jf.entries();
while (e.hasMoreElements()) {
JarEntry je = e.nextElement();
String name = je.getName();
if (!name.endsWith("".class"") || name.contains(""$"") || name.equals(""examples/nntp/NNTPUtils.class"") || name.equals(""examples/util/IOUtil.class"") || name.equals(""examples/mail/IMAPUtils.class"") || name.equals(""examples/Main.class"")) {
continue;
}
name = name.replace("".class"", """");
int lastSep = name.lastIndexOf('/');
String alias = name.substring(lastSep + 1);
if (args.length == 0) {
System.out.printf(""%-25s %s%n"", alias, name);
}
map.put(alias, name);
}
jf.close();
}
}
if (args.length == 0) {
return;
}
String shortName = args[0];
String fullName = map.get(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
m.invoke(null, (Object) args2);
}",1,False
"public static void main(String[] args) throws Throwable {
CodeSource codeSource = Main.class.getProtectionDomain().getCodeSource();
Map<String, String> map = new HashMap<String, String>();
final boolean noArgsProvided = args.length == 0;
if (codeSource != null) {
final String sourceFile = codeSource.getLocation().getFile();
if (sourceFile.endsWith("".jar"")) {
if (noArgsProvided) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
System.out.println(""\nClasses found in the jar:"");
}
JarFile jf = new JarFile(sourceFile);
Enumeration<JarEntry> e = jf.entries();
while (e.hasMoreElements()) {
JarEntry je = e.nextElement();
String name = je.getName();
processFileName(name, map, noArgsProvided);
}
jf.close();
} else {
if (noArgsProvided) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<exampleClass>,<exampleClass parameters>"");
System.out.println(""\nClasses found in the jar:"");
}
File examples = new File(sourceFile, ""examples"");
if (examples.exists()) {
scanForClasses(sourceFile.length(), examples, map, noArgsProvided);
}
}
} else {
if (noArgsProvided) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
}
}
if (noArgsProvided) {
return;
}
String shortName = args[0];
String fullName = map.get(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0,False
"public byte[] parseADATReply(String reply) {
if (reply == null)
return null;
else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0,False
"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1,True
"public boolean status(String mailboxName, String[] itemNames) throws IOException {
String statusNames = """";
if (itemNames != null) {
statusNames += "" ("";
for (int i = 0; i < itemNames.length; i++) {
statusNames += itemNames[i];
if (i < itemNames.length - 1)
statusNames += "" "";
}
statusNames += "")"";
}
return doCommand(IMAPCommand.STATUS, statusNames);
}",1,False
"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",1,False
"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1,True
"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"@Override
public void passivateObject(final T obj) throws Exception {
writeLock.tryLock();
try {
factory.passivateObject(obj);
} finally {
writeLock.unlock();
}
}",0,False
"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void returnObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0,False
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,0,True
"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0,False
"@Override
public void addObject() throws Exception, IllegalStateException, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.addObject();
} finally {
writeLock.unlock();
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
private int initIdleCapacity;,0,True
"@Override
public void evict() throws Exception {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"@Override
@Deprecated
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
}
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}",0,False
private int initIdleCapacity;,0,True
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
private int maxSleeping;,0,True
"public void evict() throws Exception {
assertOpen();
if (_idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (_evictionIterator == null || !_evictionIterator.hasNext()) {
if (getLifo()) {
_evictionIterator = _idleObjects.descendingIterator();
} else {
_evictionIterator = _idleObjects.iterator();
}
}
if (!_evictionIterator.hasNext()) {
return;
} else {
try {
underTest = _evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
_evictionIterator = null;
continue;
}
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (getMinEvictableIdleTimeMillis() > 0 && getMinEvictableIdleTimeMillis() < underTest.getIdleTimeMillis() || (getSoftMinEvictableIdleTimeMillis() > 0 && getSoftMinEvictableIdleTimeMillis() < underTest.getIdleTimeMillis() && getMinIdle() < _idleObjects.size())) {
destroy(underTest);
} else {
if (getTestWhileIdle()) {
boolean active = false;
try {
_factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
}
if (active) {
if (!_factory.validateObject(underTest.getObject())) {
destroy(underTest);
} else {
try {
_factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
}
}
}
}
if (!underTest.endEvictionTest()) {
}
}
}
return;
}",0,False
"public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0,False
"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0,False
"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTime(), getSoftMinEvictableIdleTime(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0,False
private int initIdleCapacity;,0,True
"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0,False
"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
boolean create;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
return p.getObject();
}",0,False
"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void invalidateObject(final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0,False
"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTime = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
} else {
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0,False
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0,False
"@Override
public boolean validateObject(final K key, final V obj) {
writeLock.tryLock();
try {
return keyedFactory.validateObject(key, obj);
} finally {
writeLock.unlock();
}
}",0,True
"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0,False
"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p.getObject());
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0,False
"public void invalidateObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void evict() throws Exception {
assertOpen();
if (idleObjects.size() == 0) {
return;
}
PooledObject<T> underTest = null;
boolean testWhileIdle = getTestWhileIdle();
long idleEvictTime = Long.MAX_VALUE;
long idleSoftEvictTime = Long.MAX_VALUE;
if (getMinEvictableIdleTimeMillis() > 0) {
idleEvictTime = getMinEvictableIdleTimeMillis();
}
if (getSoftMinEvictableIdleTimeMillis() > 0) {
idleSoftEvictTime = getSoftMinEvictableIdleTimeMillis();
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (idleEvictTime < underTest.getIdleTimeMillis() || (idleSoftEvictTime < underTest.getIdleTimeMillis() && getMinIdle() < idleObjects.size())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest.getObject());
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest.getObject())) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest.getObject());
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
return;
}",0,False
"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0,False
"@Override
public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0,False
"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0,False
"public void returnObject(final K key, final V obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0,False
"@Override
public int getNumIdle(final K key) {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle(key);
} finally {
readLock.unlock();
}
}",0,False
"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0,False
"@Override
public void destroyObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.destroyObject(key, obj);
} finally {
writeLock.unlock();
}
}",0,True
"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (final Exception e) {
}
}",0,False
"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
} else {
continue;
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
} finally {
synchronized (this) {
pool.decrementActiveCount();
}
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}",0,False
"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0,False
"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0,False
"@Override
public void clear() throws Exception, UnsupportedOperationException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.clear();
} finally {
writeLock.unlock();
}
}",0,True
"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0,True
"@Override
public T borrowObject(K key) throws Exception {
assertOpen();
PooledObject<T> p = null;
WhenExhaustedAction whenExhaustedAction = _whenExhaustedAction;
long maxWait = _maxWait;
boolean create;
ObjectDeque<T> objectDeque = poolMap.get(key);
while (p == null) {
create = false;
if (whenExhaustedAction == WhenExhaustedAction.FAIL) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.BLOCK) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, false);
}
if (p == null && objectDeque != null) {
if (maxWait < 1) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
p = objectDeque.getIdleObjects().pollFirst(maxWait, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else if (whenExhaustedAction == WhenExhaustedAction.GROW) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key, true);
}
if (p != null && !p.allocate()) {
p = null;
}
}
if (p != null) {
try {
_factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = _factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p);
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
return p.getObject();
}",0,False
"public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for (; ; ) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair) (pool.queue.removeFirst());
if (null != pair) {
_totalIdle--;
}
} catch (NoSuchElementException e) {
}
if (null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if (_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0) {
wait(waitTime);
}
}
} catch (InterruptedException e) {
}
if (_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue;
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
if (newlyCreated) {
return pair.value;
} else {
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e2) {
}
continue;
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
synchronized (this) {
pool.decrementActiveCount();
}
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
}
} else {
return pair.value;
}
}
}
}",0,False
"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWaitMillis < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0,True
protected int _totIdle = 0;,1,False
private int initIdleCapacity;,1,True
"@Override
public int getNumIdle() {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumIdle();
} finally {
readLock.unlock();
}
}",1,True
private int _totalIdle = 0;,1,False
private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1,True
"@Override
public boolean validateObject(final T obj) {
writeLock.tryLock();
try {
return factory.validateObject(obj);
} finally {
writeLock.unlock();
}
}",1,True
protected int _totActive = 0;,1,False
"@Override
public void clear(K key) {
ObjectDeque<T> objectDeque = register(key);
try {
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
p = idleObjects.poll();
}
} finally {
deregister(key);
}
}",1,True
"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(final Object other) {
return ((IdentityWrapper) other).instance == instance;
}",1,False
"@Override
public Map<String, Integer> getNumWaitersByKey() {
final Map<String, Integer> result = new HashMap<String, Integer>();
for (final K key : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",1,False
protected PoolableObjectFactory _factory = null;,1,True
"@Override
public void close() {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
pool.close();
} catch (Exception e) {
} finally {
writeLock.unlock();
}
}",1,False
"public JdkProxySource(ClassLoader classLoader, Class<?>[] interfaces) {
this.classLoader = classLoader;
this.interfaces = interfaces;
}",1,True
"@Override
public V borrowObject(final K key) throws Exception, NoSuchElementException, IllegalStateException {
WriteLock writeLock = readWriteLock.writeLock();
writeLock.tryLock();
try {
return keyedPool.borrowObject(key);
} finally {
writeLock.unlock();
}
}",1,False
"@Override
public int getNumActive(final K key) {
ReadLock readLock = readWriteLock.readLock();
readLock.tryLock();
try {
return keyedPool.getNumActive(key);
} finally {
readLock.unlock();
}
}",1,False
"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",1,False
"private void removeAbandoned() {
final long now = System.currentTimeMillis();
final long timeout = now - (abandonedConfig.getRemoveAbandonedTimeout() * 1000);
ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>();
Iterator<PooledObject<T>> it = allObjects.values().iterator();
while (it.hasNext()) {
PooledObject<T> pooledObject = it.next();
synchronized (pooledObject) {
if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsed() <= timeout) {
pooledObject.markAbandoned();
remove.add(pooledObject);
}
}
}
Iterator<PooledObject<T>> itr = remove.iterator();
while (itr.hasNext()) {
PooledObject<T> pooledObject = itr.next();
if (abandonedConfig.getLogAbandoned()) {
pooledObject.printStackTrace();
}
try {
invalidateObject(pooledObject.getObject());
} catch (Exception e) {
e.printStackTrace();
}
}
}",1,True
"private boolean hasBorrowWaiters() {
for (final K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",1,False
"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",1,True
"@Override
public void passivateObject(final K key, final V obj) throws Exception {
writeLock.tryLock();
try {
keyedFactory.passivateObject(key, obj);
} finally {
writeLock.unlock();
}
}",1,False
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1,True
private SoftReference<T> reference;,1,True
"private long getMeanFromStatsCache(LinkedList<Long> cache) {
List<Long> times = new ArrayList<Long>(AVERAGE_TIMING_STATS_CACHE_SIZE);
synchronized (cache) {
times.addAll(cache);
}
double result = 0;
int counter = 0;
Iterator<Long> iter = times.iterator();
while (iter.hasNext()) {
Long time = iter.next();
if (time != null) {
counter++;
result = result * ((counter - 1) / counter) + time.longValue() / counter;
}
}
return (long) result;
}",1,True
"public PoolableObjectFactory getFactory() {
return _factory;
}",1,True
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1,True
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1,True
private int _totalIdle = 0;,1,False
"public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll();
}",1,True
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;,1,True
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1,True
"@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if (null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + t.getMessage());
}
}
}
}
_numActive++;
return obj;
}",1,True
"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = poolMap.get(k).getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
}
if (destroyed) {
itemsToRemove--;
}
}
}",1,True
"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
final Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (final K key : poolMap.keySet()) {
final ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
final List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (final PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",1,False
"public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
notifyAll();
}",1,False
"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0,False
"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0,False
"private boolean hasBorrowWaiters() {
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
if (pool.hasTakeWaiters()) {
return true;
}
}
}
return false;
}",0,False
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0,False
"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"// --- protected methods ------------------------------------------
@Override
protected Listable<E> insertListable(Listable<E> before, Listable<E> after, E value) {
_modCount++;
_size++;
Listable<E> elt = _list.insertListable((null == before ? _pre : before), (null == after ? _post : after), value);
if (null == _head.next()) {
_head.setNext(elt);
_head.setPrev(elt);
}
if (before == _head.prev()) {
_head.setPrev(elt);
}
if (after == _head.next()) {
_head.setNext(elt);
}
broadcastListableInserted(elt);
return elt;
}",0,False
"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0,False
"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0,False
"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0,False
"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0,False
"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0,False
"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0,False
"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0,False
"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0,False
"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0,False
"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0,False
"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"public void invalidateObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0,False
"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final K key, final V obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0,False
"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
"@Deprecated
protected int _totActive = 0;",0,False
"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0,False
"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0,False
"protected void broadcastListableInserted(Listable elt) {
Iterator it = _cursors.iterator();
while (it.hasNext()) {
WeakReference ref = (WeakReference) it.next();
Cursor cursor = (Cursor) ref.get();
if (cursor == null) {
it.remove();
} else {
cursor.listableInserted(elt);
}
}
}",0,False
"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0,False
"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void returnObject(final Object obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0,False
"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0,False
"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}

ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0,False
"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0,False
"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0,False
"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
protected int _totActive = 0;,0,False
protected int _totIdle = 0;,0,False
"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void returnObject(final T obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final T obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void invalidateObject(final K key, final V obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"@Override
public void run() {
ClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(_factoryClassLoader);
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}",0,False
"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0,False
"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0,False
"private synchronized void allocate() {
if (isClosed()) {
return;
}
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0,False
"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0,False
"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0,False
"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0,False
"private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if ((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator iter = _pool.iterator();
while (iter.hasNext()) {
try {
Object obj = ((SoftReference) iter.next()).get();
if (null != obj) {
_factory.destroyObject(obj);
}
} catch (Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}",0,False
protected int _totIdle = 0;,0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0,False
"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0,False
"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0,False
"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0,False
"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0,False
"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0,False
"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0,False
"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0,False
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = factory.makeObject().getObject();
createCount++;
PooledSoftReference<T> ref = new PooledSoftReference<T>(new SoftReference<T>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0,False
"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0,False
"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0,False
"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0,False
"private synchronized void destroyStack(Object key, Stack stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0,False
"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
allocate();
}
}
}
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
protected int _totIdle = 0;,0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0,False
"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}",0,False
"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"@Override
public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"@Override
public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0,False
"public void returnObject(final V obj) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0,False
"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0,False
"@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0,False
"@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch<T> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0,False
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0,False
"private synchronized void destroyStack(K key, Stack<V> stack) {
if (null == stack) {
return;
} else {
if (null != _factory) {
Iterator<V> it = stack.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(key, it.next());
} catch (Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}",0,False
"private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if (null == old) {
_activeCount.put(key, new Integer(1));
} else {
_activeCount.put(key, new Integer(old.intValue() + 1));
}
}",0,True
"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List) toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0,False
"public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while (_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}",0,False
"public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized (this) {
_numActive--;
}
allocate();
}
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0,False
private ClassLoader _factoryClassLoader = null;,0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}",0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"@Override
public void clear() {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext(); ) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0,False
private boolean testOnReturn;,0,False
"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = this.testWhileIdle;
minEvictableIdleTimeMillis = this.minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((this.lifo && !_evictionCursor.hasPrevious()) || (!this.lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((this.lifo && !_evictionCursor.hasPrevious()) || (!this.lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = this.lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.getTstamp() > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.getValue());
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.getValue())) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.getValue());
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.getValue());
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (this.lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0,False
private long timeBetweenEvictionRunsMillis;,0,False
private boolean testOnBorrow;,0,False
private int maxIdle;,0,False
private int minIdle;,0,False
private boolean testWhileIdle;,0,False
"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(this.createReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}",0,False
"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0,False
"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(K key, T t) throws Exception {
ObjectDeque<T> objectDeque = poolMap.get(key);
PooledObject<T> p = objectDeque.getAllObjects().get(t);
if (p == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
long activeTime = p.getActiveTimeMillis();
if (getTestOnReturn()) {
if (!factory.validateObject(key, t)) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
}
try {
factory.passivateObject(key, t);
} catch (Exception e1) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
updateStatsReturn(activeTime);
return;
}
if (!p.deallocate()) {
throw new IllegalStateException(""Object has already been retured to this pool"");
}
int maxIdle = getMaxIdlePerKey();
LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
try {
destroy(key, p, true);
} catch (Exception e) {
}
} else {
if (getLifo()) {
idleObjects.addFirst(p);
} else {
idleObjects.addLast(p);
}
}
if (hasBorrowWaiters()) {
reuseCapacity();
}
updateStatsReturn(activeTime);
}",0,True
"public T borrowObject(K key, long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
if (blockWhenExhausted) {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null && objectDeque != null) {
if (borrowMaxWait < 0) {
p = objectDeque.getIdleObjects().takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = objectDeque.getIdleObjects().pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
if (objectDeque != null) {
p = objectDeque.getIdleObjects().pollFirst();
}
if (p == null) {
create = true;
p = create(key);
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(key, p.getObject());
} catch (Exception e) {
try {
destroy(key, p, true);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(key, p, true);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0,False
"private boolean reuseCapacity() {
final int maxTotalPerKey = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKey && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
boolean success = false;
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
success = true;
}
} catch (Exception ex) {
} finally {
deregister(loadedKey);
}
}
return success;
}",0,False
"public T borrowObject(long borrowMaxWait) throws Exception {
assertOpen();
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWait < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWait, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p.getObject());
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p.getObject());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
borrowedCount.incrementAndGet();
synchronized (idleTimes) {
idleTimes.add(Long.valueOf(p.getIdleTimeMillis()));
idleTimes.poll();
}
synchronized (waitTimes) {
waitTimes.add(Long.valueOf(waitTime));
waitTimes.poll();
}
synchronized (maxBorrowWaitTimeMillisLock) {
if (waitTime > maxBorrowWaitTimeMillis) {
maxBorrowWaitTimeMillis = waitTime;
}
}
return p.getObject();
}",0,False
"@Override
public void clear() {
PooledObject<T> p = idleObjects.poll();
while (p != null) {
try {
destroy(p);
} catch (Exception e) {
}
p = idleObjects.poll();
}
}",0,True
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0,False
"@Override
public void addObject(K key) throws Exception {
assertOpen();
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (K key : _poolMap.keySet()) {
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (ObjectTimestampPair<V> pair : list) {
map.put(pair, key);
}
}
Set<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = allocationQueueIter.next();
ObjectQueue pool = _poolMap.get(latch.getkey());
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {
clearOldest = true;
break;
}
if ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (this.maxTotalPerKey < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"@Override
public synchronized void addObject() throws Exception {
assertOpen();
T obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0,False
"private void reuseCapacity() {
final int maxTotalPerKeySave = getMaxTotalPerKey();
int maxQueueLength = 0;
LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
K loadedKey = null;
for (K k : poolMap.keySet()) {
final ObjectDeque<T> deque = poolMap.get(k);
if (deque != null) {
final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
final int queueLength = pool.getTakeQueueLength();
if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
maxQueueLength = queueLength;
mostLoaded = pool;
loadedKey = k;
}
}
}
if (mostLoaded != null) {
register(loadedKey);
try {
PooledObject<T> p = create(loadedKey);
if (p != null) {
addIdleObject(loadedKey, p);
}
} catch (Exception e) {
swallowException(e);
} finally {
deregister(loadedKey);
}
}
}",0,False
"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0,False
"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (Exception e) {
}
}
}",0,False
"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0,False
"@Override
public Map<String, List<DefaultPooledObjectInfo>> listAllObjects() {
Map<String, List<DefaultPooledObjectInfo>> result = new HashMap<String, List<DefaultPooledObjectInfo>>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
List<DefaultPooledObjectInfo> list = new ArrayList<DefaultPooledObjectInfo>();
result.put(key.toString(), list);
for (PooledObject<T> p : queue.getAllObjects().values()) {
list.add(new DefaultPooledObjectInfo(p));
}
}
}
return result;
}",0,False
"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0,False
"public void returnObject(final Object obj) {
if (type.isInstance(obj)) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Invalidated object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public String toString() {
final StringBuffer sb = new StringBuffer(128);
sb.append(""CompositeKeyedObjectPool{"");
sb.append(""poolFactory="").append(poolFactory);
sb.append("", open="").append(open);
try {
final int numActive = getNumActive();
sb.append("", activeObjects="").append(numActive);
} catch (Exception e) {
}
try {
final int numIdle = getNumIdle();
sb.append("", idleObjects="").append(numIdle);
} catch (Exception e) {
}
sb.append('}');
return sb.toString();
}",0,False
private final transient Object lock = new Object();,0,False
"// XXX: Add better handling of when this instance is not Serializable
private final PoolableObjectFactory factory;",0,False
"// XXX: Add better handling of when this instance is not Serializable
private final PoolableObjectFactory factory;",0,False
"public void run() {
if (referant == null) {
cancel();
return;
}
final PoolableObjectFactory factory = getObjectPool().getFactory();
synchronized (InvalidEvictorReference.this) {
Object r = referant;
while (r instanceof LenderReference) {
r = ((LenderReference) r).get();
}
if (r == null) {
clear();
return;
}
try {
factory.activateObject(r);
if (factory.validateObject(r)) {
factory.passivateObject(r);
} else {
factory.destroyObject(r);
clear();
}
} catch (Exception e) {
clear();
}
}
}",0,False
protected final transient ReferenceQueue rq = new ReferenceQueue();,0,False
private transient volatile int active = 0;,0,False
"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0,False
"public synchronized void evict() throws Exception {
assertOpen();
if (!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i = 0, m = getNumTests(); i < m; i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0) && (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0) && (idleTimeMilis > _softMinEvictableIdleTimeMillis) && (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if (_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
}
}
}",0,False
"public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}",0,False
"public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (_pool.isEmpty()) {
if (null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference) (_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear();
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack) (_pools.get(key));
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if (null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}",0,False
"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0,True
"public void invalidateObject(final K key, final V obj) {
synchronized (lock) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}
}",0,False
"public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue;
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) || (!_lifo && !_evictionCursor.hasNext())) {
continue;
}
pair = _lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject = false;
if ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.tstamp > minEvictableIdleTimeMillis)) {
removeObject = true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key, pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(key, pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(key, pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}",0,False
"@Override
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch<T> latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
"@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if (null == stack) {
stack = new Stack<V>();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0,False
"@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}",0,False
"@Override
public synchronized void clear() {
if (null != _factory) {
Iterator<T> it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (null != _factory) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0,False
"public void returnObject(final Object obj) {
synchronized (lock) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}",0,False
"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0,False
"@Override
public synchronized void returnObject(final T obj) throws Exception {
boolean success = !isClosed();
final PooledSoftReference<T> ref = findReference(obj);
if (ref == null) {
throw new IllegalStateException(""Returned object not currently part of this pool"");
}
if (factory != null) {
if (!factory.validateObject(ref)) {
success = false;
} else {
try {
factory.passivateObject(ref);
} catch (final Exception e) {
success = false;
}
}
}
final boolean shouldDestroy = !success;
numActive--;
if (success) {
ref.deallocate();
idleReferences.add(ref);
}
notifyAll();
if (shouldDestroy && factory != null) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0,False
"public void invalidateObject(final Object obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"protected void listableInserted(Listable elt) {
if (null == _cur.next() && null == _cur.prev()) {
_cur.setNext(elt);
} else if (_cur.prev() == elt.prev()) {
_cur.setNext(elt);
}
if (_cur.next() == elt.next()) {
_cur.setPrev(elt);
}
if (_lastReturned == elt) {
_lastReturned = null;
}
}",0,False
"public void run() {
try {
evict();
} catch (Exception e) {
} catch (OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}",0,False
"private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed())
return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair((ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}",0,False
"public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
} catch (Exception e) {
}
}
}",0,False
"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}",0,False
"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() && pool.activeCount == 0 && pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}",0,False
"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0,False
"public void evict() throws Exception {
assertOpen();
synchronized (this) {
if (_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i = 0, m = getNumTests(); i < m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) || !_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ? (ObjectTimestampPair) _evictionCursor.previous() : (ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) && (idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) && ((getNumIdle() + 1) > getMinIdle())) {
removeObject = true;
}
if (getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch (Exception e) {
removeObject = true;
}
if (active) {
if (!_factory.validateObject(pair.value)) {
removeObject = true;
} else {
try {
_factory.passivateObject(pair.value);
} catch (Exception e) {
removeObject = true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch (Exception e) {
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}",0,False
"private synchronized void allocate() {
if (isClosed())
return;
for (; ; ) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for (; ; ) {
if ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0,False
"@Override
public int compareTo(final PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0,False
private int numActive = 0;,0,False
"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (final Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception ignored) {
}
}",0,False
"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && getNumIdle() < 2 && getNumActive() > getMaxTotal() - 3) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitMillis < 0 ? objectDeque.getIdleObjects().takeFirst() : objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
} catch (InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitMillis="" + borrowMaxWaitMillis));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0,False
"public T borrowObject(final Duration borrowMaxWaitDuration) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && getNumIdle() < 2 && getNumActive() > getMaxTotal() - 3) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
while (p == null) {
create = false;
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitDuration.isNegative() ? idleObjects.takeFirst() : idleObjects.pollFirst(borrowMaxWaitDuration);
} catch (final InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitDuration="" + borrowMaxWaitDuration));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(p);
} catch (final Exception e) {
try {
destroy(p, DestroyMode.NORMAL);
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception ignored) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0,False
private long createCount;,0,False
"@Override
public void close() {
try {
keyedPool.close();
} catch (final Exception e) {
}
}",0,False
"@Override
public void close() {
try {
pool.close();
} catch (final Exception e) {
}
}",0,False
PooledObjectState getState();,0,False
"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0,False
"public T borrowObject(final K key, final long borrowMaxWaitMillis) throws E {
assertOpen();
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
final boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
final long waitTimeMillis = System.currentTimeMillis();
final ObjectDeque<T> objectDeque = register(key);
try {
while (p == null) {
create = false;
p = objectDeque.getIdleObjects().pollFirst();
if (p == null) {
p = create(key);
if (p != null) {
create = true;
}
}
if (blockWhenExhausted) {
if (p == null) {
try {
p = borrowMaxWaitMillis < 0 ? objectDeque.getIdleObjects().takeFirst() : objectDeque.getIdleObjects().pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
} catch (InterruptedException e) {
throw cast(e);
}
}
if (p == null) {
throw new NoSuchElementException(appendStats(""Timeout waiting for idle object, borrowMaxWaitMillis="" + borrowMaxWaitMillis));
}
} else if (p == null) {
throw new NoSuchElementException(appendStats(""Pool exhausted""));
}
if (!p.allocate()) {
p = null;
}
if (p != null) {
try {
factory.activateObject(key, p);
} catch (final Exception e) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
} catch (final Exception e1) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to activate object""));
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(key, p);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(key, p, true, DestroyMode.NORMAL);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (final Exception e) {
}
p = null;
if (create) {
final NoSuchElementException nsee = new NoSuchElementException(appendStats(""Unable to validate object""));
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
} finally {
deregister(key);
}
updateStatsBorrow(p, Duration.ofMillis(System.currentTimeMillis() - waitTimeMillis));
return p.getObject();
}",0,False
"@Override
public void evict() throws E {
assertOpen();
if (!idleObjects.isEmpty()) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdle());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
evictionIterator = new EvictionIterator(idleObjects);
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(underTest);
} catch (final Exception e) {
destroy(underTest, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0,False
private long createCount;,0,False
private int numActive;,0,False
"public void invalidateObject(final Object key, final Object obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
synchronized (lock) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0,False
"public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext(); ) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue) _poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing = _totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}",0,False
"synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}",0,False
"public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) {
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack) (_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}",0,False
"public void returnObject(final Object key, final Object obj) {
if (type.isInstance(obj)) {
try {
keyedPool.returnObject(key, obj);
} catch (Exception e) {
}
} else {
throw new ClassCastException(""Returned object for key: "" + key + "" is not of type: "" + type.getName() + "" was: "" + obj);
}
}",0,False
"public void close() {
try {
pool.close();
} catch (Exception e) {
}
}",0,False
"public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"public void returnObject(final Object key, final Object obj) {
try {
pool.returnObject(obj);
} catch (Exception e) {
}
}",0,False
"public void close() {
try {
keyedPool.close();
} catch (Exception e) {
}
}",0,False
"public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized (this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll();
}
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
Stack stack = (Stack) (_pools.get(key));
destroyStack(key, stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}",0,False
"public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack) _pools.get(key);
if (null == stack) {
stack = new Stack();
stack.ensureCapacity(_initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key, stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if (null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}",0,False
"public synchronized void clear() {
if (null != _factory) {
Iterator it = _pool.iterator();
while (it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch (Exception e) {
}
}
}
_pool.clear();
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"@Override
public void invalidateObject(final T obj) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}",0,False
"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0,False
"@Override
public Map<String, Integer> getNumWaitersByKey() {
Map<String, Integer> result = new HashMap<String, Integer>();
for (K key : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(key);
if (queue != null) {
if (getBlockWhenExhausted()) {
result.put(key.toString(), Integer.valueOf(queue.getIdleObjects().getTakeQueueLength()));
} else {
result.put(key.toString(), Integer.valueOf(0));
}
}
}
return result;
}",0,False
"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0,False
"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = 0;
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
waitTime = System.currentTimeMillis();
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
waitTime = System.currentTimeMillis() - waitTime;
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
create = true;
p = create();
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && getTestOnBorrow()) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, waitTime);
return p.getObject();
}",0,False
"@Override
public void evict() throws Exception {
assertOpen();
if (getNumIdle() == 0) {
return;
}
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdlePerKey());
boolean testWhileIdle = getTestWhileIdle();
LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
List<K> keyCopy = new ArrayList<K>();
Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
idleObjects = objectDeque.getIdleObjects();
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
if (evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size())) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(evictionKey, underTest)) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (Exception e) {
destroy(evictionKey, underTest, true);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}",0,False
"public void clearOldest() {
final Map<PooledObject<T>, K> map = new TreeMap<PooledObject<T>, K>();
for (K k : poolMap.keySet()) {
ObjectDeque<T> queue = poolMap.get(k);
if (queue != null) {
final LinkedBlockingDeque<PooledObject<T>> idleObjects = queue.getIdleObjects();
for (PooledObject<T> p : idleObjects) {
map.put(p, k);
}
}
}
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Map.Entry<PooledObject<T>, K>> iter = map.entrySet().iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry<PooledObject<T>, K> entry = iter.next();
K key = entry.getValue();
PooledObject<T> p = entry.getKey();
boolean destroyed = true;
try {
destroyed = destroy(key, p, false);
} catch (Exception e) {
swallowException(e);
}
if (destroyed) {
itemsToRemove--;
}
}
}",0,False
"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0,False
"@Override
public void evict() throws Exception {
assertOpen();
if (idleObjects.size() > 0) {
PooledObject<T> underTest = null;
EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleTimeMillis(), getSoftMinEvictableIdleTimeMillis(), getMinIdle());
boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (getLifo()) {
evictionIterator = idleObjects.descendingIterator();
} else {
evictionIterator = idleObjects.iterator();
}
}
if (!evictionIterator.hasNext()) {
return;
}
try {
underTest = evictionIterator.next();
} catch (NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, idleObjects.size());
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(underTest);
active = true;
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
if (!factory.validateObject(underTest)) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
} else {
try {
factory.passivateObject(underTest);
} catch (Exception e) {
destroy(underTest);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0,False
PooledObjectState getState();,0,False
"@Override
public void evict() throws E {
assertOpen();
if (getNumIdle() > 0) {
PooledObject<T> underTest = null;
final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
synchronized (evictionLock) {
final EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());
final boolean testWhileIdle = getTestWhileIdle();
for (int i = 0, m = getNumTests(); i < m; i++) {
if (evictionIterator == null || !evictionIterator.hasNext()) {
if (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {
final List<K> keyCopy = new ArrayList<>();
final Lock readLock = keyLock.readLock();
readLock.lock();
try {
keyCopy.addAll(poolKeyList);
} finally {
readLock.unlock();
}
evictionKeyIterator = keyCopy.iterator();
}
while (evictionKeyIterator.hasNext()) {
evictionKey = evictionKeyIterator.next();
final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
if (objectDeque == null) {
continue;
}
final Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
evictionIterator = new EvictionIterator(idleObjects);
if (evictionIterator.hasNext()) {
break;
}
evictionIterator = null;
}
}
if (evictionIterator == null) {
return;
}
final Deque<PooledObject<T>> idleObjects;
try {
underTest = evictionIterator.next();
idleObjects = evictionIterator.getIdleObjects();
} catch (final NoSuchElementException nsee) {
i--;
evictionIterator = null;
continue;
}
if (!underTest.startEvictionTest()) {
i--;
continue;
}
boolean evict;
try {
evict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
swallowException(new Exception(t));
evict = false;
}
if (evict) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
} else {
if (testWhileIdle) {
boolean active = false;
try {
factory.activateObject(evictionKey, underTest);
active = true;
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
if (active) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(evictionKey, underTest);
} catch (final Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
if (validationThrowable != null) {
if (validationThrowable instanceof RuntimeException) {
throw (RuntimeException) validationThrowable;
}
throw (Error) validationThrowable;
}
} else {
try {
factory.passivateObject(evictionKey, underTest);
} catch (final Exception e) {
destroy(evictionKey, underTest, true, DestroyMode.NORMAL);
destroyedByEvictorCount.incrementAndGet();
}
}
}
}
if (!underTest.endEvictionTest(idleObjects)) {
}
}
}
}
}
final AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
removeAbandoned(ac);
}
}",0,False
"@Override
public synchronized void addObject() throws E {
assertOpen();
if (factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
final T obj = factory.makeObject().getObject();
createCount++;
final PooledSoftReference<T> ref = new PooledSoftReference<>(new SoftReference<>(obj, refQueue));
allReferences.add(ref);
boolean success = true;
if (!factory.validateObject(ref)) {
success = false;
} else {
factory.passivateObject(ref);
}
final boolean shouldDestroy = !success;
if (success) {
idleReferences.add(ref);
notifyAll();
}
if (shouldDestroy) {
try {
destroy(ref);
} catch (final Exception e) {
}
}
}",0,False
"public void invalidateObject(final Object obj) {
synchronized (lock) {
try {
pool.invalidateObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int) Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}",0,False
"public synchronized void clear() {
for (Iterator entries = _poolMap.entrySet().iterator(); entries.hasNext(); ) {
final Map.Entry entry = (Map.Entry) entries.next();
final Object key = entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (entry.getValue())).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
}
}
_poolMap.clear();
_poolList.clear();
_totalIdle = 0;
notifyAll();
}",0,False
"public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue) (_poolMap.remove(key));
if (null == pool) {
return;
} else {
_poolList.remove(key);
for (Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key, ((ObjectTimestampPair) (it.next())).value);
} catch (Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}",0,False
"private void addObjectToPool(Object key, Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
if (decrementNumActive) {
synchronized (this) {
pool.decrementActiveCount();
notifyAll();
}
}
}",0,False
"public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue) _poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext(); ) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list = ((ObjectQueue) (_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}",0,False
"public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if (!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch (Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll();
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if (!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if (_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0);
}
_pool.push(obj);
obj = toBeDestroyed;
}
notifyAll();
if (shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
}",0,False
"@Override
public void invalidateObject(final K key, final V obj) {
try {
keyedPool.invalidateObject(key, obj);
} catch (Exception e) {
}
}",0,False
"@Override
public void run() {
boolean success = false;
try {
if (keyedPool.getNumIdle(key) < minIdle) {
keyedPool.addObject(key);
}
success = true;
} catch (Exception e) {
cancel();
} finally {
if (!success) {
cancel();
}
}
}",0,False
"@Override
@SuppressWarnings(""rawtypes"")
public boolean equals(Object other) {
return ((IdentityWrapper) other).instance == instance;
}",0,False
"@Override
public synchronized boolean allocate() {
if (state == PooledObjectState.IDLE) {
state = PooledObjectState.ALLOCATED;
lastBorrowTime = System.currentTimeMillis();
lastUseTime = lastBorrowTime;
borrowedCount++;
if (logAbandoned) {
borrowedBy = new AbandonedObjectCreatedException();
}
return true;
} else if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
return false;
}
return false;
}",0,False
"@Override
public synchronized boolean endEvictionTest(Deque<PooledObject<T>> idleQueue) {
if (state == PooledObjectState.EVICTION) {
state = PooledObjectState.IDLE;
return true;
} else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
state = PooledObjectState.IDLE;
if (!idleQueue.offerFirst(this)) {
}
}
return false;
}",0,False
"@Override
public int compareTo(PooledObject<T> other) {
final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int) Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}",0,False
"public T borrowObject(long borrowMaxWaitMillis) throws Exception {
assertOpen();
AbandonedConfig ac = this.abandonedConfig;
if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3)) {
removeAbandoned(ac);
}
PooledObject<T> p = null;
boolean blockWhenExhausted = getBlockWhenExhausted();
boolean create;
long waitTime = System.currentTimeMillis();
while (p == null) {
create = false;
if (blockWhenExhausted) {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
if (borrowMaxWaitMillis < 0) {
p = idleObjects.takeFirst();
} else {
p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
}
}
if (p == null) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
}
if (!p.allocate()) {
p = null;
}
} else {
p = idleObjects.pollFirst();
if (p == null) {
p = create();
if (p != null) {
create = true;
}
}
if (p == null) {
throw new NoSuchElementException(""Pool exhausted"");
}
if (!p.allocate()) {
p = null;
}
}
if (p != null) {
try {
factory.activateObject(p);
} catch (Exception e) {
try {
destroy(p);
} catch (Exception e1) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to activate object"");
nsee.initCause(e);
throw nsee;
}
}
if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
boolean validate = false;
Throwable validationThrowable = null;
try {
validate = factory.validateObject(p);
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
validationThrowable = t;
}
if (!validate) {
try {
destroy(p);
destroyedByBorrowValidationCount.incrementAndGet();
} catch (Exception e) {
}
p = null;
if (create) {
NoSuchElementException nsee = new NoSuchElementException(""Unable to validate object"");
nsee.initCause(validationThrowable);
throw nsee;
}
}
}
}
}
updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
return p.getObject();
}",0,False
