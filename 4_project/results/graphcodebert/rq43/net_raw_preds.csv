Unnamed: 0,source,target,raw_preds
0,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0,False
1,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0,False
2,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0,False
3,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0,False
4,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
5,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0,False
6,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0,False
7,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
8,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0,False
9,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
10,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
11,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
12,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
13,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
14,"public IOException getIOException() {
return (IOException) getCause();
}",0,False
15,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0,False
16,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
17,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
18,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0,False
19,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0,False
20,public String identifier;,0,False
21,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
22,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
23,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0,False
24,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
25,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
26,"public int[] startSubnegotiationLocal() {
return null;
}",0,False
27,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0,False
28,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
29,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
30,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
31,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0,False
32,private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
33,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0,False
34,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
35,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0,False
36,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0,False
37,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0,False
38,"private void buildContainer(Threadable threadable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
39,"public boolean auth(AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (sendCommand(POP3Command.AUTH, method.getAuthName()) != POP3Reply.OK_INT) {
return false;
}
switch(method) {
case PLAIN:
return sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))) == POP3Reply.OK;
case CRAM_MD5:
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return sendCommand(new String(Base64.encodeBase64(toEncode))) == POP3Reply.OK;
default:
return false;
}
}",0,False
40,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
41,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0,False
42,"final synchronized void _sendTerminalType() throws IOException {
if (debug) {
System.err.println(""SEND TERMINAL-TYPE: "" + terminalType);
}
if (terminalType != null) {
_output_.write(_COMMAND_SB);
_output_.write(_COMMAND_IS);
_output_.write(terminalType.getBytes());
_output_.write(_COMMAND_SE);
_output_.flush();
}
}",0,False
43,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0,False
44,"public Object encode(Object pObject) {
if (!(pObject instanceof byte[])) {
throw new RuntimeException(""Parameter supplied to Base64 encode is not a byte[]"");
}
return encode((byte[]) pObject);
}",0,False
45,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0,False
46,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0,False
47,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
48,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0,False
49,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0,False
50,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
51,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
52,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
53,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0,False
54,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0,False
55,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
56,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0,False
57,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
58,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
59,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
60,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
61,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
62,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
63,"public int[] startSubnegotiationLocal() {
return null;
}",0,False
64,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0,False
65,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0,False
66,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0,False
67,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
68,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0,False
69,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0,False
70,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0,False
71,"public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0,False
72,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0,False
73,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0,False
74,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0,False
75,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0,False
76,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0,False
77,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
78,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",0,True
79,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
80,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0,False
81,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
82,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
83,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
84,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
85,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0,False
86,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
87,"public NewsgroupInfo[] listNewNewsgroups(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newgroups(query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
return __readNewsgroupListing();
}",0,False
88,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0,False
89,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
90,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
91,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
bogusIdCount++;
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
92,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0,False
93,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0,False
94,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
95,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
96,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0,False
97,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
98,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
99,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
100,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0,False
101,"public int[] startSubnegotiationLocal() {
return null;
}",0,False
102,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0,False
103,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
104,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0,False
105,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
106,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0,False
107,private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
108,"public static boolean enableEndpointNameVerification(SSLSocket socket) {
try {
Class<?> cls = Class.forName(""javax.net.ssl.SSLParameters"");
Method setEndpointIdentificationAlgorithm = cls.getDeclaredMethod(""setEndpointIdentificationAlgorithm"", String.class);
Method getSSLParameters = SSLSocket.class.getDeclaredMethod(""getSSLParameters"");
Method setSSLParameters = SSLSocket.class.getDeclaredMethod(""setSSLParameters"", cls);
if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
Object sslParams = getSSLParameters.invoke(socket);
if (sslParams != null) {
setEndpointIdentificationAlgorithm.invoke(sslParams, ""HTTPS"");
setSSLParameters.invoke(socket, sslParams);
return true;
}
}
} catch (SecurityException e) {
} catch (ClassNotFoundException e) {
} catch (NoSuchMethodException e) {
} catch (IllegalArgumentException e) {
} catch (IllegalAccessException e) {
} catch (InvocationTargetException e) {
}
return false;
}",0,False
109,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0,False
110,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0,False
111,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0,False
112,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0,False
113,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
114,"@Deprecated
public static String TRUSTSTORE_ALGORITHM;",0,False
115,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
116,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
117,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0,False
118,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
119,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
120,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
121,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
122,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0,False
123,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0,False
124,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0,False
125,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0,False
126,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
127,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0,False
128,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0,False
129,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
130,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
131,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0,False
132,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
133,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0,False
134,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
135,"public int[] startSubnegotiationLocal() {
return null;
}",0,False
136,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0,False
137,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
138,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0,False
139,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
140,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0,False
141,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0,False
142,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0,False
143,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0,False
144,"@Override
InputStream _createErrorStream() throws IOException {
int localPort;
ServerSocket server;
Socket socket;
localPort = MAX_CLIENT_PORT;
server = null;
for (localPort = MAX_CLIENT_PORT; localPort >= MIN_CLIENT_PORT; --localPort) {
try {
server = _serverSocketFactory_.createServerSocket(localPort, 1, getLocalAddress());
break;
} catch (SocketException e) {
continue;
}
}
if (server == null) {
throw new BindException(""All ports in use."");
}
_output_.write(Integer.toString(server.getLocalPort()).getBytes());
_output_.write('\0');
_output_.flush();
socket = server.accept();
server.close();
if (isRemoteVerificationEnabled() && !verifyRemote(socket)) {
socket.close();
throw new IOException(""Security violation: unexpected connection attempt by "" + socket.getInetAddress().getHostAddress());
}
return (new SocketInputStream(socket, socket.getInputStream()));
}",0,False
145,"public void rexec(String username, String password, String command, boolean separateErrorStream) throws IOException {
int ch;
if (separateErrorStream) {
_errorStream_ = _createErrorStream();
} else {
_output_.write('\0');
}
_output_.write(username.getBytes());
_output_.write('\0');
_output_.write(password.getBytes());
_output_.write('\0');
_output_.write(command.getBytes());
_output_.write('\0');
_output_.flush();
ch = _input_.read();
if (ch > 0) {
StringBuilder buffer = new StringBuilder();
while ((ch = _input_.read()) != -1 && ch != '\n') {
buffer.append((char) ch);
}
throw new IOException(buffer.toString());
} else if (ch < 0) {
throw new IOException(""Server closed connection."");
}
}",0,False
146,"public String query(boolean longOutput, String username) throws IOException {
int read;
StringBuilder result = new StringBuilder(__buffer.length);
BufferedReader input;
input = new BufferedReader(new InputStreamReader(getInputStream(longOutput, username)));
try {
while (true) {
read = input.read(__buffer, 0, __buffer.length);
if (read <= 0) {
break;
}
result.append(__buffer, 0, read);
}
} finally {
input.close();
}
return result.toString();
}",0,False
147,"public int execMIC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_MIC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_MIC, """");
}
}",0,False
148,"public int execADAT(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ADAT, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ADAT);
}
}",0,False
149,"public int execENC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ENC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ENC, """");
}
}",0,False
150,"@Deprecated
public static String KEYSTORE_ALGORITHM;",0,False
151,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = _socket_.getInetAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (!isClientMode) {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
}",0,False
152,"public int execCONF(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_CONF, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_CONF, """");
}
}",0,False
153,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
154,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
}
}
}",0,False
155,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
156,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
157,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
}",0,False
158,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
159,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0,False
160,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0,False
161,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0,False
162,public String identifier;,0,False
163,public int size;,0,False
164,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
165,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
166,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0,False
167,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0,False
168,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0,False
169,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0,False
170,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0,False
171,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
172,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0,False
173,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
174,"public Object decode(Object pObject) {
if (pObject instanceof byte[]) {
return decode((byte[]) pObject);
} else if (pObject instanceof String) {
return decode((String) pObject);
} else {
throw new RuntimeException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
}
}",0,False
175,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0,False
176,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker, boolean showDirection) {
this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
}",0,False
177,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0,False
178,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0,False
179,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
180,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0,False
181,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0,False
182,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
183,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0,False
184,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
185,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
186,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0,False
187,"public IOException getIOException() {
return (IOException) getCause();
}",0,False
188,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0,False
189,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0,False
190,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0,False
191,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0,False
192,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
193,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
194,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
bogusIdCount++;
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
195,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0,False
196,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0,False
197,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
198,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, encoding));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, encoding));
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}",0,False
199,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
200,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
201,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
202,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0,False
203,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
204,"public int[] startSubnegotiationRemote() {
return null;
}",0,False
205,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
if ((suboptionData != null) && (suboptionLength > 1) && (termType != null)) {
if ((suboptionData[0] == TERMINAL_TYPE) && (suboptionData[1] == TERMINAL_TYPE_SEND)) {
int[] response = new int[termType.length() + 2];
response[0] = TERMINAL_TYPE;
response[1] = TERMINAL_TYPE_IS;
for (int ii = 0; ii < termType.length(); ii++) {
response[ii + 2] = termType.charAt(ii);
}
return response;
}
}
return null;
}",0,False
206,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
207,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0,False
208,"@Override
public String[] getServerAliases(String keyType, Principal[] issuers) {
return null;
}",0,False
209,private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
210,"public static boolean enableEndpointNameVerification(SSLSocket socket) {
try {
Class<?> cls = Class.forName(""javax.net.ssl.SSLParameters"");
Method setEndpointIdentificationAlgorithm = cls.getDeclaredMethod(""setEndpointIdentificationAlgorithm"", String.class);
Method getSSLParameters = SSLSocket.class.getDeclaredMethod(""getSSLParameters"");
Method setSSLParameters = SSLSocket.class.getDeclaredMethod(""setSSLParameters"", cls);
if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
Object sslParams = getSSLParameters.invoke(socket);
if (sslParams != null) {
setEndpointIdentificationAlgorithm.invoke(sslParams, ""HTTPS"");
setSSLParameters.invoke(socket, sslParams);
return true;
}
}
} catch (SecurityException e) {
} catch (ClassNotFoundException e) {
} catch (NoSuchMethodException e) {
} catch (IllegalArgumentException e) {
} catch (IllegalAccessException e) {
} catch (InvocationTargetException e) {
}
return false;
}",0,False
211,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0,False
212,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0,False
213,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
214,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0,False
215,"public String[] featureValues(String feature) throws IOException {
if (!initFeatureMap()) {
return null;
}
Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));
if (entries != null) {
return entries.toArray(new String[entries.size()]);
}
return null;
}",0,False
216,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
217,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
218,"private void doUnixPerms(FTPFile file, String valueLowerCase) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
break;
}
}
}",0,False
219,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
220,"public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
221,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
222,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
223,"public IOException getIOException() {
return (IOException) getCause();
}",0,False
224,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0,False
225,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0,False
226,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0,False
227,"public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException {
if (!NNTPReply.isPositiveCompletion(listActive(wildmat))) {
return null;
}
return __readNewsgroupListing();
}",0,False
228,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0,False
229,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0,False
230,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
231,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
232,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",0,False
233,"public TimeInfo(NtpV3Packet message, long returnTime, List<String> comments, boolean doComputeDetails) {
if (message == null) {
throw new IllegalArgumentException(""message cannot be null"");
}
this._returnTime = returnTime;
this._message = message;
this._comments = comments;
if (doComputeDetails) {
computeDetails();
}
}",0,False
234,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0,False
235,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
236,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
237,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
238,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0,False
239,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
240,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
241,"public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
242,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
243,"public int[] startSubnegotiationRemote() {
return null;
}",0,False
244,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
245,"@Override
DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int length;
length = _message.length();
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(length + 4);
return datagram;
}",0,False
246,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
247,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
default:
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
248,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
default:
break;
}
}
}",0,False
249,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0,False
250,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0,False
251,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0,False
252,"public static void main(String[] args) throws Throwable {
final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" + "" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" + "" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"")
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for (String s : l) {
System.out.printf(""%-25s %s%n"", s, fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0,False
253,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0,False
254,"public PrintCommandListener(PrintStream stream, boolean suppressLogin, char eolMarker) {
this(new PrintWriter(stream), suppressLogin, eolMarker);
}",0,False
255,"public String[] listNames(String pathname) throws IOException {
Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));
if (socket == null) {
return null;
}
BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
ArrayList<String> results = new ArrayList<String>();
String line;
while ((line = reader.readLine()) != null) {
results.add(line);
}
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0,False
256,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0,False
257,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
258,"public byte[] parseADATReply(String reply) {
if (reply == null) {
return null;
} else {
return Base64.decodeBase64(extractPrefixedData(""ADAT="", reply));
}
}",0,False
259,"@Deprecated
public static String TRUSTSTORE_ALGORITHM;",0,False
260,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
261,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
262,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
263,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
264,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
265,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0,False
266,"public String[] listNewNews(NewGroupsOrNewsQuery query) throws IOException {
if (!NNTPReply.isPositiveCompletion(newnews(query.getNewsgroups(), query.getDate(), query.getTime(), query.isGMT(), query.getDistributions()))) {
return null;
}
Vector<String> list = new Vector<String>();
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
try {
while ((line = reader.readLine()) != null) {
list.addElement(line);
}
} finally {
reader.close();
}
int size = list.size();
if (size < 1) {
return new String[0];
}
String[] result = new String[size];
list.copyInto(result);
return result;
}",0,False
267,"private void __parseArticlePointer(String reply, ArticleInfo pointer) throws MalformedServerReplyException {
String[] tokens = reply.split("" "");
if (tokens.length >= 3) {
int i = 1;
try {
pointer.articleNumber = Long.parseLong(tokens[i++]);
pointer.articleId = tokens[i++];
return;
} catch (NumberFormatException e) {
}
}
throw new MalformedServerReplyException(""Could not parse article pointer.\nServer reply: "" + reply);
}",0,False
268,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list())) {
return null;
}
return __readNewsgroupListing();
}",0,False
269,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
270,"public Threadable thread(Iterable<? extends Threadable> messages) {
if (messages == null) {
return null;
}
HashMap<String, ThreadContainer> idTable = new HashMap<String, ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
}",0,False
271,"private static POP3MessageInfo __parseStatus(String line) {
int num, size;
StringTokenizer tokenizer;
tokenizer = new StringTokenizer(line);
if (!tokenizer.hasMoreElements()) {
return null;
}
num = size = 0;
try {
num = Integer.parseInt(tokenizer.nextToken());
if (!tokenizer.hasMoreElements()) {
return null;
}
size = Integer.parseInt(tokenizer.nextToken());
} catch (NumberFormatException e) {
return null;
}
return new POP3MessageInfo(num, size);
}",0,False
272,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
273,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
274,"final boolean _sendAYT(long timeout) throws IOException, IllegalArgumentException, InterruptedException {
boolean retValue = false;
synchronized (aytMonitor) {
synchronized (this) {
aytFlag = false;
_output_.write(_COMMAND_AYT);
_output_.flush();
}
aytMonitor.wait(timeout);
if (aytFlag == false) {
retValue = false;
aytFlag = true;
} else {
retValue = true;
}
}
return (retValue);
}",0,False
275,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
276,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
277,"@Override
public void run() {
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch = __read(true)) < 0) {
break;
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
} catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify = false;
try {
notify = __processChar(ch);
} catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
} catch (IOException ioe) {
synchronized (__queue) {
__ioException = ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed = true;
__hasReachedEOF = true;
__queue.notify();
}
__threaded = false;
}",0,False
278,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
279,"private int __read(boolean mayBlock) throws IOException {
int ch;
while (true) {
if (!mayBlock && super.available() == 0) {
return WOULD_BLOCK;
}
if ((ch = super.read()) < 0) {
return EOF;
}
ch = (ch & 0xff);
synchronized (__client) {
__client._processAYTResponse();
}
__client._spyRead(ch);
switch(__receiveState) {
case _STATE_CR:
if (ch == '\0') {
continue;
}
case _STATE_DATA:
if (ch == TelnetCommand.IAC) {
__receiveState = _STATE_IAC;
continue;
}
if (ch == '\r') {
synchronized (__client) {
if (__client._requestedDont(TelnetOption.BINARY)) {
__receiveState = _STATE_CR;
} else {
__receiveState = _STATE_DATA;
}
}
} else {
__receiveState = _STATE_DATA;
}
break;
case _STATE_IAC:
switch(ch) {
case TelnetCommand.WILL:
__receiveState = _STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState = _STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState = _STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState = _STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count = 0;
__receiveState = _STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState = _STATE_DATA;
break;
case // unexpected byte! ignore it (don't send it as a command)
TelnetCommand.SE:
__receiveState = _STATE_DATA;
continue;
default:
__receiveState = _STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case _STATE_SB:
switch(ch) {
case TelnetCommand.IAC:
__receiveState = _STATE_IAC_SB;
continue;
default:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
}
__receiveState = _STATE_SB;
continue;
case // IAC received during SB phase
_STATE_IAC_SB:
switch(ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption, __suboption_count);
__client._flushOutputStream();
}
__receiveState = _STATE_DATA;
continue;
case // De-dup the duplicated IAC
TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++] = ch;
}
break;
default:
// unexpected byte! ignore it
break;
}
__receiveState = _STATE_SB;
continue;
}
break;
}
return ch;
}",0,False
280,"public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0,False
281,"public int[] startSubnegotiationLocal() {
return null;
}",0,False
282,"@Override
public DatagramPacket newDatagram() {
byte[] data;
int length;
length = _message.length();
data = new byte[length + 5];
data[0] = 0;
data[1] = (byte) _type;
data[2] = (byte) ((_error & 0xffff) >> 8);
data[3] = (byte) (_error & 0xff);
System.arraycopy(_message.getBytes(), 0, data, 4, length);
data[length + 4] = 0;
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
283,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0,False
284,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
285,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0,False
286,"private static String newStringUtf8(byte[] encode) {
String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
}",0,False
287,"@Deprecated
public int getAddressCount() {
long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int) countLong;
}",0,False
288,"public PrintCommandListener(PrintStream stream) {
this(new PrintWriter(stream));
}",0,False
289,"public PrintCommandListener(PrintStream stream, boolean suppressLogin) {
this(new PrintWriter(stream), suppressLogin);
}",0,False
290,"public String[] doCommandAsStrings(String command, String params) throws IOException {
boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));
if (success) {
return getReplyStrings();
} else {
return null;
}
}",0,False
291,"private void readStream(InputStream stream, String encoding) throws IOException {
BufferedReader reader;
if (encoding == null) {
reader = new BufferedReader(new InputStreamReader(stream));
} else {
reader = new BufferedReader(new InputStreamReader(stream, encoding));
}
String line = this.parser.readNextEntry(reader);
while (line != null) {
this.entries.add(line);
line = this.parser.readNextEntry(reader);
}
reader.close();
}",0,False
292,"public int execENC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_ENC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_ENC, """");
}
}",0,False
293,"public int execMIC(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_MIC, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_MIC, """");
}
}",0,False
294,"public int execCONF(byte[] data) throws IOException {
if (data != null) {
return sendCommand(CMD_CONF, new String(Base64.encodeBase64(data)));
} else {
return sendCommand(CMD_CONF, """");
}
}",0,False
295,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
296,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
297,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
298,"private boolean parseUnixList(FTPFile file, String entry) {
file = unixFTPEntryParser.parseFTPEntry(entry);
if (file == null) {
return false;
}
return true;
}",0,False
299,"public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE, method.getAuthName()))) {
return false;
}
switch(method) {
case PLAIN:
{
int result = sendData(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case CRAM_MD5:
{
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
int result = sendData(new String(Base64.encodeBase64(toEncode)));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
case LOGIN:
{
if (sendData(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT) {
return false;
}
int result = sendData(new String(Base64.encodeBase64(password.getBytes())));
if (result == IMAPReply.OK) {
setState(IMAP.IMAPState.AUTH_STATE);
}
return result == IMAPReply.OK;
}
}
return false;
}",0,False
300,"public IMAP() {
setDefaultPort(DEFAULT_PORT);
__state = IMAPState.DISCONNECTED_STATE;
_reader = null;
__writer = null;
_replyLines = new ArrayList<String>();
createCommandSupport();
}",0,False
301,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
302,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
}",0,False
303,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
304,"public String[] listOverviewFmt() throws IOException {
if (!NNTPReply.isPositiveCompletion(sendCommand(""LIST"", ""OVERVIEW.FMT""))) {
return null;
}
BufferedReader reader = new DotTerminatedMessageReader(_reader_);
String line;
ArrayList<String> list = new ArrayList<String>();
while ((line = reader.readLine()) != null) {
list.add(line);
}
reader.close();
return list.toArray(new String[list.size()]);
}",0,False
305,"void flush() {
if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}",0,False
306,"private ThreadContainer findRootSet() {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",0,False
307,"public POP3MessageInfo[] listMessages() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.LIST) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseStatus(en.next());
}
return messages;
}",0,False
308,"public POP3MessageInfo[] listUniqueIdentifiers() throws IOException {
if (getState() != TRANSACTION_STATE) {
return null;
}
if (sendCommand(POP3Command.UIDL) != POP3Reply.OK) {
return null;
}
getAdditionalReply();
POP3MessageInfo[] messages = new POP3MessageInfo[_replyLines.size() - 2];
ListIterator<String> en = _replyLines.listIterator(1);
for (int line = 0; line < messages.length; line++) {
messages[line] = __parseUID(en.next());
}
return messages;
}",0,False
309,public int size;,0,False
310,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
}",0,False
311,"public boolean auth(AuthenticatingSMTPClient.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (!SMTPReply.isPositiveIntermediate(sendCommand(SMTPCommand.AUTH, AUTH_METHOD.getAuthName(method)))) {
return false;
}
if (method.equals(AUTH_METHOD.PLAIN)) {
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))));
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(4).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(toEncode))));
} else if (method.equals(AUTH_METHOD.LOGIN)) {
if (!SMTPReply.isPositiveIntermediate(sendCommand(new String(Base64.encodeBase64(username.getBytes()))))) {
return false;
}
return SMTPReply.isPositiveCompletion(sendCommand(new String(Base64.encodeBase64(password.getBytes()))));
} else {
return false;
}
}",0,False
312,"public String[] getEnabledCipherSuites() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledCipherSuites();
}
return null;
}",0,False
313,"public String[] getEnabledProtocols() {
if (_socket_ instanceof SSLSocket) {
return ((SSLSocket) _socket_).getEnabledProtocols();
}
return null;
}",0,False
314,"@Override
public int[] startSubnegotiationLocal() {
return null;
}",0,False
315,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0,False
316,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0,False
317,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0,False
318,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0,False
319,"@Override
public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e = __ioException;
__ioException = null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting = true;
__queue.wait();
__readIsWaiting = false;
} catch (InterruptedException e) {
throw new InterruptedIOException(""Fatal thread interruption during read."");
}
} else {
__readIsWaiting = true;
int ch;
boolean mayBlock = true;
do {
try {
if ((ch = __read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
} catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException = e;
__queue.notifyAll();
try {
__queue.wait(100);
} catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
} catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock = false;
} while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting = false;
}
continue;
} else {
int ch;
ch = __queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead = 0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}",0,False
320,"private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty = (__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
} catch (InterruptedException e) {
throw e;
}
} else {
throw new IllegalStateException(""Queue is full! Cannot process another character."");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail] = ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail = 0;
}
}
return bufferWasEmpty;
}",0,False
321,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0,False
322,"@Override
public int[] answerSubnegotiation(int[] suboptionData, int suboptionLength) {
return null;
}",0,False
323,"@Override
public int[] startSubnegotiationRemote() {
return null;
}",0,False
324,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",0,False
325,"@Override
public final DatagramPacket newDatagram() {
int fileLength, modeLength;
byte[] data;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data = new byte[fileLength + modeLength + 4];
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
return new DatagramPacket(data, data.length, _address, _port);
}",0,False
326,"@Override
final DatagramPacket _newDatagram(DatagramPacket datagram, byte[] data) {
int fileLength, modeLength;
fileLength = _filename.length();
modeLength = _modeBytes[_mode].length;
data[0] = 0;
data[1] = (byte) _type;
System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
data[fileLength + 2] = 0;
System.arraycopy(_modeBytes[_mode], 0, data, fileLength + 3, modeLength);
datagram.setAddress(_address);
datagram.setPort(_port);
datagram.setData(data);
datagram.setLength(fileLength + modeLength + 3);
return datagram;
}",0,False
327,"private byte[] getBytesUtf8(String pArray) {
try {
return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",0,False
328,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
329,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0,False
330,"public Object decode(Object pObject) {
if (pObject instanceof byte[]) {
return decode((byte[]) pObject);
} else if (pObject instanceof String) {
return decode((String) pObject);
} else {
throw new RuntimeException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
}
}",0,False
331,private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
332,"public FTPHTTPClient(String proxyHost, int proxyPort, String proxyUser, String proxyPass) {
this.proxyHost = proxyHost;
this.proxyPort = proxyPort;
this.proxyUsername = proxyUser;
this.proxyPassword = proxyPass;
try {
CRLF = ""\r\n"".getBytes(getControlEncoding());
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}",1,True
333,"public String toDateString() {
DateFormat formatter = null;
if (simpleFormatter != null) {
formatter = simpleFormatter.get();
}
if (formatter == null) {
formatter = new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);
formatter.setTimeZone(TimeZone.getDefault());
simpleFormatter = new SoftReference<DateFormat>(formatter);
}
Date ntpDate = getDate();
synchronized (formatter) {
return formatter.format(ntpDate);
}
}",1,False
334,public final String identifier;,0,False
335,"public NewsgroupInfo[] listNewsgroups() throws IOException {
if (!NNTPReply.isPositiveCompletion(list()))
return null;
return __readNewsgroupListing();
}",0,False
336,"final synchronized void _processAYTResponse() {
if (!aytFlag) {
synchronized (aytMonitor) {
aytFlag = true;
try {
aytMonitor.notifyAll();
} catch (IllegalMonitorStateException e) {
System.err.println(""Exception notifying:"" + e.getMessage());
}
}
}
}",1,False
337,"@Deprecated
public static String PROVIDER;",1,False
338,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
339,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1,True
340,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, _DEFAULT_ENCODING));
_writer = new BufferedWriter(new OutputStreamWriter(_output_, _DEFAULT_ENCODING));
}",0,False
341,"protected boolean _storeFile(String command, String remote, InputStream local) throws IOException {
Socket socket = _openDataConnection_(command, remote);
if (socket == null) {
return false;
}
final OutputStream output;
if (__fileType == ASCII_FILE_TYPE) {
output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
} else {
output = getBufferedOutputStream(socket.getOutputStream());
}
CSL csl = null;
if (__controlKeepAliveTimeout > 0) {
csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);
}
try {
Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), false);
} catch (IOException e) {
Util.closeQuietly(socket);
if (csl != null) {
csl.cleanUp();
}
throw e;
}
output.close();
socket.close();
if (csl != null) {
csl.cleanUp();
}
boolean ok = completePendingCommand();
return ok;
}",0,False
342,"public FTPFile parseFTPEntry(String entry) {
String[] parts = entry.split("" "", 2);
if (parts.length != 2) {
return null;
}
FTPFile file = new FTPFile();
file.setRawListing(entry);
file.setName(parts[1]);
String[] facts = parts[0].split("";"");
boolean hasUnixMode = parts[0].toLowerCase(Locale.ENGLISH).contains(""unix.mode="");
for (String fact : facts) {
String[] factparts = fact.split(""="");
if (factparts.length != 2) {
continue;
}
String factname = factparts[0].toLowerCase(Locale.ENGLISH);
String factvalue = factparts[1];
String valueLowerCase = factvalue.toLowerCase(Locale.ENGLISH);
if (""size"".equals(factname)) {
file.setSize(Long.parseLong(factvalue));
} else if (""sizd"".equals(factname)) {
file.setSize(Long.parseLong(factvalue));
} else if (""modify"".equals(factname)) {
SimpleDateFormat sdf;
if (factvalue.contains(""."")) {
sdf = new SimpleDateFormat(""yyyyMMddHHmmss.SSS"");
} else {
sdf = new SimpleDateFormat(""yyyyMMddHHmmss"");
}
GregorianCalendar gc = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
try {
gc.setTime(sdf.parse(factvalue));
} catch (ParseException e) {
}
file.setTimestamp(gc);
} else if (""type"".equals(factname)) {
Integer intType = TYPE_TO_INT.get(valueLowerCase);
if (intType == null) {
} else {
file.setType(intType.intValue());
}
} else if (factname.startsWith(""unix."")) {
String unixfact = factname.substring(""unix."".length()).toLowerCase(Locale.ENGLISH);
if (""group"".equals(unixfact)) {
file.setGroup(factvalue);
} else if (""owner"".equals(unixfact)) {
file.setUser(factvalue);
} else if (""mode"".equals(unixfact)) {
int off = factvalue.length() - 4;
for (int i = 1; i <= 3; i++) {
int ch = factvalue.charAt(off + i) - '0';
for (int p : UNIX_PERMS[ch]) {
file.setPermission(UNIX_GROUPS[i - 1], p, true);
}
}
file.setUser(factvalue);
}
} else if (!hasUnixMode && ""perm"".equals(factname)) {
for (char c : valueLowerCase.toCharArray()) {
switch(c) {
case 'a':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'c':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'd':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'e':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'f':
break;
case 'l':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION, true);
break;
case 'm':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'p':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
case 'r':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
case 'w':
file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
default:
return null;
}
}
}
}
return file;
}",0,False
343,private final Charset charset;,1,False
344,public final int number;,0,False
345,"public static void main(String[] args) throws Exception {
if (args.length == 0) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
}
CodeSource codeSource = Main.class.getProtectionDomain().getCodeSource();
Map<String, String> map = new HashMap<String, String>();
if (codeSource != null) {
final String sourceFile = codeSource.getLocation().getFile();
if (sourceFile.endsWith("".jar"")) {
if (args.length == 0) {
System.out.println(""\nClasses found in the jar:"");
}
JarFile jf = new JarFile(sourceFile);
Enumeration<JarEntry> e = jf.entries();
while (e.hasMoreElements()) {
JarEntry je = e.nextElement();
String name = je.getName();
if (!name.endsWith("".class"") || name.contains(""$"") || name.equals(""examples/nntp/NNTPUtils.class"") || name.equals(""examples/util/IOUtil.class"") || name.equals(""examples/mail/IMAPUtils.class"") || name.equals(""examples/Main.class"")) {
continue;
}
name = name.replace("".class"", """");
int lastSep = name.lastIndexOf('/');
String alias = name.substring(lastSep + 1);
if (args.length == 0) {
System.out.printf(""%-25s %s%n"", alias, name);
}
map.put(alias, name);
}
jf.close();
}
}
if (args.length == 0) {
return;
}
String shortName = args[0];
String fullName = map.get(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
m.invoke(null, (Object) args2);
}",1,False
346,"public boolean auth(ExtendedPOP3Client.AUTH_METHOD method, String username, String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
if (sendCommand(authCommand + "" "" + AUTH_METHOD.getAuthName(method)) != POP3Reply.OK_INT)
return false;
if (method.equals(AUTH_METHOD.PLAIN)) {
return sendCommand(new String(Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes()))) == POP3Reply.OK;
} else if (method.equals(AUTH_METHOD.CRAM_MD5)) {
byte[] serverChallenge = Base64.decodeBase64(getReplyString().substring(2).trim());
Mac hmac_md5 = Mac.getInstance(""HmacMD5"");
hmac_md5.init(new SecretKeySpec(password.getBytes(), ""HmacMD5""));
// compute the result:
byte[] hmacResult = _convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();
byte[] usernameBytes = username.getBytes();
byte[] toEncode = new byte[usernameBytes.length + 1 + hmacResult.length];
System.arraycopy(usernameBytes, 0, toEncode, 0, usernameBytes.length);
toEncode[usernameBytes.length] = ' ';
System.arraycopy(hmacResult, 0, toEncode, usernameBytes.length + 1, hmacResult.length);
// send the reply and read the server code:
return sendCommand(new String(Base64.encodeBase64(toEncode))) == POP3Reply.OK;
} else
return false;
}",0,False
347,"@Override
public FTPFile parseFTPEntry(String entry) {
FTPFile file = new FTPFile();
file.setRawListing(entry);
int type;
boolean isDevice = false;
if (matches(entry)) {
String typeStr = group(1);
String hardLinkCount = ""0"";
String usr = null;
String grp = null;
String filesize = group(20);
String datestr = group(21) + "" "" + group(22);
String name = group(23);
String endtoken = group(24);
try {
file.setTimestamp(super.parseTimestamp(datestr));
} catch (ParseException e) {
}
switch(typeStr.charAt(0)) {
case 'd':
type = FTPFile.DIRECTORY_TYPE;
break;
case 'e':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'l':
type = FTPFile.SYMBOLIC_LINK_TYPE;
break;
case 'b':
case 'c':
isDevice = true;
type = FTPFile.FILE_TYPE;
break;
case 'f':
case '-':
type = FTPFile.FILE_TYPE;
break;
default:
// e.g. ? and w = whiteout
type = FTPFile.UNKNOWN_TYPE;
}
file.setType(type);
int g = 4;
for (int access = 0; access < 3; access++, g += 4) {
file.setPermission(access, FTPFile.READ_PERMISSION, (!group(g).equals(""-"")));
file.setPermission(access, FTPFile.WRITE_PERMISSION, (!group(g + 1).equals(""-"")));
String execPerm = group(g + 2);
if (!execPerm.equals(""-"") && !Character.isUpperCase(execPerm.charAt(0))) {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, true);
} else {
file.setPermission(access, FTPFile.EXECUTE_PERMISSION, false);
}
}
if (!isDevice) {
try {
file.setHardLinkCount(Integer.parseInt(hardLinkCount));
} catch (NumberFormatException e) {
}
}
file.setUser(usr);
file.setGroup(grp);
try {
file.setSize(Long.parseLong(filesize));
} catch (NumberFormatException e) {
}
if (null == endtoken) {
file.setName(name);
} else {
name += endtoken;
if (type == FTPFile.SYMBOLIC_LINK_TYPE) {
int end = name.indexOf("" -> "");
if (end == -1) {
file.setName(name);
} else {
file.setName(name.substring(0, end));
file.setLink(name.substring(end + 4));
}
} else {
file.setName(name);
}
}
return file;
}
return null;
}",0,False
348,"public static void main(String[] args) throws Throwable {
CodeSource codeSource = Main.class.getProtectionDomain().getCodeSource();
Map<String, String> map = new HashMap<String, String>();
final boolean noArgsProvided = args.length == 0;
if (codeSource != null) {
final String sourceFile = codeSource.getLocation().getFile();
if (sourceFile.endsWith("".jar"")) {
if (noArgsProvided) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
System.out.println(""\nClasses found in the jar:"");
}
JarFile jf = new JarFile(sourceFile);
Enumeration<JarEntry> e = jf.entries();
while (e.hasMoreElements()) {
JarEntry je = e.nextElement();
String name = je.getName();
processFileName(name, map, noArgsProvided);
}
jf.close();
} else {
if (noArgsProvided) {
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<exampleClass>,<exampleClass parameters>"");
System.out.println(""\nClasses found in the jar:"");
}
File examples = new File(sourceFile, ""examples"");
if (examples.exists()) {
scanForClasses(sourceFile.length(), examples, map, noArgsProvided);
}
}
} else {
if (noArgsProvided) {
System.out.println(""Usage: java -jar commons-net-examples-m.n.jar <exampleClass> <exampleClass parameters>"");
}
}
if (noArgsProvided) {
return;
}
String shortName = args[0];
String fullName = map.get(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[] { args.getClass() });
String[] args2 = new String[args.length - 1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object) args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}",0,False
349,"private void performSSLNegotiation() throws IOException {
initSSLContext();
SSLSocketFactory ssf = context.getSocketFactory();
String ip = getRemoteAddress().getHostAddress();
int port = getRemotePort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, ip, port, true);
socket.setEnableSessionCreation(true);
socket.setUseClientMode(true);
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_input_ = socket.getInputStream();
_output_ = socket.getOutputStream();
_reader = new CRLFLineReader(new InputStreamReader(_input_, __DEFAULT_ENCODING));
__writer = new BufferedWriter(new OutputStreamWriter(_output_, __DEFAULT_ENCODING));
}",0,False
350,"public String[] listNames(String pathname) throws IOException {
String line;
Socket socket;
BufferedReader reader;
ArrayList<String> results;
if ((socket = _openDataConnection_(FTPCommand.NLST, getListArguments(pathname))) == null)
return null;
reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
results = new ArrayList<String>();
while ((line = reader.readLine()) != null) results.add(line);
reader.close();
socket.close();
if (completePendingCommand()) {
String[] names = new String[results.size()];
return results.toArray(names);
}
return null;
}",0,False
351,"public static X509TrustManager getDefaultTrustManager() throws NoSuchAlgorithmException {
return (X509TrustManager) TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
}",1,True
352,public int size;,0,False
353,"public String toUTCString() {
DateFormat formatter = null;
if (utcFormatter != null)
formatter = utcFormatter.get();
if (formatter == null) {
formatter = new SimpleDateFormat(NTP_DATE_FORMAT + "" 'UTC'"", Locale.US);
formatter.setTimeZone(TimeZone.getTimeZone(""UTC""));
utcFormatter = new SoftReference<DateFormat>(formatter);
}
Date ntpDate = getDate();
synchronized (formatter) {
return formatter.format(ntpDate);
}
}",1,False
354,"protected void sslNegotiation() throws IOException {
plainSocket = _socket_;
initSslContext();
SSLSocketFactory ssf = context.getSocketFactory();
String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
int port = _socket_.getPort();
SSLSocket socket = (SSLSocket) ssf.createSocket(_socket_, host, port, false);
socket.setEnableSessionCreation(isCreation);
socket.setUseClientMode(isClientMode);
if (isClientMode) {
if (tlsEndpointChecking) {
SSLSocketUtils.enableEndpointNameVerification(socket);
}
} else {
socket.setNeedClientAuth(isNeedClientAuth);
socket.setWantClientAuth(isWantClientAuth);
}
if (protocols != null) {
socket.setEnabledProtocols(protocols);
}
if (suites != null) {
socket.setEnabledCipherSuites(suites);
}
socket.startHandshake();
_socket_ = socket;
_controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));
_controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), getControlEncoding()));
if (isClientMode) {
if (hostnameVerifier != null && !hostnameVerifier.verify(host, socket.getSession())) {
throw new SSLHandshakeException(""Hostname doesn't match certificate"");
}
}
}",1,True
355,"public void sendFile(String filename, int mode, InputStream input, InetAddress host, int port) throws IOException {
int bytesRead, timeouts, lastBlock, block, hostPort, dataLength, offset, totalThisPacket;
TFTPPacket sent, received = null;
TFTPErrorPacket error;
TFTPDataPacket data = new TFTPDataPacket(host, port, 0, _sendBuffer, 4, 0);
TFTPAckPacket ack;
boolean justStarted = true;
beginBufferedOps();
dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
totalBytesSent = 0L;
block = 0;
boolean lastAckWait = false;
if (mode == TFTP.ASCII_MODE) {
input = new ToNetASCIIInputStream(input);
}
sent = new TFTPWriteRequestPacket(host, port, filename, mode);
_sendPacket: do {
// first time: block is 0, lastBlock is 0, send a request packet.
// subsequent: block is integer starting at 1, send data packet.
bufferedSend(sent);
_receivePacket: while (true) {
timeouts = 0;
do {
try {
received = bufferedReceive();
break;
} catch (SocketException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (InterruptedIOException e) {
if (++timeouts >= __maxTimeouts) {
endBufferedOps();
throw new IOException(""Connection timed out."");
}
continue _sendPacket;
} catch (TFTPPacketException e) {
endBufferedOps();
throw new IOException(""Bad packet: "" + e.getMessage());
}
} while (timeouts < __maxTimeouts);
if (justStarted) {
justStarted = false;
hostPort = received.getPort();
data.setPort(hostPort);
if (!host.equals(received.getAddress())) {
host = received.getAddress();
data.setAddress(host);
sent.setAddress(host);
}
}
if (host.equals(received.getAddress()) && received.getPort() == hostPort) {
switch(received.getType()) {
case TFTPPacket.ERROR:
error = (TFTPErrorPacket) received;
endBufferedOps();
throw new IOException(""Error code "" + error.getError() + "" received: "" + error.getMessage());
case TFTPPacket.ACKNOWLEDGEMENT:
ack = (TFTPAckPacket) received;
lastBlock = ack.getBlockNumber();
if (lastBlock == block) {
++block;
if (block > 65535) {
block = 0;
}
if (lastAckWait) {
break _sendPacket;
} else {
break _receivePacket;
}
} else {
discardPackets();
continue _receivePacket;
}
default:
endBufferedOps();
throw new IOException(""Received unexpected packet type."");
}
} else {
error = new TFTPErrorPacket(received.getAddress(), received.getPort(), TFTPErrorPacket.UNKNOWN_TID, ""Unexpected host or port."");
bufferedSend(error);
continue _sendPacket;
}
}
dataLength = TFTPPacket.SEGMENT_SIZE;
offset = 4;
totalThisPacket = 0;
while (dataLength > 0 && (bytesRead = input.read(_sendBuffer, offset, dataLength)) > 0) {
offset += bytesRead;
dataLength -= bytesRead;
totalThisPacket += bytesRead;
}
if (totalThisPacket < TFTPPacket.SEGMENT_SIZE) {
lastAckWait = true;
}
data.setBlockNumber(block);
data.setData(_sendBuffer, 4, totalThisPacket);
sent = data;
totalBytesSent += totalThisPacket;
} while (totalThisPacket > 0 || lastAckWait);
// Note: this was looping while dataLength == 0 || lastAckWait,
endBufferedOps();
}",1,False
356,"public FTPListParseEngine initiateListParsing(String pathname) throws IOException {
String key = null;
return initiateListParsing(key, pathname);
}",1,True
357,"private ThreadContainer findRootSet(HashMap<String, ThreadContainer> idTable) {
ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
}",1,False
358,"private void buildContainer(Threadable threadable, HashMap<String, ThreadContainer> idTable) {
String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) {
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references) {
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null) && (ref.parent == null) && (parentRef != ref) && !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null && (parentRef == container || container.findChild(parentRef))) {
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child; rest != null; prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(""Didnt find "" + container + "" in parent"" + container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}",1,False
