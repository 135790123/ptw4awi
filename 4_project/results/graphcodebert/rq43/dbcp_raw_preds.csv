Unnamed: 0,source,target,raw_preds
0,"@Override
public synchronized String getUrl() {
return this.url;
}",0,False
1,"@Override
public String getUsername() {
return this.userName;
}",0,False
2,private boolean closed;,0,False
3,"@Override
public byte[] getBytes(final String parameterName) throws SQLException {
checkOpen();
try {
return getDelegateCallableStatement().getBytes(parameterName);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
4,"@Override
public byte[] getBytes(final String columnName) throws SQLException {
try {
return resultSet.getBytes(columnName);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
5,"@Override
public boolean execute(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0,False
6,"@Override
public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0,False
7,"@Override
public long executeLargeUpdate(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
8,"@Override
public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
9,"@Override
public boolean execute(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0,False
10,"@Override
public void addBatch(final String sql) throws SQLException {
checkOpen();
try {
statement.addBatch(sql);
} catch (final SQLException e) {
handleException(e);
}
}",0,False
11,"@Override
public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
12,"@Override
public long[] executeLargeBatch() throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeBatch();
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
13,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, columnIndexes);
}",0,False
14,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, columnNames);
}",0,False
15,"public void validate(final String sql, int timeoutSeconds) throws SQLException {
if (fastFailValidation && fatalSqlExceptionThrown) {
throw new SQLException(Utils.getMessage(""poolableConnection.validate.fastFail""));
}
if (sql == null || sql.isEmpty()) {
if (timeoutSeconds < 0) {
timeoutSeconds = 0;
}
if (!isValid(timeoutSeconds)) {
throw new SQLException(""isValid() returned false"");
}
return;
}
if (!sql.equals(lastValidationSql)) {
lastValidationSql = sql;
validationPreparedStatement = getInnermostDelegateInternal().prepareStatement(sql);
}
if (timeoutSeconds > 0) {
validationPreparedStatement.setQueryTimeout(timeoutSeconds);
}
try (ResultSet rs = validationPreparedStatement.executeQuery()) {
if (!rs.next()) {
throw new SQLException(""validationQuery didn't return a row"");
}
} catch (final SQLException sqle) {
throw sqle;
}
}",0,False
16,"public void validateConnection(final PoolableConnection conn) throws SQLException {
if (conn.isClosed()) {
throw new SQLException(""validateConnection: connection closed"");
}
conn.validate(validationQuery, validationQueryTimeoutSeconds);
}",0,False
17,public static final Set<String> DISCONNECTION_SQL_CODES;,0,False
18,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
19,"@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnNames));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
20,"@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
21,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
22,"@Override
public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnIndexes));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
23,"PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
}
try {
return pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0,False
24,"PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
}
try {
return pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0,False
25,"PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, columnNames);
}
try {
return pStmtPool.borrowObject(createKey(sql, columnNames));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0,False
26,"@Override
public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
try {
validateLifetime(pooledObject);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pconn = pooledObject.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pconn);
if (null == validationQuery) {
int timeoutSeconds = validationQueryTimeoutSeconds;
if (timeoutSeconds < 0) {
timeoutSeconds = 0;
}
try {
conn = pconn.getConnection();
valid = conn.isValid(timeoutSeconds);
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pconn);
try {
conn = pconn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly(rset);
Utils.closeQuietly(stmt);
Utils.closeQuietly(conn);
validatingSet.remove(pconn);
}
}
return valid;
}",0,False
27,"@Override
public synchronized void rollback(final Xid xid) throws XAException {
Objects.requireNonNull(xid, ""xid is null"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
try {
connection.rollback();
} catch (final SQLException e) {
throw (XAException) new XAException().initCause(e);
} finally {
try {
connection.setAutoCommit(originalAutoCommit);
} catch (final SQLException e) {
}
this.currentXid = null;
}
}",0,False
28,"@Override
public synchronized void end(final Xid xid, final int flag) throws XAException {
Objects.requireNonNull(xid, ""xid is null"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
}",0,False
29,"@Override
public synchronized String getUrl() {
return this.connectionString;
}",0,False
30,"static ConnectionFactory createConnectionFactory(final BasicDataSource basicDataSource, final Driver driver) throws SQLException {
final Properties connectionProperties = basicDataSource.getConnectionProperties();
final String url = basicDataSource.getUrl();
final String user = basicDataSource.getUsername();
if (user != null) {
connectionProperties.put(Constants.KEY_USER, user);
} else {
basicDataSource.log(String.format(""DBCP DataSource configured without a '%s'"", Constants.KEY_USER));
}
final String pwd = basicDataSource.getPassword();
if (pwd != null) {
connectionProperties.put(Constants.KEY_PASSWORD, pwd);
} else {
basicDataSource.log(String.format(""DBCP DataSource configured without a '%s'"", Constants.KEY_PASSWORD));
}
final String connectionFactoryClassName = basicDataSource.getConnectionFactoryClassName();
if (connectionFactoryClassName != null) {
try {
final Class<?> connectionFactoryFromCCL = Class.forName(connectionFactoryClassName);
return (ConnectionFactory) connectionFactoryFromCCL.getConstructor(Driver.class, String.class, Properties.class).newInstance(driver, url, connectionProperties);
} catch (final Exception t) {
final String message = ""Cannot load ConnectionFactory implementation '"" + connectionFactoryClassName + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
return new DriverConnectionFactory(driver, url, connectionProperties);
}",0,False
31,"@Override
public byte[] getBytes(final int parameterIndex) throws SQLException {
checkOpen();
try {
return getDelegateCallableStatement().getBytes(parameterIndex);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
32,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
33,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
34,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnNames)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
35,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
36,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnIndexes)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
37,"@Override
public byte[] getBytes(final int columnIndex) throws SQLException {
try {
return resultSet.getBytes(columnIndex);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
38,"@Override
public byte[] getBytes(final String columnName) throws SQLException {
try {
return resultSet.getBytes(columnName);
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
39,"@Override
public void addBatch(final String sql) throws SQLException {
checkOpen();
try {
statement.addBatch(sql);
} catch (final SQLException e) {
handleException(e);
}
}",0,False
40,"static Driver createDriver(final BasicDataSource basicDataSource) throws SQLException {
Driver driverToUse = basicDataSource.getDriver();
final String driverClassName = basicDataSource.getDriverClassName();
final ClassLoader driverClassLoader = basicDataSource.getDriverClassLoader();
final String url = basicDataSource.getUrl();
if (driverToUse == null) {
Class<?> driverFromCCL = null;
if (driverClassName != null) {
try {
try {
if (driverClassLoader == null) {
driverFromCCL = Class.forName(driverClassName);
} else {
driverFromCCL = Class.forName(driverClassName, true, driverClassLoader);
}
} catch (final ClassNotFoundException cnfe) {
driverFromCCL = Thread.currentThread().getContextClassLoader().loadClass(driverClassName);
}
} catch (final Exception t) {
final String message = ""Cannot load JDBC driver class '"" + driverClassName + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
try {
if (driverFromCCL == null) {
driverToUse = DriverManager.getDriver(url);
} else {
driverToUse = (Driver) driverFromCCL.getConstructor().newInstance();
if (!driverToUse.acceptsURL(url)) {
throw new SQLException(""No suitable driver"", ""08001"");
}
}
} catch (final Exception t) {
final String message = ""Cannot create JDBC driver of class '"" + (driverClassName != null ? driverClassName : """") + ""' for connect URL '"" + url + ""'"";
basicDataSource.log(message, t);
throw new SQLException(message, t);
}
}
return driverToUse;
}",0,False
41,"public void validate(final String sql, Duration timeoutDuration) throws SQLException {
if (fastFailValidation && fatalSqlExceptionThrown) {
throw new SQLException(Utils.getMessage(""poolableConnection.validate.fastFail""));
}
if (sql == null || sql.isEmpty()) {
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
if (!isValid(timeoutDuration)) {
throw new SQLException(""isValid() returned false"");
}
return;
}
if (!sql.equals(lastValidationSql)) {
lastValidationSql = sql;
validationPreparedStatement = getInnermostDelegateInternal().prepareStatement(sql);
}
if (timeoutDuration.compareTo(Duration.ZERO) > 0) {
validationPreparedStatement.setQueryTimeout((int) timeoutDuration.getSeconds());
}
try (ResultSet rs = validationPreparedStatement.executeQuery()) {
if (!rs.next()) {
throw new SQLException(""validationQuery didn't return a row"");
}
} catch (final SQLException sqle) {
throw sqle;
}
}",0,False
42,"protected static final HashMap<String, ObjectPool<? extends Connection>> pools = new HashMap<>();",0,False
43,"@Deprecated
public static final Set<String> DISCONNECTION_SQL_CODES;",0,False
44,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
45,"@Override
public boolean validateObject(final PooledObject<PooledConnectionAndInfo> p) {
try {
validateLifetime(p);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pconn = p.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pconn);
if (null == validationQuery) {
Duration timeoutDuration = validationQueryTimeoutDuration;
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
try {
conn = pconn.getConnection();
valid = conn.isValid((int) timeoutDuration.getSeconds());
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pconn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pconn);
try {
conn = pconn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) rset);
Utils.closeQuietly((AutoCloseable) stmt);
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pconn);
}
}
return valid;
}",0,False
46,"@Override
public Connection getConnection(final String userName, final String userPassword) throws SQLException {
if (instanceKey == null) {
throw new SQLException(""Must set the ConnectionPoolDataSource "" + ""through setDataSourceName or setConnectionPoolDataSource"" + "" before calling getConnection."");
}
getConnectionCalled = true;
PooledConnectionAndInfo info = null;
try {
info = getPooledConnectionAndInfo(userName, userPassword);
} catch (final RuntimeException | SQLException e) {
closeDueToException(info);
throw e;
} catch (final Exception e) {
closeDueToException(info);
throw new SQLException(""Cannot borrow connection from pool"", e);
}
if (!(null == userPassword ? null == info.getPassword() : userPassword.equals(info.getPassword()))) {
try {
testCPDS(userName, userPassword);
} catch (final SQLException ex) {
closeDueToException(info);
throw new SQLException(""Given password did not match password used"" + "" to create the PooledConnection."", ex);
} catch (final javax.naming.NamingException ne) {
throw new SQLException(""NamingException encountered connecting to database"", ne);
}
final UserPassKey upkey = info.getUserPassKey();
final PooledConnectionManager manager = getConnectionManager(upkey);
manager.invalidate(info.getPooledConnection());
manager.setPassword(upkey.getPassword());
info = null;
for (int i = 0; i < 10; i++) {
try {
info = getPooledConnectionAndInfo(userName, userPassword);
} catch (final RuntimeException | SQLException e) {
closeDueToException(info);
throw e;
} catch (final Exception e) {
closeDueToException(info);
throw new SQLException(""Cannot borrow connection from pool"", e);
}
if (info != null && userPassword != null && userPassword.equals(info.getPassword())) {
break;
}
if (info != null) {
manager.invalidate(info.getPooledConnection());
}
info = null;
}
if (info == null) {
throw new SQLException(""Cannot borrow connection from pool - password change failure."");
}
}
final Connection connection = info.getPooledConnection().getConnection();
try {
setupDefaults(connection, userName);
connection.clearWarnings();
return connection;
} catch (final SQLException ex) {
Utils.close(connection, e -> getLogWriter().println(""ignoring exception during close: "" + e));
throw ex;
}
}",0,False
47,"@Override
public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
try {
validateLifetime(pooledObject);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pooledConn = pooledObject.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pooledConn);
if (null == validationQuery) {
Duration timeoutDuration = validationQueryTimeoutDuration;
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
try {
conn = pooledConn.getConnection();
valid = conn.isValid((int) timeoutDuration.getSeconds());
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pooledConn);
try {
conn = pooledConn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) rset);
Utils.closeQuietly((AutoCloseable) stmt);
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
}
return valid;
}",0,False
48,"@Override
public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
try {
validateLifetime(pooledObject);
} catch (final Exception e) {
return false;
}
boolean valid = false;
final PooledConnection pooledConn = pooledObject.getObject().getPooledConnection();
Connection conn = null;
validatingSet.add(pooledConn);
if (null == validationQuery) {
Duration timeoutDuration = validationQueryTimeoutDuration;
if (timeoutDuration.isNegative()) {
timeoutDuration = Duration.ZERO;
}
try {
conn = pooledConn.getConnection();
valid = conn.isValid((int) timeoutDuration.getSeconds());
} catch (final SQLException e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
} else {
Statement stmt = null;
ResultSet rset = null;
validatingSet.add(pooledConn);
try {
conn = pooledConn.getConnection();
stmt = conn.createStatement();
rset = stmt.executeQuery(validationQuery);
valid = rset.next();
if (rollbackAfterValidation) {
conn.rollback();
}
} catch (final Exception e) {
valid = false;
} finally {
Utils.closeQuietly((AutoCloseable) rset);
Utils.closeQuietly((AutoCloseable) stmt);
Utils.closeQuietly((AutoCloseable) conn);
validatingSet.remove(pooledConn);
}
}
return valid;
}",0,False
49,"public void clear() {
for (final PooledConnectionManager manager : managers.values()) {
try {
getCPDSConnectionFactoryPool(manager).clear();
} catch (final Exception ignored) {
}
}
InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
}",0,False
50,"@Override
public synchronized void end(final Xid xid, final int flag) throws XAException {
Objects.requireNonNull(xid, ""xid"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
}",0,False
51,"@Deprecated
public static void closeQuietly(final Statement statement) {
if (statement != null) {
try {
statement.close();
} catch (final Exception e) {
}
}
}",0,False
52,"@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency));
initializeStatement(dps);
return dps;
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
53,"public void invalidateConnection(final Connection conn) throws SQLException {
if (conn instanceof PoolGuardConnectionWrapper) {
final PoolGuardConnectionWrapper pgconn = (PoolGuardConnectionWrapper) conn;
@SuppressWarnings(""unchecked"")
final ObjectPool<Connection> pool = (ObjectPool<Connection>) pgconn.pool;
try {
pool.invalidateObject(pgconn.getDelegateInternal());
} catch (final Exception e) {
}
} else {
throw new SQLException(""Invalid connection class"");
}
}",0,False
54,"@Override
protected void finalize() throws Throwable {
try {
connection.close();
} catch (final Exception ignored) {
}
if (logicalConnection != null && !logicalConnection.isClosed()) {
throw new SQLException(""PooledConnection was gc'ed, without its last Connection being closed."");
}
}",1,False
55,"@Override
public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
try {
return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, autoGeneratedKeys));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
56,"PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, autoGeneratedKeys);
}
try {
return pStmtPool.borrowObject(createKey(sql, autoGeneratedKeys));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0,False
57,"public static void closeQuietly(final AutoCloseable autoCloseable) {
if (autoCloseable != null) {
try {
autoCloseable.close();
} catch (final Exception ignored) {
}
}
}",1,False
58,"PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql, columnIndexes);
}
try {
return pStmtPool.borrowObject(createKey(sql, columnIndexes));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0,False
59,"public String[] getColumnNames() {
return columnNames;
}",1,False
60,"public void validateConnection(final PoolableConnection conn) throws SQLException {
if (conn.isClosed()) {
throw new SQLException(""validateConnection: connection closed"");
}
conn.validate(validationQuery, validationQueryTimeoutSeconds);
}",0,False
61,"@Override
public Statement createStatement(final Connection connection) throws SQLException {
return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue(), resultSetHoldability.intValue());
}",0,False
62,"@Override
public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
try {
final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this, connection.prepareStatement(sql, autoGeneratedKeys));
initializeStatement(dps);
return dps;
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
63,"public void setPassword(final char[] userPassword) {
this.userPassword = userPassword;
}",1,False
64,"@Override
public boolean execute(final String sql) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0,False
65,"private void validatePropertyNames(final Reference ref, final Name name, final List<String> warnings, final List<String> infoMessages) {
final List<String> allPropsAsList = Arrays.asList(ALL_PROPERTIES);
final String nameString = name != null ? ""Name = "" + name.toString() + "" "" : """";
if (NUPROP_WARNTEXT != null && !NUPROP_WARNTEXT.isEmpty()) {
for (final String propertyName : NUPROP_WARNTEXT.keySet()) {
final RefAddr ra = ref.get(propertyName);
if (ra != null && !allPropsAsList.contains(ra.getType())) {
final StringBuilder stringBuilder = new StringBuilder(nameString);
final String propertyValue = ra.getContent().toString();
stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append("" You have set value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property, which is being ignored."");
warnings.add(stringBuilder.toString());
}
}
}
final Enumeration<RefAddr> allRefAddrs = ref.getAll();
while (allRefAddrs.hasMoreElements()) {
final RefAddr ra = allRefAddrs.nextElement();
final String propertyName = ra.getType();
if (!(allPropsAsList.contains(propertyName) || NUPROP_WARNTEXT.containsKey(propertyName) || SILENT_PROPERTIES.contains(propertyName))) {
final String propertyValue = ra.getContent().toString();
final StringBuilder stringBuilder = new StringBuilder(nameString);
stringBuilder.append(""Ignoring unknown property: "").append(""value of \"""").append(propertyValue).append(""\"" for \"""").append(propertyName).append(""\"" property"");
infoMessages.add(stringBuilder.toString());
}
}
}",0,True
66,"PreparedStatement prepareStatement(final String sql) throws SQLException {
if (pStmtPool == null) {
return connection.prepareStatement(sql);
}
try {
return pStmtPool.borrowObject(createKey(sql));
} catch (final RuntimeException e) {
throw e;
} catch (final Exception e) {
throw new SQLException(""Borrow prepareStatement from pool failed"", e);
}
}",0,False
67,"@Override
public boolean execute(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.execute(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return false;
}
}",0,False
68,"protected void initializeConnection(final Connection conn) throws SQLException {
final Collection<String> sqls = connectionInitSqls;
if (conn.isClosed()) {
throw new SQLException(""initializeConnection: connection closed"");
}
if (null != sqls) {
try (Statement stmt = conn.createStatement()) {
for (final String sql : sqls) {
Objects.requireNonNull(sql, ""null connectionInitSqls element"");
stmt.execute(sql);
}
}
}
}",1,False
69,"public synchronized void setPool(final ObjectPool<PoolableConnection> pool) {
if (null != this.pool && pool != this.pool) {
try {
this.pool.close();
} catch (final Exception e) {
}
}
this.pool = pool;
}",0,False
70,"public char[] getUserPassword() {
return userPassword;
}",1,True
71,"@Override
public void close() throws SQLException {
if (isClosed()) {
return;
}
final List<Exception> thrownList = new ArrayList<>();
try {
if (connection != null) {
connection.removeTrace(this);
connection = null;
}
final List<AbandonedTrace> resultSetList = getTrace();
if (resultSetList != null) {
final int size = resultSetList.size();
final ResultSet[] resultSets = resultSetList.toArray(Utils.EMPTY_RESULT_SET_ARRAY);
for (final ResultSet resultSet : resultSets) {
if (resultSet != null) {
try {
resultSet.close();
} catch (final Exception e) {
if (connection != null) {
connection.handleExceptionNoThrow(e);
}
thrownList.add(e);
}
}
}
clearTrace();
}
if (statement != null) {
try {
statement.close();
} catch (final Exception e) {
if (connection != null) {
connection.handleExceptionNoThrow(e);
}
thrownList.add(e);
}
}
} finally {
closed = true;
statement = null;
if (!thrownList.isEmpty()) {
throw new SQLExceptionList(thrownList);
}
}
}",1,False
72,"@Override
public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, autoGeneratedKeys);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
73,"public int[] getColumnIndexes() {
return columnIndexes;
}",1,False
74,"private void closeConnectionPool() {
final GenericObjectPool<?> oldPool = connectionPool;
connectionPool = null;
try {
if (oldPool != null) {
oldPool.close();
}
} catch (final Exception e) {
}
}",1,False
75,"@Override
public long executeLargeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeUpdate(sql, columnIndexes);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
76,"@Override
public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeUpdate(sql, columnNames);
} catch (final SQLException e) {
handleException(e);
return 0;
}
}",0,False
77,"@Override
public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
checkOpen();
try {
final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnNames));
initializeStatement(dps);
return dps;
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
78,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, autoGeneratedKeys)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
79,"@Override
public synchronized void rollback(final Xid xid) throws XAException {
Objects.requireNonNull(xid, ""xid"");
if (!this.currentXid.equals(xid)) {
throw new XAException(""Invalid Xid: expected "" + this.currentXid + "", but was "" + xid);
}
try {
connection.rollback();
} catch (final SQLException e) {
throw (XAException) new XAException().initCause(e);
} finally {
try {
connection.setAutoCommit(originalAutoCommit);
} catch (final SQLException ignored) {
}
this.currentXid = null;
}
}",0,False
80,"@SuppressWarnings(""resource"")
@Override
public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
checkOpen();
try {
return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, resultSetType, resultSetConcurrency)));
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
81,"@Override
public void close() {
for (final PooledConnectionManager manager : managers.values()) {
try {
getCPDSConnectionFactoryPool(manager).close();
} catch (final Exception closePoolException) {
}
}
InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
}",0,True
82,"@Override
public long[] executeLargeBatch() throws SQLException {
checkOpen();
setLastUsedInParent();
try {
return statement.executeLargeBatch();
} catch (final SQLException e) {
handleException(e);
return null;
}
}",0,False
