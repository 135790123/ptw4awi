Unnamed: 0,source,target,raw_preds
0,"@Deprecated
public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",1,True
1,"@Override
public boolean equals(final Instruction i1, final Instruction i2) {
if (i1.getOpcode() == i2.getOpcode()) {
if (i1 instanceof BranchInstruction) {
return false;
} else if (i1 instanceof ConstantPushInstruction) {
return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());
} else if (i1 instanceof IndexedInstruction) {
return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();
} else if (i1 instanceof NEWARRAY) {
return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
} else {
return true;
}
}
return false;
}",0,False
2,"public ModuleProvides[] getProvidesTable() {
return provides_table;
}",0,False
3,"@Deprecated
public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0,False
4,"public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",1,False
5,"public ModuleOpens[] getOpensTable() {
return opens_table;
}",0,False
6,"@Deprecated
public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",0,False
7,"@Deprecated
public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1,False
8,"public void setConstantPool(final Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0,False
9,"@Deprecated
public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",1,False
10,"@Deprecated
public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0,False
11,"public final LocalVariable[] getLocalVariableTable() {
return local_variable_table;
}",0,False
12,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0,False
13,"public void setArgumentTypes(final Type[] arg_types) {
this.arg_types = arg_types;
}",0,False
14,"public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1,False
15,"@Deprecated
public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",1,False
16,"public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {
super(type, cpool);
if (type != ARRAY) {
throw new IllegalArgumentException(""Only element values of type array can be built with this ctor - type specified: "" + type);
}
this.evalues = datums;
}",0,False
17,"public LocalVariableTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {
super(Const.ATTR_LOCAL_VARIABLE_TABLE, name_index, length, constant_pool);
this.local_variable_table = local_variable_table;
}",0,False
18,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
19,"public LineNumber[] getLineNumberTable() {
return line_number_table;
}",0,False
20,"@Deprecated
public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0,False
21,"public BootstrapMethod(final int bootstrap_method_ref, final int[] bootstrap_arguments) {
this.bootstrap_method_ref = bootstrap_method_ref;
this.bootstrap_arguments = bootstrap_arguments;
}",0,False
22,"public final BootstrapMethod[] getBootstrapMethods() {
return bootstrap_methods;
}",0,False
23,"public ConstantPool(final Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0,False
24,"public void setLineNumberTable(final LineNumber[] line_number_table) {
this.line_number_table = line_number_table;
}",0,False
25,"@Deprecated
public static final String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0,True
26,"synchronized void classNamesJList_valueChanged(ListSelectionEvent e) {
if (e.getValueIsAdjusting()) {
return;
}
current_class = classNamesJList.getSelectedValue().toString();
try {
verify();
} catch (ClassNotFoundException ex) {
// FIXME: report the error using the GUI
ex.printStackTrace();
}
classNamesJList.setSelectedValue(current_class, true);
}",1,False
27,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.local_variable_table = local_variable_table;
}",0,False
28,"@Deprecated
public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",0,True
29,"@Deprecated
public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",1,False
30,"public final LocalVariable[] getLocalVariableTypeTable() {
return local_variable_type_table;
}",0,False
31,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Constants.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Constants.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Constants.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Constants.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Constants.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Constants.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Constants.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Constants.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Constants.CONSTANT_InterfaceMethodref:
case Constants.CONSTANT_Methodref:
case Constants.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Constants.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Constants.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Constants.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
32,"public String[] getInterfaceNames() {
return interface_names;
}",0,False
33,"@Deprecated
public static final String[] METHODHANDLE_NAMES = { """", ""getField"", ""getStatic"", ""putField"", ""putStatic"", ""invokeVirtual"", ""invokeStatic"", ""invokeSpecial"", ""newInvokeSpecial"", ""invokeInterface"" };",1,True
34,"public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
return parameter_annotation_table;
}",0,False
35,"public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",1,False
36,"@Deprecated
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"", ""LocalVariableTypeTable"", ""EnclosingMethod"", ""StackMapTable"", ""BootstrapMethods"", ""MethodParameters"" };",1,False
37,"public void setBootstrapArguments(final int[] bootstrap_arguments) {
this.bootstrap_arguments = bootstrap_arguments;
}",0,False
38,"@Deprecated
public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"", """", """", ""CONSTANT_MethodHandle"", ""CONSTANT_MethodType"", """", ""CONSTANT_InvokeDynamic"" };",0,True
39,"public ModuleRequires[] getRequiresTable() {
return requires_table;
}",0,False
40,"@Deprecated
public static final short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",1,False
41,"public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrap_methods, final ConstantPool constant_pool) {
super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);
this.bootstrap_methods = bootstrap_methods;
}",0,False
42,"public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table, final ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.line_number_table = line_number_table;
}",0,False
43,"public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",1,False
44,"@Deprecated
public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0,True
45,"@Deprecated
public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",1,True
46,"public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"", """", """", ""CONSTANT_MethodHandle"", ""CONSTANT_MethodType"", """", ""CONSTANT_InvokeDynamic"" };",1,True
47,"protected FieldOrMethod(DataInput file, ConstantPool constant_pool) throws IOException, ClassFormatException {
this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null, constant_pool);
int attributes_count = file.readUnsignedShort();
attributes = new Attribute[attributes_count];
for (int i = 0; i < attributes_count; i++) {
attributes[i] = Attribute.readAttribute(file, constant_pool);
}
this.attributes_count = attributes_count;
}",0,False
48,"public int[] getBootstrapArguments() {
return bootstrap_arguments;
}",0,False
49,"public final void setAnnotationTable(AnnotationEntry[] annotation_table) {
this.annotation_table = annotation_table;
}",0,False
50,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0,False
51,"public Annotations(byte annotation_type, int name_index, int length, AnnotationEntry[] annotation_table, ConstantPool constant_pool, boolean isRuntimeVisible) {
super(annotation_type, name_index, length, constant_pool);
this.annotation_table = annotation_table;
this.isRuntimeVisible = isRuntimeVisible;
}",0,False
52,"public ArrayElementValue(int type, ElementValue[] datums, ConstantPool cpool) {
super(type, cpool);
if (type != ARRAY) {
throw new RuntimeException(""Only element values of type array can be built with this ctor - type specified: "" + type);
}
this.evalues = datums;
}",0,False
53,"public static Attribute readAttribute(DataInput file, ConstantPool constant_pool) throws IOException, ClassFormatException {
byte tag = Const.ATTR_UNKNOWN;
int name_index = file.readUnsignedShort();
ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);
String name = c.getBytes();
int length = file.readInt();
for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++) {
if (name.equals(Const.getAttributeName(i))) {
tag = i;
break;
}
}
switch(tag) {
case Const.ATTR_UNKNOWN:
Object r = readers.get(name);
if (r instanceof UnknownAttributeReader) {
return ((UnknownAttributeReader) r).createAttribute(name_index, length, file, constant_pool);
}
return new Unknown(name_index, length, file, constant_pool);
case Const.ATTR_CONSTANT_VALUE:
return new ConstantValue(name_index, length, file, constant_pool);
case Const.ATTR_SOURCE_FILE:
return new SourceFile(name_index, length, file, constant_pool);
case Const.ATTR_CODE:
return new Code(name_index, length, file, constant_pool);
case Const.ATTR_EXCEPTIONS:
return new ExceptionTable(name_index, length, file, constant_pool);
case Const.ATTR_LINE_NUMBER_TABLE:
return new LineNumberTable(name_index, length, file, constant_pool);
case Const.ATTR_LOCAL_VARIABLE_TABLE:
return new LocalVariableTable(name_index, length, file, constant_pool);
case Const.ATTR_INNER_CLASSES:
return new InnerClasses(name_index, length, file, constant_pool);
case Const.ATTR_SYNTHETIC:
return new Synthetic(name_index, length, file, constant_pool);
case Const.ATTR_DEPRECATED:
return new Deprecated(name_index, length, file, constant_pool);
case Const.ATTR_PMG:
return new PMGClass(name_index, length, file, constant_pool);
case Const.ATTR_SIGNATURE:
return new Signature(name_index, length, file, constant_pool);
case Const.ATTR_STACK_MAP:
return new StackMap(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:
return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:
return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:
return new RuntimeVisibleParameterAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:
return new RuntimeInvisibleParameterAnnotations(name_index, length, file, constant_pool);
case Const.ATTR_ANNOTATION_DEFAULT:
return new AnnotationDefault(name_index, length, file, constant_pool);
case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:
return new LocalVariableTypeTable(name_index, length, file, constant_pool);
case Const.ATTR_ENCLOSING_METHOD:
return new EnclosingMethod(name_index, length, file, constant_pool);
case Const.ATTR_STACK_MAP_TABLE:
return new StackMap(name_index, length, file, constant_pool);
case Const.ATTR_BOOTSTRAP_METHODS:
return new BootstrapMethods(name_index, length, file, constant_pool);
case Const.ATTR_METHOD_PARAMETERS:
return new MethodParameters(name_index, length, file, constant_pool);
default:
throw new IllegalStateException(""Unrecognized attribute type tag parsed: "" + tag);
}
}",0,False
54,"public BootstrapMethod(int bootstrap_method_ref, int[] bootstrap_arguments) {
this.bootstrap_method_ref = bootstrap_method_ref;
this.bootstrap_arguments = bootstrap_arguments;
}",0,False
55,"public void setBootstrapArguments(int[] bootstrap_arguments) {
this.bootstrap_arguments = bootstrap_arguments;
}",0,False
56,"public final BootstrapMethod[] getBootstrapMethods() {
return bootstrap_methods;
}",0,False
57,"public final void setBootstrapMethods(BootstrapMethod[] bootstrap_methods) {
this.bootstrap_methods = bootstrap_methods;
}",0,False
58,"public BootstrapMethods(int name_index, int length, BootstrapMethod[] bootstrap_methods, ConstantPool constant_pool) {
super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);
this.bootstrap_methods = bootstrap_methods;
}",0,False
59,"public final Attribute[] getAttributes() {
return attributes;
}",0,False
60,"@Override
public Object getConstantValue(ConstantPool cp) {
return new Double(bytes);
}",0,False
61,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
62,"public void setConstantPool(Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0,False
63,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
64,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
65,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
66,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
67,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
68,"public final void setBytes(byte[] bytes) {
this.bytes = bytes;
}",0,False
69,"public Deprecated(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {
super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);
this.bytes = bytes;
}",0,False
70,"public final int[] getExceptionIndexTable() {
return exception_index_table;
}",0,False
71,"public final Attribute[] getAttributes() {
return attributes;
}",0,False
72,"public final InnerClass[] getInnerClasses() {
return inner_classes;
}",0,False
73,"public void setInterfaceNames(String[] interface_names) {
this.interface_names = interface_names;
}",0,False
74,"public Attribute[] getAttributes() {
return attributes;
}",0,False
75,"public void setAttributes(Attribute[] attributes) {
this.attributes = attributes;
}",0,False
76,"public AnnotationEntry[] getAnnotationEntries() {
if (annotations == null) {
annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotations;
}",0,False
77,"public Method[] getMethods() {
return methods;
}",0,False
78,"public int[] getInterfaceIndices() {
return interfaces;
}",0,False
79,"public LineNumberTable(int name_index, int length, LineNumber[] line_number_table, ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.line_number_table = line_number_table;
}",0,False
80,"public final void setLocalVariableTable(LocalVariable[] local_variable_table) {
this.local_variable_table = local_variable_table;
}",0,False
81,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
if (parameterAnnotationEntries == null) {
parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());
}
return parameterAnnotationEntries;
}",0,False
82,"public MethodParameter[] getParameters() {
return parameters;
}",0,False
83,"public void setParameters(MethodParameter[] parameters) {
this.parameters = parameters;
}",0,False
84,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
return parameter_annotation_table;
}",0,False
85,"final String getData() {
return new String(buf);
}",0,False
86,"public final void setStackMap(StackMapEntry[] map) {
this.map = map;
int len = 2;
for (int i = 0; i < map.length; i++) {
len += map[i].getMapEntrySize();
}
setLength(len);
}",0,False
87,"public Unknown(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {
super(Const.ATTR_UNKNOWN, name_index, length, constant_pool);
this.bytes = bytes;
name = ((ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8)).getBytes();
unknown_attributes.put(name, this);
}",0,False
88,"public static String codeToString(ByteSequence bytes, ConstantPool constant_pool, boolean verbose) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
System.err.println(""Unreachable default case reached!"");
System.exit(-1);
}
}
}
}
return buf.toString();
}",0,False
89,"static Attribute[] getParameterAnnotationAttributes(ConstantPoolGen cp, List<AnnotationEntryGen>[] vec) {
int[] visCount = new int[vec.length];
int totalVisCount = 0;
int[] invisCount = new int[vec.length];
int totalInvisCount = 0;
try {
for (int i = 0; i < vec.length; i++) {
if (vec[i] != null) {
for (AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
visCount[i]++;
totalVisCount++;
} else {
invisCount[i]++;
totalInvisCount++;
}
}
}
}
ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
rvaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
rvaDos.writeShort(visCount[i]);
if (visCount[i] > 0) {
for (AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
element.dump(rvaDos);
}
}
}
}
rvaDos.close();
ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
DataOutputStream riaDos = new DataOutputStream(riaBytes);
riaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
riaDos.writeShort(invisCount[i]);
if (invisCount[i] > 0) {
for (AnnotationEntryGen element : vec[i]) {
if (!element.isRuntimeVisible()) {
element.dump(riaDos);
}
}
}
}
riaDos.close();
byte[] rvaData = rvaBytes.toByteArray();
byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (totalVisCount > 0) {
rvaIndex = cp.addUtf8(""RuntimeVisibleParameterAnnotations"");
}
if (totalInvisCount > 0) {
riaIndex = cp.addUtf8(""RuntimeInvisibleParameterAnnotations"");
}
List<Attribute> newAttributes = new ArrayList<>();
if (totalVisCount > 0) {
newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (totalInvisCount > 0) {
newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (IOException e) {
System.err.println(""IOException whilst processing parameter annotations"");
e.printStackTrace();
}
return null;
}",0,False
90,"static Attribute[] getAnnotationAttributes(ConstantPoolGen cp, AnnotationEntryGen[] annotationEntryGens) {
if (annotationEntryGens.length == 0) {
return new Attribute[0];
}
try {
int countVisible = 0;
int countInvisible = 0;
for (AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
countVisible++;
} else {
countInvisible++;
}
}
ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
DataOutputStream riaDos = new DataOutputStream(riaBytes);
rvaDos.writeShort(countVisible);
riaDos.writeShort(countInvisible);
for (AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
a.dump(rvaDos);
} else {
a.dump(riaDos);
}
}
rvaDos.close();
riaDos.close();
byte[] rvaData = rvaBytes.toByteArray();
byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (rvaData.length > 2) {
rvaIndex = cp.addUtf8(""RuntimeVisibleAnnotations"");
}
if (riaData.length > 2) {
riaIndex = cp.addUtf8(""RuntimeInvisibleAnnotations"");
}
List<Attribute> newAttributes = new ArrayList<>();
if (rvaData.length > 2) {
newAttributes.add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (riaData.length > 2) {
newAttributes.add(new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (IOException e) {
System.err.println(""IOException whilst processing annotations"");
e.printStackTrace();
}
return null;
}",0,False
91,"public ArrayType(Type type, int dimensions) {
super(Const.T_ARRAY, ""<dummy>"");
if ((dimensions < 1) || (dimensions > Const.MAX_BYTE)) {
throw new ClassGenException(""Invalid number of dimensions: "" + dimensions);
}
switch(type.getType()) {
case Const.T_ARRAY:
ArrayType array = (ArrayType) type;
this.dimensions = dimensions + array.dimensions;
basic_type = array.basic_type;
break;
case Const.T_VOID:
throw new ClassGenException(""Invalid type: void[]"");
default:
// Basic type or reference
this.dimensions = dimensions;
basic_type = type;
break;
}
StringBuilder buf = new StringBuilder();
for (int i = 0; i < this.dimensions; i++) {
buf.append('[');
}
buf.append(basic_type.getSignature());
super.setSignature(buf.toString());
}",0,False
92,"static BranchHandle getBranchHandle(BranchInstruction i) {
if (bh_list == null) {
return new BranchHandle(i);
}
BranchHandle bh = bh_list;
bh_list = (BranchHandle) bh.getNext();
bh.setInstruction(i);
return bh;
}",0,False
93,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
94,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
95,"public int addConstant(Constant c, ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
96,"public static ElementValueGen copy(ElementValue value, ConstantPoolGen cpool, boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0,False
97,"public void setInitValue(double d) {
checkType(Type.DOUBLE);
if (d != 0.0) {
value = new Double(d);
}
}",0,False
98,"public void setInitValue(float f) {
checkType(Type.FLOAT);
if (f != 0.0) {
value = new Float(f);
}
}",0,False
99,"@Override
public boolean equals(Instruction i1, Instruction i2) {
if (i1.getOpcode() == i2.getOpcode()) {
if (i1 instanceof BranchInstruction) {
return false;
} else if (i1 instanceof ConstantPushInstruction) {
return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());
} else if (i1 instanceof IndexedInstruction) {
return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();
} else if (i1 instanceof NEWARRAY) {
return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
} else {
return true;
}
}
return false;
}",0,False
100,"public INSTANCEOF createInstanceOf(ReferenceType t) {
if (t instanceof ArrayType) {
return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
}
return new INSTANCEOF(cp.addClass((ObjectType) t));
}",0,False
101,"public Instruction createCast(Type src_type, Type dest_type) {
if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {
byte dest = dest_type.getType();
byte src = src_type.getType();
if (dest == Const.T_LONG && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
src = Const.T_INT;
}
String name = ""org.apache.commons.bcel6.generic."" + short_names[src - Const.T_CHAR] + ""2"" + short_names[dest - Const.T_CHAR];
Instruction i = null;
try {
i = (Instruction) java.lang.Class.forName(name).newInstance();
} catch (Exception e) {
throw new RuntimeException(""Could not find instruction: "" + name, e);
}
return i;
} else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {
if (dest_type instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));
}
return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
} else {
throw new RuntimeException(""Can not cast "" + src_type + "" to "" + dest_type);
}
}",0,False
102,"public int[] getInstructionPositions() {
return byte_positions;
}",0,False
103,"public void setArgumentTypes(Type[] arg_types) {
this.arg_types = arg_types;
}",0,False
104,"public void setArgumentNames(String[] arg_names) {
this.arg_names = arg_names;
}",0,False
105,"public void setArgumentNames(String[] arg_names) {
this.arg_names = arg_names;
}",0,False
106,"private void sort(int l, int r) {
int i = l;
int j = r;
int h;
int m = match[(l + r) / 2];
InstructionHandle h2;
do {
while (match[i] < m) {
i++;
}
while (m < match[j]) {
j--;
}
if (i <= j) {
h = match[i];
match[i] = match[j];
match[j] = h;
h2 = targets[i];
targets[i] = targets[j];
targets[j] = h2;
i++;
j--;
}
} while (i <= j);
if (l < j) {
sort(l, j);
}
if (i < r) {
sort(i, r);
}
}",0,False
107,private final InstructionHandle[] targets;,0,False
108,"@Override
public void visitAllocationInstruction(AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new RuntimeException(""Oops: "" + opcode);
}
}",0,False
109,"public static String printFlags(int flags, FLAGS location) {
if (flags == 0) {
return ""0"";
}
StringBuilder buf = new StringBuilder();
for (int i = 0, pow = 1; pow <= Const.MAX_ACC_FLAG; i++) {
if ((flags & pow) != 0) {
if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {
buf.append(""ACC_SUPER | "");
} else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {
buf.append(""ACC_BRIDGE | "");
} else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {
buf.append(""ACC_VARARGS | "");
} else {
if (i < Const.ACCESS_NAMES_LENGTH) {
buf.append(""ACC_"").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append("" | "");
} else {
buf.append(String.format(""ACC_BIT %x | "", pow));
}
}
}
pow <<= 1;
}
String str = buf.toString();
return str.substring(0, str.length() - 3);
}",0,False
110,"private void writeMainHTML(AttributeHTML attribute_html) throws IOException {
PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + "".html""));
Attribute[] attributes = java_class.getAttributes();
file.println(""<HTML>\n"" + ""<HEAD><TITLE>Documentation for "" + class_name + ""</TITLE>"" + ""</HEAD>\n"" + ""<FRAMESET BORDER=1 cols=\""30%,*\"">\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""ConstantPool\"" SRC=\"""" + class_name + ""_cp.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Attributes\"" SRC=\"""" + class_name + ""_attributes.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET>\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""Code\"" SRC=\"""" + class_name + ""_code.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Methods\"" SRC=\"""" + class_name + ""_methods.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET></FRAMESET></HTML>"");
file.close();
for (int i = 0; i < attributes.length; i++) {
attribute_html.writeAttribute(attributes[i], ""class"" + i);
}
}",0,False
111,"public InputStream getInputStream(String name, String suffix) throws IOException {
InputStream is = null;
try {
is = getClass().getClassLoader().getResourceAsStream(name + suffix);
} catch (Exception e) {
}
if (is != null) {
return is;
}
return getClassFile(name, suffix).getInputStream();
}",0,False
112,"private String codeToHTML(ByteSequence bytes, int method_number) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constant_pool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
String field_name = constant_pool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(class_name)) {
buf.append(""<A HREF=\"""").append(class_name).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constant_html.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(index, Const.CONSTANT_NameAndType)));
ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constant_pool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
String[] args = Utility.methodSignatureArgumentTypes(signature, false);
String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
int dimensions = bytes.readByte();
buf.append(constant_html.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0,False
113,"ConstantHTML(String dir, String class_name, String class_package, Method[] methods, ConstantPool constant_pool) throws IOException {
this.class_name = class_name;
this.class_package = class_package;
this.constant_pool = constant_pool;
this.methods = methods;
constants = constant_pool.getConstantPool();
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
constant_ref = new String[constants.length];
constant_ref[0] = ""&lt;unknown&gt;"";
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
for (int i = 1; i < constants.length; i++) {
if (i % 2 == 0) {
file.print(""<TR BGCOLOR=\""#C0C0C0\""><TD>"");
} else {
file.print(""<TR BGCOLOR=\""#A0A0A0\""><TD>"");
}
if (constants[i] != null) {
writeConstant(i);
}
file.print(""</TD></TR>\n"");
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0,False
114,"MethodHTML(String dir, String class_name, Method[] methods, Field[] fields, ConstantHTML constant_html, AttributeHTML attribute_html) throws IOException {
this.class_name = class_name;
this.attribute_html = attribute_html;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_methods.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
file.println(""<TR><TH ALIGN=LEFT>Access&nbsp;flags</TH><TH ALIGN=LEFT>Type</TH>"" + ""<TH ALIGN=LEFT>Field&nbsp;name</TH></TR>"");
for (Field field : fields) {
writeField(field);
}
file.println(""</TABLE>"");
file.println(""<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags</TH>"" + ""<TH ALIGN=LEFT>Return&nbsp;type</TH><TH ALIGN=LEFT>Method&nbsp;name</TH>"" + ""<TH ALIGN=LEFT>Arguments</TH></TR>"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0,False
115,"@Override
public void update(String classname) {
System.gc();
for (int i = 0; i < indent; i++) {
System.out.print("" "");
}
System.out.println(classname);
indent += 1;
Verifier v = VerifierFactory.getVerifier(classname);
VerificationResult vr;
vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 1:\n"" + vr);
}
vr = v.doPass2();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 2:\n"" + vr);
}
if (vr == VerificationResult.VR_OK) {
try {
JavaClass jc = Repository.lookupClass(v.getClassName());
for (int i = 0; i < jc.getMethods().length; i++) {
vr = v.doPass3a(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3a, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
vr = v.doPass3b(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3b, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
}
} catch (ClassNotFoundException e) {
System.err.println(""Could not find class "" + v.getClassName() + "" in Repository"");
}
}
indent -= 1;
}",0,False
116,"@Override
public void visitINVOKEINTERFACE(INVOKEINTERFACE o) {
int count = o.getCount();
if (count == 0) {
constraintViolated(o, ""The 'count' argument must not be 0."");
}
// TODO: Do we want to do anything with it?
Type t = o.getType(cpg);
if (t instanceof ObjectType) {
String name = ((ObjectType) t).getClassName();
Verifier v = VerifierFactory.getVerifier(name);
VerificationResult vr = v.doPass2();
if (vr.getStatus() != VerificationResult.VERIFIED_OK) {
constraintViolated(o, ""Class '"" + name + ""' is referenced, but cannot be loaded and resolved: '"" + vr + ""'."");
}
}
Type[] argtypes = o.getArgumentTypes(cpg);
int nargs = argtypes.length;
for (int i = nargs - 1; i >= 0; i--) {
Type fromStack = stack().peek((nargs - 1) - i);
Type fromDesc = argtypes[i];
if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {
fromDesc = Type.INT;
}
if (!fromStack.equals(fromDesc)) {
if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {
ReferenceType rFromStack = (ReferenceType) fromStack;
// TODO: This can only be checked when using Staerk-et-al's ""set of object types""
referenceTypeIsInitialized(o, rFromStack);
} else {
constraintViolated(o, ""Expecting a '"" + fromDesc + ""' but found a '"" + fromStack + ""' on the stack."");
}
}
}
Type objref = stack().peek(nargs);
if (objref == Type.NULL) {
return;
}
if (!(objref instanceof ReferenceType)) {
constraintViolated(o, ""Expecting a reference type as 'objectref' on the stack, not a '"" + objref + ""'."");
}
referenceTypeIsInitialized(o, (ReferenceType) objref);
if (!(objref instanceof ObjectType)) {
if (!(objref instanceof ArrayType)) {
constraintViolated(o, ""Expecting an ObjectType as 'objectref' on the stack, not a '"" + objref + ""'."");
} else {
objref = GENERIC_ARRAY;
}
}
// TODO: This can only be checked if we're using Staerk-et-al's ""set of object types""
int counted_count = 1;
for (int i = 0; i < nargs; i++) {
counted_count += argtypes[i].getSize();
}
if (count != counted_count) {
constraintViolated(o, ""The 'count' argument should probably read '"" + counted_count + ""' but is '"" + count + ""'."");
}
}",0,False
117,"@Override
public void visitGETFIELD(GETFIELD o) {
try {
Type objectref = stack().peek();
if (!((objectref instanceof ObjectType) || (objectref == Type.NULL))) {
constraintViolated(o, ""Stack top should be an object reference that's not an array reference, but is '"" + objectref + ""'."");
}
String field_name = o.getFieldName(cpg);
JavaClass jc = Repository.lookupClass(getObjectType(o).getClassName());
Field[] fields = jc.getFields();
Field f = null;
for (Field field : fields) {
if (field.getName().equals(field_name)) {
Type f_type = Type.getType(field.getSignature());
Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
break;
}
}
}
if (f == null) {
JavaClass[] superclasses = jc.getSuperClasses();
outer: for (JavaClass superclass : superclasses) {
fields = superclass.getFields();
for (Field field : fields) {
if (field.getName().equals(field_name)) {
Type f_type = Type.getType(field.getSignature());
Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
if ((f.getAccessFlags() & (Const.ACC_PUBLIC | Const.ACC_PROTECTED)) == 0) {
f = null;
}
break outer;
}
}
}
}
if (f == null) {
throw new AssertionViolatedException(""Field '"" + field_name + ""' not found in "" + jc.getClassName());
}
}
if (f.isProtected()) {
ObjectType classtype = getObjectType(o);
ObjectType curr = ObjectType.getInstance(mg.getClassName());
if (classtype.equals(curr) || curr.subclassOf(classtype)) {
Type t = stack().peek();
if (t == Type.NULL) {
return;
}
if (!(t instanceof ObjectType)) {
constraintViolated(o, ""The 'objectref' must refer to an object that's not an array. Found instead: '"" + t + ""'."");
}
ObjectType objreftype = (ObjectType) t;
if (!(objreftype.equals(curr) || objreftype.subclassOf(curr))) {
// TODO: One day move to Staerk-et-al's ""Set of object types"" instead of ""wider"" object types
}
}
}
// TODO: Could go into Pass 3a.
if (f.isStatic()) {
constraintViolated(o, ""Referenced field '"" + f + ""' is static which it shouldn't be."");
}
} catch (ClassNotFoundException e) {
// FIXME: maybe not the best way to handle this
throw new AssertionViolatedException(""Missing class: "" + e, e);
}
}",0,False
118,"@Override
public Object clone() {
LocalVariables lvs = new LocalVariables(locals.length);
for (int i = 0; i < locals.length; i++) {
lvs.locals[i] = this.locals[i];
}
return lvs;
}",0,False
119,"String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"" };",0,False
120,"String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",0,True
121,"short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",0,False
122,"int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0,False
123,"String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0,False
124,"// TODO: mutable public array!!
String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"" };",0,False
125,"String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0,False
126,"short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",0,True
127,"@Deprecated
Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = { NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR, EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR };",0,False
128,"@Deprecated
Class<?>[] EXCS_ARRAY_EXCEPTION = { NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION };",0,False
129,"public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {
this.annotationTable = annotationTable;
}",0,False
130,"public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {
super(type, cpool);
if (type != ARRAY) {
throw new IllegalArgumentException(""Only element values of type array can be built with this ctor - type specified: "" + type);
}
this.elementValues = datums;
}",0,False
131,"public void setBootstrapArguments(final int[] bootstrapArguments) {
this.bootstrapArguments = bootstrapArguments;
}",0,False
132,"public final void setBootstrapMethods(final BootstrapMethod[] bootstrapMethods) {
this.bootstrapMethods = bootstrapMethods;
}",0,False
133,"public CodeException[] getExceptionTable() {
return exceptionTable;
}",0,False
134,"public Attribute[] getAttributes() {
return attributes;
}",0,False
135,"@Override
public Object getConstantValue(final ConstantPool cp) {
return new Float(bytes);
}",0,False
136,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
137,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
138,"public Constant[] getConstantPool() {
return constantPool;
}",0,False
139,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
140,"public void setConstantPool(final Constant[] constantPool) {
this.constantPool = constantPool;
}",0,False
141,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
142,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
143,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
144,"public ConstantPool(final Constant[] constantPool) {
this.constantPool = constantPool;
}",0,False
145,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
final byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "" "" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
final ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_Module:
i = ((ConstantModule) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_Package:
i = ((ConstantPackage) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + tag);
}
return str;
}",0,False
146,"public ConstantUtf8(final String value) {
super(Const.CONSTANT_Utf8);
if (value == null) {
throw new IllegalArgumentException(""Value must not be null."");
}
this.value = value;
created++;
}",0,False
147,"ConstantUtf8(final DataInput dataInput) throws IOException {
super(Const.CONSTANT_Utf8);
value = dataInput.readUTF();
created++;
}",0,False
148,"public Deprecated(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);
this.bytes = bytes;
}",0,False
149,"public int[] getExceptionIndexTable() {
return exceptionIndexTable;
}",0,False
150,"public final void setAttributes(final Attribute[] attributes) {
this.attributes = attributes;
this.attributes_count = attributes != null ? attributes.length : 0;
}",0,False
151,"public AnnotationEntry[] getAnnotationEntries() {
if (annotations == null) {
annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotations;
}",0,False
152,"public Field[] getFields() {
return fields;
}",0,False
153,"public void setAttributes(final Attribute[] attributes) {
this.attributes = attributes;
}",0,False
154,"public int[] getInterfaceIndices() {
return interfaces;
}",0,False
155,"static void Debug(final String str) {
if (debug) {
System.out.println(str);
}
}",0,False
156,"public void setMethods(final Method[] methods) {
this.methods = methods;
}",0,False
157,"public String[] getInterfaceNames() {
return interfaceNames;
}",0,False
158,"public void setInterfaces(final int[] interfaces) {
this.interfaces = interfaces;
}",0,False
159,"public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table, final ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.lineNumberTable = line_number_table;
}",0,False
160,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.localVariableTable = local_variable_table;
}",0,False
161,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
if (parameterAnnotationEntries == null) {
parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());
}
return parameterAnnotationEntries;
}",0,False
162,"public MethodParameter[] getParameters() {
return parameters;
}",0,False
163,"public ModuleExports[] getExportsTable() {
return exportsTable;
}",0,False
164,"public ModuleRequires[] getRequiresTable() {
return requiresTable;
}",0,False
165,"public ParameterAnnotations(final byte parameterAnnotationType, final int nameIndex, final int length, final ParameterAnnotationEntry[] parameterAnnotationTable, final ConstantPool constantPool) {
super(parameterAnnotationType, nameIndex, length, constantPool);
this.parameterAnnotationTable = parameterAnnotationTable;
}",0,False
166,"public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
return parameterAnnotationTable;
}",0,False
167,"public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameterAnnotationTable) {
this.parameterAnnotationTable = parameterAnnotationTable;
}",0,False
168,"String getData() {
return new String(buf);
}",0,False
169,"public void setStackMap(final StackMapEntry[] map) {
this.map = map;
int len = 2;
for (final StackMapEntry element : map) {
len += element.getMapEntrySize();
}
setLength(len);
}",0,False
170,"public Synthetic(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_SYNTHETIC, name_index, length, constant_pool);
this.bytes = bytes;
}",0,False
171,"public void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0,False
172,"public byte[] getBytes() {
return bytes;
}",0,False
173,"public void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0,False
174,"public Unknown(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_UNKNOWN, name_index, length, constant_pool);
this.bytes = bytes;
name = ((ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8)).getBytes();
unknownAttributes.put(name, this);
}",0,False
175,"public byte[] getBytes() {
return bytes;
}",0,False
176,"public static String signatureToString(final String signature, final boolean chopit) {
String type = """";
String typeParams = """";
int index = 0;
if (signature.charAt(0) == '<') {
typeParams = typeParamTypesToString(signature, chopit);
index += unwrap(consumed_chars);
}
if (signature.charAt(index) == '(') {
type = typeParams + typeSignaturesToString(signature.substring(index), chopit, ')');
index += unwrap(consumed_chars);
type = type + typeSignatureToString(signature.substring(index), chopit);
index += unwrap(consumed_chars);
return type;
}
type = typeSignatureToString(signature.substring(index), chopit);
index += unwrap(consumed_chars);
if ((typeParams.length() == 0) && (index == signature.length())) {
return type;
}
final StringBuilder typeClass = new StringBuilder(typeParams);
typeClass.append("" extends "");
typeClass.append(type);
if (index < signature.length()) {
typeClass.append("" implements "");
typeClass.append(typeSignatureToString(signature.substring(index), chopit));
index += unwrap(consumed_chars);
}
while (index < signature.length()) {
typeClass.append("", "");
typeClass.append(typeSignatureToString(signature.substring(index), chopit));
index += unwrap(consumed_chars);
}
return typeClass.toString();
}",0,False
177,"static Attribute[] getParameterAnnotationAttributes(final ConstantPoolGen cp, final List<AnnotationEntryGen>[] vec) {
final int[] visCount = new int[vec.length];
int totalVisCount = 0;
final int[] invisCount = new int[vec.length];
int totalInvisCount = 0;
try {
for (int i = 0; i < vec.length; i++) {
if (vec[i] != null) {
for (final AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
visCount[i]++;
totalVisCount++;
} else {
invisCount[i]++;
totalInvisCount++;
}
}
}
}
final ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes)) {
rvaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
rvaDos.writeShort(visCount[i]);
if (visCount[i] > 0) {
for (final AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
element.dump(rvaDos);
}
}
}
}
}
final ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
try (DataOutputStream riaDos = new DataOutputStream(riaBytes)) {
riaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
riaDos.writeShort(invisCount[i]);
if (invisCount[i] > 0) {
for (final AnnotationEntryGen element : vec[i]) {
if (!element.isRuntimeVisible()) {
element.dump(riaDos);
}
}
}
}
}
final byte[] rvaData = rvaBytes.toByteArray();
final byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (totalVisCount > 0) {
rvaIndex = cp.addUtf8(""RuntimeVisibleParameterAnnotations"");
}
if (totalInvisCount > 0) {
riaIndex = cp.addUtf8(""RuntimeInvisibleParameterAnnotations"");
}
final List<Attribute> newAttributes = new ArrayList<>();
if (totalVisCount > 0) {
newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (totalInvisCount > 0) {
newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (final IOException e) {
System.err.println(""IOException whilst processing parameter annotations"");
e.printStackTrace();
}
return null;
}",0,False
178,"static Attribute[] getAnnotationAttributes(final ConstantPoolGen cp, final AnnotationEntryGen[] annotationEntryGens) {
if (annotationEntryGens.length == 0) {
return new Attribute[0];
}
try {
int countVisible = 0;
int countInvisible = 0;
for (final AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
countVisible++;
} else {
countInvisible++;
}
}
final ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
final ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
DataOutputStream riaDos = new DataOutputStream(riaBytes)) {
rvaDos.writeShort(countVisible);
riaDos.writeShort(countInvisible);
for (final AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
a.dump(rvaDos);
} else {
a.dump(riaDos);
}
}
}
final byte[] rvaData = rvaBytes.toByteArray();
final byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (rvaData.length > 2) {
rvaIndex = cp.addUtf8(""RuntimeVisibleAnnotations"");
}
if (riaData.length > 2) {
riaIndex = cp.addUtf8(""RuntimeInvisibleAnnotations"");
}
final List<Attribute> newAttributes = new ArrayList<>();
if (rvaData.length > 2) {
newAttributes.add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (riaData.length > 2) {
newAttributes.add(new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (final IOException e) {
System.err.println(""IOException whilst processing annotations"");
e.printStackTrace();
}
return null;
}",0,False
179,"public ArrayType(final Type type, final int dimensions) {
super(Const.T_ARRAY, ""<dummy>"");
if ((dimensions < 1) || (dimensions > Const.MAX_BYTE)) {
throw new ClassGenException(""Invalid number of dimensions: "" + dimensions);
}
switch(type.getType()) {
case Const.T_ARRAY:
final ArrayType array = (ArrayType) type;
this.dimensions = dimensions + array.dimensions;
basicType = array.basicType;
break;
case Const.T_VOID:
throw new ClassGenException(""Invalid type: void[]"");
default:
// Basic type or reference
this.dimensions = dimensions;
basicType = type;
break;
}
final StringBuilder buf = new StringBuilder();
for (int i = 0; i < this.dimensions; i++) {
buf.append('[');
}
buf.append(basicType.getSignature());
super.setSignature(buf.toString());
}",0,False
180,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0,False
181,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0,False
182,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
final Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
final ConstantString s = (ConstantString) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
final ConstantClass s = (ConstantClass) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
final ConstantNameAndType n = (ConstantNameAndType) c;
final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
final ConstantCP m = (ConstantCP) c;
final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
final String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
final String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
final String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new IllegalArgumentException(""Unknown constant type "" + c);
}
}",0,False
183,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new UnsupportedOperationException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0,False
184,"@Override
public Number getValue() {
return new Float(value);
}",0,False
185,"public void setInitValue(final float f) {
checkType(Type.FLOAT);
if (f != 0.0) {
value = new Float(f);
}
}",0,False
186,Instruction[] INSTRUCTIONS = new Instruction[256];,0,False
187,"public int[] getInstructionPositions() {
return bytePositions;
}",0,False
188,"public Object getValue(final ConstantPoolGen cpg) {
org.apache.bcel.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.bcel.Const.CONSTANT_String:
final int i = ((org.apache.bcel.classfile.ConstantString) c).getStringIndex();
c = cpg.getConstantPool().getConstant(i);
return ((org.apache.bcel.classfile.ConstantUtf8) c).getBytes();
case org.apache.bcel.Const.CONSTANT_Float:
return new Float(((org.apache.bcel.classfile.ConstantFloat) c).getBytes());
case org.apache.bcel.Const.CONSTANT_Integer:
return Integer.valueOf(((org.apache.bcel.classfile.ConstantInteger) c).getBytes());
case org.apache.bcel.Const.CONSTANT_Class:
final int nameIndex = ((org.apache.bcel.classfile.ConstantClass) c).getNameIndex();
c = cpg.getConstantPool().getConstant(nameIndex);
return new ObjectType(((org.apache.bcel.classfile.ConstantUtf8) c).getBytes());
default:
// Never reached
throw new IllegalArgumentException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0,False
189,"public void setArgumentNames(final String[] arg_names) {
this.argNames = arg_names;
}",0,False
190,"public InstructionHandle[] getTargets() {
return targets;
}",0,False
191,"public InstructionHandle[] getTargets() {
return targets;
}",0,False
192,private final InstructionHandle[] targets;,0,False
193,"@Override
public void visitAllocationInstruction(final AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
final short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new IllegalArgumentException(""Unhandled opcode: "" + opcode);
}
}",0,False
194,"@Override
public void visitAllocationInstruction(final AllocationInstruction i) {
Type type;
if (i instanceof CPInstruction) {
type = ((CPInstruction) i).getType(_cp);
} else {
type = ((NEWARRAY) i).getType();
}
final short opcode = ((Instruction) i).getOpcode();
int dim = 1;
switch(opcode) {
case Const.NEW:
_out.println(""il.append(_factory.createNew(\"""" + ((ObjectType) type).getClassName() + ""\""));"");
break;
case Const.MULTIANEWARRAY:
dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
type = ((ArrayType) type).getBasicType();
}
_out.println(""il.append(_factory.createNewArray("" + BCELifier.printType(type) + "", (short) "" + dim + ""));"");
break;
default:
throw new IllegalArgumentException(""Unhandled opcode: "" + opcode);
}
}",0,False
195,"@Override
public void visitBranchInstruction(final BranchInstruction bi) {
final BranchHandle bh = (BranchHandle) branch_map.get(bi);
final int pos = bh.getPosition();
final String name = bi.getName() + ""_"" + pos;
if (bi instanceof Select) {
final Select s = (Select) bi;
branches.add(bi);
final StringBuilder args = new StringBuilder(""new int[] { "");
final int[] matchs = s.getMatchs();
for (int i = 0; i < matchs.length; i++) {
args.append(matchs[i]);
if (i < matchs.length - 1) {
args.append("", "");
}
}
args.append("" }"");
_out.print(""Select "" + name + "" = new "" + bi.getName().toUpperCase(Locale.ENGLISH) + ""("" + args + "", new InstructionHandle[] { "");
for (int i = 0; i < matchs.length; i++) {
_out.print(""null"");
if (i < matchs.length - 1) {
_out.print("", "");
}
}
_out.println("" }, null);"");
} else {
final int t_pos = bh.getTarget().getPosition();
String target;
if (pos > t_pos) {
target = ""ih_"" + t_pos;
} else {
branches.add(bi);
target = ""null"";
}
_out.println(""    BranchInstruction "" + name + "" = _factory.createBranchInstruction("" + CONSTANT_PREFIX + bi.getName().toUpperCase(Locale.ENGLISH) + "", "" + target + "");"");
}
if (bh.hasTargeters()) {
_out.println(""    ih_"" + pos + "" = il.append("" + name + "");"");
} else {
_out.println(""    il.append("" + name + "");"");
}
}",0,False
196,"private void updateBranchTargets() {
for (final BranchInstruction bi : branches) {
final BranchHandle bh = (BranchHandle) branch_map.get(bi);
final int pos = bh.getPosition();
final String name = bi.getName() + ""_"" + pos;
int t_pos = bh.getTarget().getPosition();
_out.println(""    "" + name + "".setTarget(ih_"" + t_pos + "");"");
if (bi instanceof Select) {
final InstructionHandle[] ihs = ((Select) bi).getTargets();
for (int j = 0; j < ihs.length; j++) {
t_pos = ihs[j].getPosition();
_out.println(""    "" + name + "".setTarget("" + j + "", ih_"" + t_pos + "");"");
}
}
}
}",0,False
197,"public static String printFlags(final int flags, final FLAGS location) {
if (flags == 0) {
return ""0"";
}
final StringBuilder buf = new StringBuilder();
for (int i = 0, pow = 1; pow <= Const.MAX_ACC_FLAG_I; i++) {
if ((flags & pow) != 0) {
if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {
buf.append(CONSTANT_PREFIX + ""ACC_SUPER | "");
} else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {
buf.append(CONSTANT_PREFIX + ""ACC_BRIDGE | "");
} else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {
buf.append(CONSTANT_PREFIX + ""ACC_VARARGS | "");
} else {
if (i < Const.ACCESS_NAMES_LENGTH) {
buf.append(CONSTANT_PREFIX + ""ACC_"").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append("" | "");
} else {
buf.append(String.format(CONSTANT_PREFIX + ""ACC_BIT %x | "", pow));
}
}
}
pow <<= 1;
}
final String str = buf.toString();
return str.substring(0, str.length() - 3);
}",0,False
198,"private void writeMainHTML(final AttributeHTML attribute_html) throws IOException {
try (PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + "".html""))) {
file.println(""<HTML>\n"" + ""<HEAD><TITLE>Documentation for "" + class_name + ""</TITLE>"" + ""</HEAD>\n"" + ""<FRAMESET BORDER=1 cols=\""30%,*\"">\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""ConstantPool\"" SRC=\"""" + class_name + ""_cp.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Attributes\"" SRC=\"""" + class_name + ""_attributes.html"" + ""\""\n MARGINWIDTH=\""0\"" "" + ""MARGINHEIGHT=\""0\"" FRAMEBORDER=\""1\"" SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET>\n"" + ""<FRAMESET BORDER=1 rows=\""80%,*\"">\n"" + ""<FRAME NAME=\""Code\"" SRC=\"""" + class_name + ""_code.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""<FRAME NAME=\""Methods\"" SRC=\"""" + class_name + ""_methods.html\""\n MARGINWIDTH=0 "" + ""MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\""AUTO\"">\n"" + ""</FRAMESET></FRAMESET></HTML>"");
}
final Attribute[] attributes = java_class.getAttributes();
for (int i = 0; i < attributes.length; i++) {
attribute_html.writeAttribute(attributes[i], ""class"" + i);
}
}",0,False
199,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
final Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
final int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0,False
200,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
final Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
final int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0,False
201,"public static final String[] DEFAULT_IGNORED_PACKAGES = { ""java."", ""javax."", ""sun."" };",0,False
202,"@Override
public String getBase() {
return resolved.getFileName().toString();
}",0,False
203,"public InputStream getInputStream(final String name, final String suffix) throws IOException {
InputStream inputStream = null;
try {
inputStream = getClass().getClassLoader().getResourceAsStream(name + suffix);
} catch (final Exception e) {
}
if (inputStream != null) {
return inputStream;
}
return getClassFile(name, suffix).getInputStream();
}",0,False
204,"@Deprecated
protected List<JavaClass> vec = new ArrayList<>();",0,False
205,"CodeHTML(final String dir, final String class_name, final Method[] methods, final ConstantPool constant_pool, final ConstantHTML constant_html) throws IOException {
this.className = class_name;
this.constantPool = constant_pool;
this.constantHtml = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_code.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\"">"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</BODY></HTML>"");
file.close();
}",0,False
206,"private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {
final short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
final StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
final int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (final int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
final int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
final int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
final int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
final ConstantFieldref c1 = (ConstantFieldref) constantPool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constantPool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
final String field_name = constantPool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(className)) {
buf.append(""<A HREF=\"""").append(className).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constantHtml.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
final int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
final ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constantPool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
final ConstantInvokeDynamic c = (ConstantInvokeDynamic) constantPool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(index, Const.CONSTANT_NameAndType)));
final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
final String[] args = Utility.methodSignatureArgumentTypes(signature, false);
final String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(className).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(className).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(className).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
final int dimensions = bytes.readByte();
buf.append(constantHtml.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0,False
207,"@Override
public JavaClass findClass(final String className) {
return loadedClasses.get(className);
}",0,False
208,"MethodHTML(final String dir, final String class_name, final Method[] methods, final Field[] fields, final ConstantHTML constant_html, final AttributeHTML attribute_html) throws IOException {
this.className = class_name;
this.attribute_html = attribute_html;
this.constantHtml = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_methods.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
file.println(""<TR><TH ALIGN=LEFT>Access&nbsp;flags</TH><TH ALIGN=LEFT>Type</TH>"" + ""<TH ALIGN=LEFT>Field&nbsp;name</TH></TR>"");
for (final Field field : fields) {
writeField(field);
}
file.println(""</TABLE>"");
file.println(""<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags</TH>"" + ""<TH ALIGN=LEFT>Return&nbsp;type</TH><TH ALIGN=LEFT>Method&nbsp;name</TH>"" + ""<TH ALIGN=LEFT>Arguments</TH></TR>"");
for (int i = 0; i < methods.length; i++) {
writeMethod(methods[i], i);
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0,False
209,private final IvjEventHandler ivjEventHandler = new IvjEventHandler();,0,False
210,"public LocalVariablesInfo getLocalVariablesInfo(final int methodNr) {
if (this.verify() != VerificationResult.VR_OK) {
return null;
}
if (methodNr < 0 || methodNr >= localVariablesInfos.length) {
throw new AssertionViolatedException(""Method number out of range."");
}
return localVariablesInfos[methodNr];
}",0,False
211,"public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0,False
212,"public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",0,True
213,"public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0,False
214,"public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0,True
215,"public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0,False
216,"public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0,False
217,"@Deprecated
public static final Class<?>[] EXCS_ARRAY_EXCEPTION = { NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION };",0,False
218,"@Deprecated
public static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = { NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR };",0,False
219,"public Annotations(final byte annotation_type, final int name_index, final int length, final AnnotationEntry[] annotation_table, final ConstantPool constant_pool, final boolean isRuntimeVisible) {
super(annotation_type, name_index, length, constant_pool);
this.annotation_table = annotation_table;
this.isRuntimeVisible = isRuntimeVisible;
}",0,False
220,"public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {
super(type, cpool);
if (type != ARRAY) {
throw new RuntimeException(""Only element values of type array can be built with this ctor - type specified: "" + type);
}
this.evalues = datums;
}",0,False
221,"public void setBootstrapArguments(final int[] bootstrap_arguments) {
this.bootstrap_arguments = bootstrap_arguments;
}",0,False
222,"public int[] getBootstrapArguments() {
return bootstrap_arguments;
}",0,False
223,"public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrap_methods, final ConstantPool constant_pool) {
super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);
this.bootstrap_methods = bootstrap_methods;
}",0,False
224,"public final BootstrapMethod[] getBootstrapMethods() {
return bootstrap_methods;
}",0,False
225,"public JavaClass parse() throws IOException, ClassFormatException {
ZipFile zip = null;
try {
if (fileOwned) {
if (is_zip) {
zip = new ZipFile(zip_file);
ZipEntry entry = zip.getEntry(file_name);
if (entry == null) {
throw new IOException(""File "" + file_name + "" not found"");
}
dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry), BUFSIZE));
} else {
dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(file_name), BUFSIZE));
}
}
readID();
readVersion();
readConstantPool();
readClassInfo();
readInterfaces();
readFields();
readMethods();
readAttributes();
// System.err.println(""WARNING: "" + u[i]);
// System.err.println(""WARNING: Trailing garbage at end of "" + file_name);
// System.err.println(bytes + "" extra bytes: "" + Utility.toHexString(buf));
} finally {
if (fileOwned) {
try {
if (dataInputStream != null) {
dataInputStream.close();
}
if (zip != null) {
zip.close();
}
} catch (IOException ioe) {
}
}
}
return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor, access_flags, constant_pool, interfaces, fields, methods, attributes, is_zip ? JavaClass.ZIP : JavaClass.FILE);
}",0,False
226,"public final CodeException[] getExceptionTable() {
return exception_table;
}",0,False
227,"public final byte[] getCode() {
return code;
}",0,False
228,"public final int getEndPC() {
return end_pc;
}",0,False
229,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
230,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
231,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
232,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
233,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
234,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
235,"public ConstantPool(final Constant[] constant_pool) {
this.constant_pool = constant_pool;
}",0,False
236,"public String constantToString(Constant c) throws ClassFormatException {
String str;
int i;
byte tag = c.getTag();
switch(tag) {
case Const.CONSTANT_Class:
i = ((ConstantClass) c).getNameIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
break;
case Const.CONSTANT_String:
i = ((ConstantString) c).getStringIndex();
c = getConstant(i, Const.CONSTANT_Utf8);
str = ""\"""" + escape(((ConstantUtf8) c).getBytes()) + ""\"""";
break;
case Const.CONSTANT_Utf8:
str = ((ConstantUtf8) c).getBytes();
break;
case Const.CONSTANT_Double:
str = String.valueOf(((ConstantDouble) c).getBytes());
break;
case Const.CONSTANT_Float:
str = String.valueOf(((ConstantFloat) c).getBytes());
break;
case Const.CONSTANT_Long:
str = String.valueOf(((ConstantLong) c).getBytes());
break;
case Const.CONSTANT_Integer:
str = String.valueOf(((ConstantInteger) c).getBytes());
break;
case Const.CONSTANT_NameAndType:
str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + "":"" + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + ""."" + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
case Const.CONSTANT_MethodHandle:
ConstantMethodHandle cmh = (ConstantMethodHandle) c;
str = Const.getMethodHandleName(cmh.getReferenceKind()) + "" "" + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());
break;
case Const.CONSTANT_MethodType:
ConstantMethodType cmt = (ConstantMethodType) c;
str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
break;
case Const.CONSTANT_InvokeDynamic:
ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
str = cid.getBootstrapMethodAttrIndex() + "":"" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);
break;
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + tag);
}
return str;
}",0,False
237,"public Constant[] getConstantPool() {
return constant_pool;
}",0,False
238,"public ConstantUtf8(final String bytes) {
super(Const.CONSTANT_Utf8);
if (bytes == null) {
throw new IllegalArgumentException(""bytes must not be null!"");
}
this.bytes = bytes;
created++;
}",0,False
239,"public Deprecated(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {
super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);
this.bytes = bytes;
}",0,False
240,"public final void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0,False
241,"public final Attribute[] getAttributes() {
return attributes;
}",0,False
242,"public AnnotationEntry[] getAnnotationEntries() {
if (annotationEntries == null) {
annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotationEntries;
}",0,False
243,"public Field[] getFields() {
return fields;
}",0,False
244,"public void setFields(final Field[] fields) {
this.fields = fields;
}",0,False
245,"public AnnotationEntry[] getAnnotationEntries() {
if (annotations == null) {
annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
}
return annotations;
}",0,False
246,"public int[] getInterfaceIndices() {
return interfaces;
}",0,False
247,"public void setAttributes(final Attribute[] attributes) {
this.attributes = attributes;
}",0,False
248,"public String[] getInterfaceNames() {
return interface_names;
}",0,False
249,"public Method[] getMethods() {
return methods;
}",0,False
250,"public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table, final ConstantPool constant_pool) {
super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);
this.line_number_table = line_number_table;
}",0,False
251,"public int getSourceLine(final int pos) {
int l = 0;
int r = line_number_table.length - 1;
if (r < 0) {
return -1;
}
int min_index = -1;
int min = -1;
do {
int i = (l + r) / 2;
int j = line_number_table[i].getStartPC();
if (j == pos) {
return line_number_table[i].getLineNumber();
} else if (pos < j) {
r = i - 1;
} else {
l = i + 1;
}
if (j < pos && j > min) {
min = j;
min_index = i;
}
} while (l <= r);
if (min_index < 0) {
return -1;
}
return line_number_table[min_index].getLineNumber();
}",0,False
252,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.local_variable_table = local_variable_table;
}",0,False
253,"public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {
this.local_variable_type_table = local_variable_table;
}",0,False
254,"public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
if (parameterAnnotationEntries == null) {
parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());
}
return parameterAnnotationEntries;
}",0,False
255,"public MethodParameter[] getParameters() {
return parameters;
}",0,False
256,"public AnnotationEntry[] getAnnotationEntries() {
return annotation_table;
}",0,False
257,"public ParameterAnnotations(final byte parameter_annotation_type, final int name_index, final int length, final ParameterAnnotationEntry[] parameter_annotation_table, final ConstantPool constant_pool) {
super(parameter_annotation_type, name_index, length, constant_pool);
this.parameter_annotation_table = parameter_annotation_table;
}",0,False
258,"public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameter_annotation_table) {
this.parameter_annotation_table = parameter_annotation_table;
}",0,False
259,"final String getData() {
return new String(buf);
}",0,False
260,"private static void matchIdent(final MyByteArrayInputStream in, final StringBuilder buf) {
int ch;
if ((ch = in.read()) == -1) {
throw new RuntimeException(""Illegal signature: "" + in.getData() + "" no ident, reaching EOF"");
}
// System.out.println(""return from ident:"" + (char)ch);
if (!identStart(ch)) {
StringBuilder buf2 = new StringBuilder();
int count = 1;
while (Character.isJavaIdentifierPart((char) ch)) {
buf2.append((char) ch);
count++;
ch = in.read();
}
if (ch == ':') {
in.skip(""Ljava/lang/Object"".length());
buf.append(buf2);
ch = in.read();
in.unread();
// System.out.println(""so far:"" + buf2 + "":next:"" +(char)ch);
} else {
for (int i = 0; i < count; i++) {
in.unread();
}
}
return;
}
StringBuilder buf2 = new StringBuilder();
ch = in.read();
do {
buf2.append((char) ch);
ch = in.read();
// System.out.println(""within ident:""+ (char)ch);
} while ((ch != -1) && (Character.isJavaIdentifierPart((char) ch) || (ch == '/')));
buf.append(buf2.toString().replace('/', '.'));
// System.out.println(""regular return ident:""+ (char)ch + "":"" + buf2);
if (ch != -1) {
in.unread();
}
}",0,False
261,"public final StackMapEntry[] getStackMap() {
return map;
}",0,False
262,"public StackMapType[] getTypesOfLocals() {
return types_of_locals;
}",0,False
263,"public StackMapType[] getTypesOfStackItems() {
return types_of_stack_items;
}",0,False
264,"public final void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0,False
265,"public final void setBytes(final byte[] bytes) {
this.bytes = bytes;
}",0,False
266,"public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool, final boolean verbose) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
int default_offset = 0;
int low;
int high;
int npairs;
int index;
int vindex;
int constant;
int[] match;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
byte b;
if ((b = bytes.readByte()) != 0) {
System.err.println(""Warning: Padding byte != 0 in "" + Const.getOpcodeName(opcode) + "":"" + b);
}
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", low = "").append(low).append("", high = "").append(high).append(""("");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(jump_table[i]);
if (i < jump_table.length - 1) {
buf.append("", "");
}
}
buf.append("")"");
break;
case Const.LOOKUPSWITCH:
{
npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
match = new int[npairs];
jump_table = new int[npairs];
default_offset += offset;
buf.append(""\tdefault = "").append(default_offset).append("", npairs = "").append(npairs).append("" ("");
for (int i = 0; i < npairs; i++) {
match[i] = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""("").append(match[i]).append("", "").append(jump_table[i]).append("")"");
if (i < npairs - 1) {
buf.append("", "");
}
}
buf.append("")"");
}
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.JSR:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readShort());
break;
case Const.GOTO_W:
case Const.JSR_W:
buf.append(""\t\t#"").append((bytes.getIndex() - 1) + bytes.readInt());
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readUnsignedShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""\t\t%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""\t(wide)"");
break;
case Const.NEWARRAY:
buf.append(""\t\t<"").append(Const.getTypeName(bytes.readByte())).append("">"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.NEW:
case Const.CHECKCAST:
buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
buf.append(""\t<"").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
index = bytes.readUnsignedShort();
Constant c = constant_pool.getConstant(index);
buf.append(""\t"").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEVIRTUAL:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.INVOKEINTERFACE:
index = bytes.readUnsignedShort();
int nargs = bytes.readUnsignedByte();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? "" ("" + index + "")\t"" : """").append(nargs).append(""\t"").append(bytes.readUnsignedByte());
break;
case Const.INVOKEDYNAMIC:
index = bytes.readUnsignedShort();
buf.append(""\t"").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? "" ("" + index + "")\t"" : """").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readUnsignedShort();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""\t\t"").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.ANEWARRAY:
index = bytes.readUnsignedShort();
buf.append(""\t\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">"").append(verbose ? "" ("" + index + "")"" : """");
break;
case Const.MULTIANEWARRAY:
{
index = bytes.readUnsignedShort();
int dimensions = bytes.readUnsignedByte();
buf.append(""\t<"").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append("">\t"").append(dimensions).append(verbose ? "" ("" + index + "")"" : """");
}
break;
case Const.IINC:
if (wide) {
vindex = bytes.readUnsignedShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""\t\t%"").append(vindex).append(""\t"").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
buf.append(""\t\t"");
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readByte());
break;
case Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
System.err.println(""Unreachable default case reached!"");
System.exit(-1);
}
}
}
}
return buf.toString();
}",0,False
267,"static Attribute[] getAnnotationAttributes(final ConstantPoolGen cp, final AnnotationEntryGen[] annotationEntryGens) {
if (annotationEntryGens.length == 0) {
return new Attribute[0];
}
try {
int countVisible = 0;
int countInvisible = 0;
for (AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
countVisible++;
} else {
countInvisible++;
}
}
ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
DataOutputStream riaDos = new DataOutputStream(riaBytes);
rvaDos.writeShort(countVisible);
riaDos.writeShort(countInvisible);
for (AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
a.dump(rvaDos);
} else {
a.dump(riaDos);
}
}
rvaDos.close();
riaDos.close();
byte[] rvaData = rvaBytes.toByteArray();
byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (rvaData.length > 2) {
rvaIndex = cp.addUtf8(""RuntimeVisibleAnnotations"");
}
if (riaData.length > 2) {
riaIndex = cp.addUtf8(""RuntimeInvisibleAnnotations"");
}
List<Attribute> newAttributes = new ArrayList<>();
if (rvaData.length > 2) {
newAttributes.add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (riaData.length > 2) {
newAttributes.add(new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (IOException e) {
System.err.println(""IOException whilst processing annotations"");
e.printStackTrace();
}
return null;
}",0,False
268,"static Attribute[] getParameterAnnotationAttributes(final ConstantPoolGen cp, final List<AnnotationEntryGen>[] vec) {
int[] visCount = new int[vec.length];
int totalVisCount = 0;
int[] invisCount = new int[vec.length];
int totalInvisCount = 0;
try {
for (int i = 0; i < vec.length; i++) {
if (vec[i] != null) {
for (AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
visCount[i]++;
totalVisCount++;
} else {
invisCount[i]++;
totalInvisCount++;
}
}
}
}
ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
rvaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
rvaDos.writeShort(visCount[i]);
if (visCount[i] > 0) {
for (AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
element.dump(rvaDos);
}
}
}
}
rvaDos.close();
ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
DataOutputStream riaDos = new DataOutputStream(riaBytes);
riaDos.writeByte(vec.length);
for (int i = 0; i < vec.length; i++) {
riaDos.writeShort(invisCount[i]);
if (invisCount[i] > 0) {
for (AnnotationEntryGen element : vec[i]) {
if (!element.isRuntimeVisible()) {
element.dump(riaDos);
}
}
}
}
riaDos.close();
byte[] rvaData = rvaBytes.toByteArray();
byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (totalVisCount > 0) {
rvaIndex = cp.addUtf8(""RuntimeVisibleParameterAnnotations"");
}
if (totalInvisCount > 0) {
riaIndex = cp.addUtf8(""RuntimeInvisibleParameterAnnotations"");
}
List<Attribute> newAttributes = new ArrayList<>();
if (totalVisCount > 0) {
newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (totalInvisCount > 0) {
newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (IOException e) {
System.err.println(""IOException whilst processing parameter annotations"");
e.printStackTrace();
}
return null;
}",0,False
269,"@Override
protected void addHandle() {
super.setNext(bh_list);
bh_list = this;
}",0,False
270,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
271,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
272,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
273,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
274,"public int addConstant(final Constant c, final ConstantPoolGen cp) {
Constant[] constants = cp.getConstantPool().getConstantPool();
switch(c.getTag()) {
case Const.CONSTANT_String:
{
ConstantString s = (ConstantString) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
return addString(u8.getBytes());
}
case Const.CONSTANT_Class:
{
ConstantClass s = (ConstantClass) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
return addClass(u8.getBytes());
}
case Const.CONSTANT_NameAndType:
{
ConstantNameAndType n = (ConstantNameAndType) c;
ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
return addNameAndType(u8.getBytes(), u8_2.getBytes());
}
case Const.CONSTANT_Utf8:
return addUtf8(((ConstantUtf8) c).getBytes());
case Const.CONSTANT_Double:
return addDouble(((ConstantDouble) c).getBytes());
case Const.CONSTANT_Float:
return addFloat(((ConstantFloat) c).getBytes());
case Const.CONSTANT_Long:
return addLong(((ConstantLong) c).getBytes());
case Const.CONSTANT_Integer:
return addInteger(((ConstantInteger) c).getBytes());
case Const.CONSTANT_InterfaceMethodref:
case Const.CONSTANT_Methodref:
case Const.CONSTANT_Fieldref:
{
ConstantCP m = (ConstantCP) c;
ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
String class_name = u8.getBytes().replace('/', '.');
u8 = (ConstantUtf8) constants[n.getNameIndex()];
String name = u8.getBytes();
u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
String signature = u8.getBytes();
switch(c.getTag()) {
case Const.CONSTANT_InterfaceMethodref:
return addInterfaceMethodref(class_name, name, signature);
case Const.CONSTANT_Methodref:
return addMethodref(class_name, name, signature);
case Const.CONSTANT_Fieldref:
return addFieldref(class_name, name, signature);
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}
default:
// Never reached
throw new RuntimeException(""Unknown constant type "" + c);
}
}",0,False
275,"@Override
public Number getValue() {
return new Double(value);
}",0,False
276,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0,False
277,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0,False
278,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0,False
279,"public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {
switch(value.getElementValueType()) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'I':
case 'J':
case 'S':
case 'Z':
case 's':
return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);
case 'e':
return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);
case '@':
return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);
case '[':
return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);
case 'c':
return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);
default:
throw new RuntimeException(""Not implemented yet! ("" + value.getElementValueType() + "")"");
}
}",0,False
280,"@Override
public boolean equals(final Instruction i1, final Instruction i2) {
if (i1.getOpcode() == i2.getOpcode()) {
if (i1 instanceof BranchInstruction) {
return false;
} else if (i1 instanceof ConstantPushInstruction) {
return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());
} else if (i1 instanceof IndexedInstruction) {
return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();
} else if (i1 instanceof NEWARRAY) {
return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
} else {
return true;
}
}
return false;
}",0,False
281,"public Instruction createCast(final Type src_type, final Type dest_type) {
if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {
byte dest = dest_type.getType();
byte src = src_type.getType();
if (dest == Const.T_LONG && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
src = Const.T_INT;
}
String name = ""org.apache.commons.bcel6.generic."" + short_names[src - Const.T_CHAR] + ""2"" + short_names[dest - Const.T_CHAR];
Instruction i = null;
try {
i = (Instruction) java.lang.Class.forName(name).newInstance();
} catch (Exception e) {
throw new RuntimeException(""Could not find instruction: "" + name, e);
}
return i;
} else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {
if (dest_type instanceof ArrayType) {
return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));
}
return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
} else {
throw new RuntimeException(""Can not cast "" + src_type + "" to "" + dest_type);
}
}",0,False
282,"public INSTANCEOF createInstanceOf(final ReferenceType t) {
if (t instanceof ArrayType) {
return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
}
return new INSTANCEOF(cp.addClass((ObjectType) t));
}",0,False
283,"protected void addHandle() {
next = ih_list;
ih_list = this;
}",0,False
284,"public void setPositions(final boolean check) {
int max_additional_bytes = 0;
int additional_bytes = 0;
int index = 0;
int count = 0;
int[] pos = new int[length];
if (check) {
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
Instruction i = ih.getInstruction();
if (i instanceof BranchInstruction) {
Instruction inst = ((BranchInstruction) i).getTarget().getInstruction();
if (!contains(inst)) {
throw new ClassGenException(""Branch target of "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not in instruction list"");
}
if (i instanceof Select) {
InstructionHandle[] targets = ((Select) i).getTargets();
for (InstructionHandle target : targets) {
inst = target.getInstruction();
if (!contains(inst)) {
throw new ClassGenException(""Branch target of "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not in instruction list"");
}
}
}
if (!(ih instanceof BranchHandle)) {
throw new ClassGenException(""Branch instruction "" + Const.getOpcodeName(i.getOpcode()) + "":"" + inst + "" not contained in BranchHandle."");
}
}
}
}
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
Instruction i = ih.getInstruction();
ih.setPosition(index);
pos[count++] = index;
switch(i.getOpcode()) {
case Const.JSR:
case Const.GOTO:
max_additional_bytes += 2;
break;
case Const.TABLESWITCH:
case Const.LOOKUPSWITCH:
max_additional_bytes += 3;
break;
}
index += i.getLength();
}
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);
}
index = count = 0;
for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
Instruction i = ih.getInstruction();
ih.setPosition(index);
pos[count++] = index;
index += i.getLength();
}
byte_positions = new int[count];
System.arraycopy(pos, 0, byte_positions, 0, count);
}",0,False
285,"public static InstructionHandle findHandle(final InstructionHandle[] ihs, final int[] pos, final int count, final int target) {
int l = 0;
int r = count - 1;
do {
int i = (l + r) / 2;
int j = pos[i];
if (j == target) {
return ihs[i];
} else if (target < j) {
r = i - 1;
} else {
l = i + 1;
}
} while (l <= r);
return null;
}",0,False
286,"public Number getValue(final ConstantPoolGen cpg) {
org.apache.commons.bcel6.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());
switch(c.getTag()) {
case org.apache.commons.bcel6.Const.CONSTANT_Long:
return Long.valueOf(((org.apache.commons.bcel6.classfile.ConstantLong) c).getBytes());
case org.apache.commons.bcel6.Const.CONSTANT_Double:
return new Double(((org.apache.commons.bcel6.classfile.ConstantDouble) c).getBytes());
default:
// Never reached
throw new RuntimeException(""Unknown or invalid constant type at "" + super.getIndex());
}
}",0,False
287,"public void setArgumentNames(final String[] arg_names) {
this.arg_names = arg_names;
}",0,False
288,"public void setArgumentTypes(final Type[] arg_types) {
this.arg_types = arg_types;
}",0,False
289,"private void sort(final int l, final int r) {
int i = l;
int j = r;
int h;
int m = match[(l + r) / 2];
InstructionHandle h2;
do {
while (match[i] < m) {
i++;
}
while (m < match[j]) {
j--;
}
if (i <= j) {
h = match[i];
match[i] = match[j];
match[j] = h;
h2 = targets[i];
targets[i] = targets[j];
targets[j] = h2;
i++;
j--;
}
} while (i <= j);
if (l < j) {
sort(l, j);
}
if (i < r) {
sort(i, r);
}
}",0,False
290,"public InstructionHandle[] getTargets() {
return targets;
}",0,False
291,private final InstructionHandle[] targets;,0,False
292,"AttributeHTML(final String dir, final String class_name, final ConstantPool constant_pool, final ConstantHTML constant_html) throws IOException {
this.class_name = class_name;
this.constant_pool = constant_pool;
this.constant_html = constant_html;
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_attributes.html""));
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
}",0,False
293,"@Override
public void visitLocalVariableInstruction(final LocalVariableInstruction i) {
short opcode = i.getOpcode();
Type type = i.getType(_cp);
if (opcode == Const.IINC) {
_out.println(""il.append(new IINC("" + i.getIndex() + "", "" + ((IINC) i).getIncrement() + ""));"");
} else {
String kind = (opcode < Const.ISTORE) ? ""Load"" : ""Store"";
_out.println(""il.append(_factory.create"" + kind + ""("" + BCELifier.printType(type) + "", "" + i.getIndex() + ""));"");
}
}",0,False
294,"private void updateBranchTargets() {
for (BranchInstruction bi : branches) {
BranchHandle bh = (BranchHandle) branch_map.get(bi);
int pos = bh.getPosition();
String name = bi.getName() + ""_"" + pos;
int t_pos = bh.getTarget().getPosition();
_out.println(""    "" + name + "".setTarget(ih_"" + t_pos + "");"");
if (bi instanceof Select) {
InstructionHandle[] ihs = ((Select) bi).getTargets();
for (int j = 0; j < ihs.length; j++) {
t_pos = ihs[j].getPosition();
_out.println(""    "" + name + "".setTarget("" + j + "", ih_"" + t_pos + "");"");
}
}
}
}",0,False
295,"public static String printFlags(final int flags, final FLAGS location) {
if (flags == 0) {
return ""0"";
}
StringBuilder buf = new StringBuilder();
for (int i = 0, pow = 1; pow <= Const.MAX_ACC_FLAG; i++) {
if ((flags & pow) != 0) {
if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {
buf.append(CONSTANT_PREFIX + ""ACC_SUPER | "");
} else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {
buf.append(CONSTANT_PREFIX + ""ACC_BRIDGE | "");
} else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {
buf.append(CONSTANT_PREFIX + ""ACC_VARARGS | "");
} else {
if (i < Const.ACCESS_NAMES_LENGTH) {
buf.append(CONSTANT_PREFIX + ""ACC_"").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append("" | "");
} else {
buf.append(String.format(CONSTANT_PREFIX + ""ACC_BIT %x | "", pow));
}
}
}
pow <<= 1;
}
String str = buf.toString();
return str.substring(0, str.length() - 3);
}",0,False
296,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0,False
297,"public Class2HTML(final JavaClass java_class, final String dir) throws IOException {
Method[] methods = java_class.getMethods();
this.java_class = java_class;
this.dir = dir;
class_name = java_class.getClassName();
constant_pool = java_class.getConstantPool();
int index = class_name.lastIndexOf('.');
if (index > -1) {
class_package = class_name.substring(0, index);
} else {
class_package = """";
}
ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods, constant_pool);
AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool, constant_html);
new MethodHTML(dir, class_name, methods, java_class.getFields(), constant_html, attribute_html);
writeMainHTML(attribute_html);
new CodeHTML(dir, class_name, methods, constant_pool, constant_html);
attribute_html.close();
}",0,False
298,"public ClassLoader(final String[] ignored_packages) {
this.ignored_packages = ignored_packages;
}",0,False
299,"public ClassLoader(final String[] ignored_packages) {
this.ignored_packages = ignored_packages;
}",0,False
300,"public InputStream getInputStream(final String name, final String suffix) throws IOException {
InputStream is = null;
try {
is = getClass().getClassLoader().getResourceAsStream(name + suffix);
} catch (Exception e) {
}
if (is != null) {
return is;
}
return getClassFile(name, suffix).getInputStream();
}",0,False
301,"private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constant_pool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
String field_name = constant_pool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(class_name)) {
buf.append(""<A HREF=\"""").append(class_name).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constant_html.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(index, Const.CONSTANT_NameAndType)));
ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constant_pool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
String[] args = Utility.methodSignatureArgumentTypes(signature, false);
String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
int dimensions = bytes.readByte();
buf.append(constant_html.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0,False
302,"private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {
short opcode = (short) bytes.readUnsignedByte();
String name;
String signature;
int default_offset = 0;
int low;
int high;
int index;
int class_index;
int vindex;
int constant;
int[] jump_table;
int no_pad_bytes = 0;
int offset;
StringBuilder buf = new StringBuilder(256);
buf.append(""<TT>"").append(Const.getOpcodeName(opcode)).append(""</TT></TD><TD>"");
if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
int remainder = bytes.getIndex() % 4;
no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
for (int i = 0; i < no_pad_bytes; i++) {
bytes.readByte();
}
default_offset = bytes.readInt();
}
switch(opcode) {
case Const.TABLESWITCH:
low = bytes.readInt();
high = bytes.readInt();
offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
jump_table = new int[high - low + 1];
for (int i = 0; i < jump_table.length; i++) {
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(low + i).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int element : jump_table) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(element).append(""\"">"").append(element).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.LOOKUPSWITCH:
int npairs = bytes.readInt();
offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
jump_table = new int[npairs];
default_offset += offset;
buf.append(""<TABLE BORDER=1><TR>"");
for (int i = 0; i < npairs; i++) {
int match = bytes.readInt();
jump_table[i] = offset + bytes.readInt();
buf.append(""<TH>"").append(match).append(""</TH>"");
}
buf.append(""<TH>default</TH></TR>\n<TR>"");
for (int i = 0; i < npairs; i++) {
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(jump_table[i]).append(""\"">"").append(jump_table[i]).append(""</A></TD>"");
}
buf.append(""<TD><A HREF=\""#code"").append(method_number).append(""@"").append(default_offset).append(""\"">"").append(default_offset).append(""</A></TD></TR>\n</TABLE>\n"");
break;
case Const.GOTO:
case Const.IFEQ:
case Const.IFGE:
case Const.IFGT:
case Const.IFLE:
case Const.IFLT:
case Const.IFNE:
case Const.IFNONNULL:
case Const.IFNULL:
case Const.IF_ACMPEQ:
case Const.IF_ACMPNE:
case Const.IF_ICMPEQ:
case Const.IF_ICMPGE:
case Const.IF_ICMPGT:
case Const.IF_ICMPLE:
case Const.IF_ICMPLT:
case Const.IF_ICMPNE:
case Const.JSR:
index = bytes.getIndex() + bytes.readShort() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(index).append(""\"">"").append(index).append(""</A>"");
break;
case Const.GOTO_W:
case Const.JSR_W:
int windex = bytes.getIndex() + bytes.readInt() - 1;
buf.append(""<A HREF=\""#code"").append(method_number).append(""@"").append(windex).append(""\"">"").append(windex).append(""</A>"");
break;
case Const.ALOAD:
case Const.ASTORE:
case Const.DLOAD:
case Const.DSTORE:
case Const.FLOAD:
case Const.FSTORE:
case Const.ILOAD:
case Const.ISTORE:
case Const.LLOAD:
case Const.LSTORE:
case Const.RET:
if (wide) {
vindex = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
}
buf.append(""%"").append(vindex);
break;
case Const.WIDE:
wide = true;
buf.append(""(wide)"");
break;
case Const.NEWARRAY:
buf.append(""<FONT COLOR=\""#00FF00\"">"").append(Const.getTypeName(bytes.readByte())).append(""</FONT>"");
break;
case Const.GETFIELD:
case Const.GETSTATIC:
case Const.PUTFIELD:
case Const.PUTSTATIC:
index = bytes.readShort();
ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index, Const.CONSTANT_Fieldref);
class_index = c1.getClassIndex();
name = constant_pool.getConstantString(class_index, Const.CONSTANT_Class);
name = Utility.compactClassName(name, false);
index = c1.getNameAndTypeIndex();
String field_name = constant_pool.constantToString(index, Const.CONSTANT_NameAndType);
if (name.equals(class_name)) {
buf.append(""<A HREF=\"""").append(class_name).append(""_methods.html#field"").append(field_name).append(""\"" TARGET=Methods>"").append(field_name).append(""</A>\n"");
} else {
buf.append(constant_html.referenceConstant(class_index)).append(""."").append(field_name);
}
break;
case Const.CHECKCAST:
case Const.INSTANCEOF:
case Const.NEW:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.INVOKESPECIAL:
case Const.INVOKESTATIC:
case Const.INVOKEVIRTUAL:
case Const.INVOKEINTERFACE:
case Const.INVOKEDYNAMIC:
int m_index = bytes.readShort();
String str;
if (opcode == Const.INVOKEINTERFACE) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
} else if (opcode == Const.INVOKEDYNAMIC) {
bytes.readUnsignedByte();
bytes.readUnsignedByte();
ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);
index = c.getNameAndTypeIndex();
name = ""#"" + c.getBootstrapMethodAttrIndex();
} else {
// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to
ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index, Const.CONSTANT_Methodref);
class_index = c.getClassIndex();
index = c.getNameAndTypeIndex();
name = Class2HTML.referenceClass(class_index);
}
str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(index, Const.CONSTANT_NameAndType)));
ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index, Const.CONSTANT_NameAndType);
signature = constant_pool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);
String[] args = Utility.methodSignatureArgumentTypes(signature, false);
String type = Utility.methodSignatureReturnType(signature, false);
buf.append(name).append("".<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(m_index).append(""\"" TARGET=ConstantPool>"").append(str).append(""</A>"").append(""("");
for (int i = 0; i < args.length; i++) {
buf.append(Class2HTML.referenceType(args[i]));
if (i < args.length - 1) {
buf.append("", "");
}
}
buf.append(""):"").append(Class2HTML.referenceType(type));
break;
case Const.LDC_W:
case Const.LDC2_W:
index = bytes.readShort();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.LDC:
index = bytes.readUnsignedByte();
buf.append(""<A HREF=\"""").append(class_name).append(""_cp.html#cp"").append(index).append(""\"" TARGET=\""ConstantPool\"">"").append(Class2HTML.toHTML(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag()))).append(""</a>"");
break;
case Const.ANEWARRAY:
index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
case Const.MULTIANEWARRAY:
index = bytes.readShort();
int dimensions = bytes.readByte();
buf.append(constant_html.referenceConstant(index)).append("":"").append(dimensions).append(""-dimensional"");
break;
case Const.IINC:
if (wide) {
vindex = bytes.readShort();
constant = bytes.readShort();
wide = false;
} else {
vindex = bytes.readUnsignedByte();
constant = bytes.readByte();
}
buf.append(""%"").append(vindex).append("" "").append(constant);
break;
default:
if (Const.getNoOfOperands(opcode) > 0) {
for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {
switch(Const.getOperandType(opcode, i)) {
case Const.T_BYTE:
buf.append(bytes.readUnsignedByte());
break;
case // Either branch or index
Const.T_SHORT:
buf.append(bytes.readShort());
break;
case Const.T_INT:
buf.append(bytes.readInt());
break;
default:
// Never reached
throw new IllegalStateException(""Unreachable default case reached! "" + Const.getOperandType(opcode, i));
}
buf.append(""&nbsp;"");
}
}
}
buf.append(""</TD>"");
return buf.toString();
}",0,False
303,"ConstantHTML(final String dir, final String class_name, final String class_package, final Method[] methods, final ConstantPool constant_pool) throws IOException {
this.class_name = class_name;
this.class_package = class_package;
this.constant_pool = constant_pool;
this.methods = methods;
constants = constant_pool.getConstantPool();
file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
constant_ref = new String[constants.length];
constant_ref[0] = ""&lt;unknown&gt;"";
file.println(""<HTML><BODY BGCOLOR=\""#C0C0C0\""><TABLE BORDER=0>"");
for (int i = 1; i < constants.length; i++) {
if (i % 2 == 0) {
file.print(""<TR BGCOLOR=\""#C0C0C0\""><TD>"");
} else {
file.print(""<TR BGCOLOR=\""#A0A0A0\""><TD>"");
}
if (constants[i] != null) {
writeConstant(i);
}
file.print(""</TD></TR>\n"");
}
file.println(""</TABLE></BODY></HTML>"");
file.close();
}",0,False
304,private final boolean packFrame = false;,0,False
305,"@Override
public void update(final String classname) {
System.gc();
for (int i = 0; i < indent; i++) {
System.out.print("" "");
}
System.out.println(classname);
indent += 1;
Verifier v = VerifierFactory.getVerifier(classname);
VerificationResult vr;
vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 1:\n"" + vr);
}
vr = v.doPass2();
if (vr != VerificationResult.VR_OK) {
System.out.println(""Pass 2:\n"" + vr);
}
if (vr == VerificationResult.VR_OK) {
try {
JavaClass jc = Repository.lookupClass(v.getClassName());
for (int i = 0; i < jc.getMethods().length; i++) {
vr = v.doPass3a(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3a, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
vr = v.doPass3b(i);
if (vr != VerificationResult.VR_OK) {
System.out.println(v.getClassName() + "", Pass 3b, method "" + i + "" ['"" + jc.getMethods()[i] + ""']:\n"" + vr);
}
}
} catch (ClassNotFoundException e) {
System.err.println(""Could not find class "" + v.getClassName() + "" in Repository"");
}
}
indent -= 1;
}",0,False
306,private final IvjEventHandler ivjEventHandler = new IvjEventHandler();,0,False
307,"public LocalVariablesInfo getLocalVariablesInfo(final int method_nr) {
if (this.verify() != VerificationResult.VR_OK) {
return null;
}
if (method_nr < 0 || method_nr >= localVariablesInfos.length) {
throw new AssertionViolatedException(""Method number out of range."");
}
return localVariablesInfos[method_nr];
}",0,False
308,"@Override
public void visitField(final Field obj) {
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isFinal() && obj.isVolatile()) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isStatic()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_STATIC modifier set but hasn't!"");
}
if (!obj.isFinal()) {
throw new ClassConstraintException(""Interface field '"" + tostring(obj) + ""' must have the ACC_FINAL modifier set but hasn't!"");
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_VOLATILE | Const.ACC_TRANSIENT)) > 0) {
addMessage(""Field '"" + tostring(obj) + ""' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED,"" + "" ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored)."");
}
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
String name = obj.getName();
if (!validFieldName(name)) {
throw new ClassConstraintException(""Field '"" + tostring(obj) + ""' has illegal name '"" + obj.getName() + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
try {
Type.getType(sig);
} catch (ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by '"" + tostring(obj) + ""'."", cfe);
}
String nameanddesc = name + sig;
if (field_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two fields (like '"" + tostring(obj) + ""') are allowed have same names and descriptors!"");
}
if (field_names.contains(name)) {
addMessage(""More than one field of name '"" + name + ""' detected (but with different type descriptors). This is very unusual."");
}
field_names_and_desc.add(nameanddesc);
field_names.add(name);
Attribute[] atts = obj.getAttributes();
for (Attribute att : atts) {
if ((!(att instanceof ConstantValue)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if (!(att instanceof ConstantValue)) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Field '"" + tostring(obj) + ""' is not a ConstantValue and is therefore only of use for debuggers and such."");
}
}
}",0,False
309,"@Override
public void visitMethod(final Method obj) {
checkIndex(obj, obj.getNameIndex(), CONST_Utf8);
String name = obj.getName();
if (!validMethodName(name, true)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."");
}
checkIndex(obj, obj.getSignatureIndex(), CONST_Utf8);
String sig = ((ConstantUtf8) (cp.getConstant(obj.getSignatureIndex()))).getBytes();
Type t;
Type[] ts;
try {
t = Type.getReturnType(sig);
ts = Type.getArgumentTypes(sig);
} catch (ClassFormatException cfe) {
throw new ClassConstraintException(""Illegal descriptor (==signature) '"" + sig + ""' used by Method '"" + tostring(obj) + ""'."", cfe);
}
Type act = t;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has a return type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
for (Type element : ts) {
act = element;
if (act instanceof ArrayType) {
act = ((ArrayType) act).getBasicType();
}
if (act instanceof ObjectType) {
Verifier v = VerifierFactory.getVerifier(((ObjectType) act).getClassName());
VerificationResult vr = v.doPass1();
if (vr != VerificationResult.VR_OK) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has an argument type that does not pass verification pass 1: '"" + vr + ""'."");
}
}
}
if (name.equals(Const.STATIC_INITIALIZER_NAME) && (ts.length != 0)) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' has illegal name '"" + name + ""'."" + "" Its name resembles the class or interface initialization method"" + "" which it isn't because of its arguments (==descriptor)."");
}
if (jc.isClass()) {
int maxone = 0;
if (obj.isPrivate()) {
maxone++;
}
if (obj.isProtected()) {
maxone++;
}
if (obj.isPublic()) {
maxone++;
}
if (maxone > 1) {
throw new ClassConstraintException(""Method '"" + tostring(obj) + ""' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."");
}
if (obj.isAbstract()) {
if (obj.isFinal()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_FINAL modifier set."");
}
if (obj.isNative()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_NATIVE modifier set."");
}
if (obj.isPrivate()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_PRIVATE modifier set."");
}
if (obj.isStatic()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STATIC modifier set."");
}
if (obj.isStrictfp()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_STRICT modifier set."");
}
if (obj.isSynchronized()) {
throw new ClassConstraintException(""Abstract method '"" + tostring(obj) + ""' must not have the ACC_SYNCHRONIZED modifier set."");
}
}
if (name.equals(Const.CONSTRUCTOR_NAME)) {
// ..may have at most one of ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC set: is checked above.
if (obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isAbstract()) {
throw new ClassConstraintException(""Instance initialization method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set."");
}
}
} else {
if (!name.equals(Const.STATIC_INITIALIZER_NAME)) {
if (jc.getMajor() >= Const.MAJOR_1_8) {
if (!(obj.isPublic() ^ obj.isPrivate())) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have"" + "" exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set."");
}
if (obj.isProtected() || obj.isFinal() || obj.isSynchronized() || obj.isNative()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set."");
}
} else {
if (!obj.isPublic()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_PUBLIC modifier set but hasn't!"");
}
if (!obj.isAbstract()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must have the ACC_ABSTRACT modifier set but hasn't!"");
}
if (obj.isPrivate() || obj.isProtected() || obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isStrictfp()) {
throw new ClassConstraintException(""Interface method '"" + tostring(obj) + ""' must not have"" + "" any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED,"" + "" ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set."");
}
}
}
}
if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC | Const.ACC_PRIVATE | Const.ACC_PROTECTED | Const.ACC_STATIC | Const.ACC_FINAL | Const.ACC_SYNCHRONIZED | Const.ACC_NATIVE | Const.ACC_ABSTRACT | Const.ACC_STRICT)) > 0) {
addMessage(""Method '"" + tostring(obj) + ""' has access flag(s) other than"" + "" ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,"" + "" ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored)."");
}
String nameanddesc = name + sig;
if (method_names_and_desc.contains(nameanddesc)) {
throw new ClassConstraintException(""No two methods (like '"" + tostring(obj) + ""') are allowed have same names and desciptors!"");
}
method_names_and_desc.add(nameanddesc);
Attribute[] atts = obj.getAttributes();
int num_code_atts = 0;
for (Attribute att : atts) {
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable)) && (!(att instanceof Synthetic)) && (!(att instanceof Deprecated))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is unknown and will therefore be ignored."");
}
if ((!(att instanceof Code)) && (!(att instanceof ExceptionTable))) {
addMessage(""Attribute '"" + tostring(att) + ""' as an attribute of Method '"" + tostring(obj) + ""' is neither Code nor Exceptions and is therefore only of use for debuggers and such."");
}
if ((att instanceof Code) && (obj.isNative() || obj.isAbstract())) {
throw new ClassConstraintException(""Native or abstract methods like '"" + tostring(obj) + ""' must not have a Code attribute like '"" + tostring(att) + ""'."");
}
if (att instanceof Code) {
num_code_atts++;
}
}
if (!obj.isNative() && !obj.isAbstract() && num_code_atts != 1) {
throw new ClassConstraintException(""Non-native, non-abstract methods like '"" + tostring(obj) + ""' must have exactly one Code attribute (found: "" + num_code_atts + "")."");
}
}",0,False
310,"@Override
public void visitGETFIELD(final GETFIELD o) {
try {
Type objectref = stack().peek();
if (!((objectref instanceof ObjectType) || (objectref == Type.NULL))) {
constraintViolated(o, ""Stack top should be an object reference that's not an array reference, but is '"" + objectref + ""'."");
}
String field_name = o.getFieldName(cpg);
JavaClass jc = Repository.lookupClass(getObjectType(o).getClassName());
Field[] fields = jc.getFields();
Field f = null;
for (Field field : fields) {
if (field.getName().equals(field_name)) {
Type f_type = Type.getType(field.getSignature());
Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
break;
}
}
}
if (f == null) {
JavaClass[] superclasses = jc.getSuperClasses();
outer: for (JavaClass superclass : superclasses) {
fields = superclass.getFields();
for (Field field : fields) {
if (field.getName().equals(field_name)) {
Type f_type = Type.getType(field.getSignature());
Type o_type = o.getType(cpg);
if (f_type.equals(o_type)) {
f = field;
if ((f.getAccessFlags() & (Const.ACC_PUBLIC | Const.ACC_PROTECTED)) == 0) {
f = null;
}
break outer;
}
}
}
}
if (f == null) {
throw new AssertionViolatedException(""Field '"" + field_name + ""' not found in "" + jc.getClassName());
}
}
if (f.isProtected()) {
ObjectType classtype = getObjectType(o);
ObjectType curr = ObjectType.getInstance(mg.getClassName());
if (classtype.equals(curr) || curr.subclassOf(classtype)) {
Type t = stack().peek();
if (t == Type.NULL) {
return;
}
if (!(t instanceof ObjectType)) {
constraintViolated(o, ""The 'objectref' must refer to an object that's not an array. Found instead: '"" + t + ""'."");
}
ObjectType objreftype = (ObjectType) t;
if (!(objreftype.equals(curr) || objreftype.subclassOf(curr))) {
// TODO: One day move to Staerk-et-al's ""Set of object types"" instead of ""wider"" object types
}
}
}
// TODO: Could go into Pass 3a.
if (f.isStatic()) {
constraintViolated(o, ""Referenced field '"" + f + ""' is static which it shouldn't be."");
}
} catch (ClassNotFoundException e) {
// FIXME: maybe not the best way to handle this
throw new AssertionViolatedException(""Missing class: "" + e, e);
}
}",0,False
311,"@Override
public void visitINVOKEINTERFACE(final INVOKEINTERFACE o) {
int count = o.getCount();
if (count == 0) {
constraintViolated(o, ""The 'count' argument must not be 0."");
}
// TODO: Do we want to do anything with it?
Type t = o.getType(cpg);
if (t instanceof ObjectType) {
String name = ((ObjectType) t).getClassName();
Verifier v = VerifierFactory.getVerifier(name);
VerificationResult vr = v.doPass2();
if (vr.getStatus() != VerificationResult.VERIFIED_OK) {
constraintViolated(o, ""Class '"" + name + ""' is referenced, but cannot be loaded and resolved: '"" + vr + ""'."");
}
}
Type[] argtypes = o.getArgumentTypes(cpg);
int nargs = argtypes.length;
for (int i = nargs - 1; i >= 0; i--) {
Type fromStack = stack().peek((nargs - 1) - i);
Type fromDesc = argtypes[i];
if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {
fromDesc = Type.INT;
}
if (!fromStack.equals(fromDesc)) {
if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {
ReferenceType rFromStack = (ReferenceType) fromStack;
// TODO: This can only be checked when using Staerk-et-al's ""set of object types""
referenceTypeIsInitialized(o, rFromStack);
} else {
constraintViolated(o, ""Expecting a '"" + fromDesc + ""' but found a '"" + fromStack + ""' on the stack."");
}
}
}
Type objref = stack().peek(nargs);
if (objref == Type.NULL) {
return;
}
if (!(objref instanceof ReferenceType)) {
constraintViolated(o, ""Expecting a reference type as 'objectref' on the stack, not a '"" + objref + ""'."");
}
referenceTypeIsInitialized(o, (ReferenceType) objref);
if (!(objref instanceof ObjectType)) {
if (!(objref instanceof ArrayType)) {
constraintViolated(o, ""Expecting an ObjectType as 'objectref' on the stack, not a '"" + objref + ""'."");
} else {
objref = GENERIC_ARRAY;
}
}
// TODO: This can only be checked if we're using Staerk-et-al's ""set of object types""
int counted_count = 1;
for (int i = 0; i < nargs; i++) {
counted_count += argtypes[i].getSize();
}
if (count != counted_count) {
constraintViolated(o, ""The 'count' argument should probably read '"" + counted_count + ""' but is '"" + count + ""'."");
}
}",0,False
312,"@Override
public Object clone() {
LocalVariables lvs = new LocalVariables(locals.length);
for (int i = 0; i < locals.length; i++) {
lvs.locals[i] = this.locals[i];
}
return lvs;
}",0,False
