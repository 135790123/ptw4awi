Unnamed: 0,source,target,raw_preds
0,"@Override
public int compare(Object o1, Object o2) {
int compareCode = 0;
try {
Comparable s1 = (Comparable) this.stringEncoder.encode(o1);
Comparable s2 = (Comparable) this.stringEncoder.encode(o2);
compareCode = s1.compareTo(s2);
} catch (EncoderException ee) {
compareCode = 0;
}
return compareCode;
}",0,False
1,protected final byte PAD = PAD_DEFAULT;,0,False
2,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
3,"private static byte[] getBytes(String string, Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
4,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
5,"private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) {
int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
String saltString = m.group(4);
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
6,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
7,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
8,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
9,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
10,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
11,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
12,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
13,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
14,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
15,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
16,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0,False
17,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
18,"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",0,False
19,"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",0,False
20,"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage());
}
}",0,False
21,"public static byte[] md5(String data) {
return md5(data.getBytes());
}",0,False
22,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
23,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
24,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
25,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
26,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
27,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
28,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
29,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == '%') {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid URL encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
30,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write('%');
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
31,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
32,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
33,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
34,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
35,protected final byte PAD = PAD_DEFAULT;,0,False
36,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
37,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
38,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
39,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
40,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
41,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
42,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
43,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
44,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
45,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
46,protected final byte PAD = PAD_DEFAULT;,0,False
47,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
48,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
49,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
50,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
51,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
52,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
53,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
54,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
55,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
56,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
57,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
58,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
59,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
60,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
61,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
62,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
63,"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",0,False
64,"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",0,False
65,"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage());
}
}",0,False
66,"public static byte[] sha512(String data) {
return sha512(data.getBytes());
}",0,False
67,"public static byte[] sha384(String data) {
return sha384(data.getBytes());
}",0,False
68,"public static byte[] md5(String data) {
return md5(data.getBytes());
}",0,False
69,"public static byte[] sha(String data) {
return sha(data.getBytes());
}",0,False
70,"public static byte[] sha256(String data) {
return sha256(data.getBytes());
}",0,False
71,"private String cleanInput(String input) {
if (input == null) {
return null;
}
input = input.trim();
if (input.length() == 0) {
return null;
}
return input.toUpperCase();
}",0,False
72,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase();
}
char[] inwd = txt.toUpperCase().toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
73,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase();
}
char[] inwd = txt.toUpperCase().toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
74,"public RefinedSoundex(char[] mapping) {
this.soundexMapping = mapping;
}",0,False
75,"public static final char[] US_ENGLISH_MAPPING = ""01360240043788015936020505"".toCharArray();",0,False
76,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,False
77,"static String clean(String str) {
if (str == null || str.length() == 0) {
return str;
}
int len = str.length();
char[] chars = new char[len];
int count = 0;
for (int i = 0; i < len; i++) {
if (Character.isLetter(str.charAt(i))) {
chars[count++] = str.charAt(i);
}
}
if (count == len) {
return str.toUpperCase();
}
return new String(chars, 0, count).toUpperCase();
}",0,False
78,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
79,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
80,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
81,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
82,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
83,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
84,protected static byte ESCAPE_CHAR = '%';,0,False
85,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write('%');
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
86,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == '%') {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid URL encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
87,protected static byte ESCAPE_CHAR = '%';,0,False
88,protected final byte PAD = PAD_DEFAULT;,0,False
89,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
90,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
91,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
92,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
93,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
94,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
95,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
96,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
97,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
98,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
99,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
100,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
101,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
102,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
103,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
104,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
105,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
106,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
107,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
108,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
109,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
110,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
111,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
112,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
113,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(languages);
for (String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0,False
114,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
115,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
116,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
117,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
118,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
119,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
120,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
121,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
122,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
123,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
124,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
125,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
126,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
127,protected final byte PAD = PAD_DEFAULT;,0,False
128,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
129,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
130,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
131,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
132,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
133,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
134,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
135,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
136,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
137,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
138,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
139,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
140,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
141,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
142,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
143,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
144,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
145,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
146,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
147,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
148,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0,False
149,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
150,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
151,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
152,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
153,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
154,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
155,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
156,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
157,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
158,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
159,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
160,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
161,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
162,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
163,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
164,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
165,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
166,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
167,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(languages);
for (String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0,False
168,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
169,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
170,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
171,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
172,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
173,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
174,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
175,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
176,protected final byte PAD = PAD_DEFAULT;,0,False
177,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
178,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
179,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
180,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
181,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
182,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
183,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
184,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
185,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
186,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
187,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
188,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
189,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
190,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
191,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
192,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
193,"@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = input[inPos++];
if (b == pad) {
context.eof = true;
break;
}
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus > 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 1:
validateTrailingCharacters();
case 2:
validateCharacter(MASK_2BITS, context);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
validateTrailingCharacters();
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
validateCharacter(MASK_4BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
validateCharacter(MASK_1BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
validateTrailingCharacters();
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
validateCharacter(MASK_3BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
default:
throw new IllegalStateException(""Impossible modulus "" + context.modulus);
}
}
}",0,False
194,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
195,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
196,"private static void packInt(final int value, final byte[] dst, final int off, final int len) {
for (int i = 0; i < len; i++) {
dst[off + i] = (byte) (value >>> i * Byte.SIZE);
}
}",0,False
197,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
198,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
199,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
200,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
201,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
202,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
203,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
204,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0,False
205,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
206,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
207,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
208,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
209,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
210,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0,False
211,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
212,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
213,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
214,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_START + c0] ^ T[T8_6_START + c1]) ^ (T[T8_5_START + c2] ^ T[T8_4_START + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_START + c4] ^ T[T8_2_START + c5]) ^ (T[T8_1_START + c6] ^ T[T8_0_START + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
215,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_START + c0] ^ T[T8_6_START + c1]) ^ (T[T8_5_START + c2] ^ T[T8_4_START + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_START + c4] ^ T[T8_2_START + c5]) ^ (T[T8_1_START + c6] ^ T[T8_0_START + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
216,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
}
if (other == ANY_LANGUAGE) {
return other;
}
final SomeLanguages someLanguages = (SomeLanguages) other;
final Set<String> set = new HashSet<>(languages);
set.addAll(someLanguages.languages);
return from(set);
}",0,False
217,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
}
if (other == ANY_LANGUAGE) {
return this;
}
final SomeLanguages someLanguages = (SomeLanguages) other;
return from(languages.stream().filter(lang -> someLanguages.languages.contains(lang)).collect(Collectors.toSet()));
}",0,False
218,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
219,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return new Base64(0, BaseNCodec.getChunkSeparator(), false, decodingPolicy).decode(bytes);
}",0,False
220,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0,False
221,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
return buffer.array();
}",0,False
222,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
223,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
224,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
final int bytesLength = bytes.length;
if (strict) {
int pos = 1;
for (int i = 0; i < bytesLength - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytesLength - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytesLength - 2; i < bytesLength; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytesLength - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
225,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
226,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
227,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
228,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0,False
229,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
230,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
231,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0,False
232,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
233,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
234,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,False
235,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,False
236,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
237,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
238,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
239,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
240,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
241,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
242,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
243,protected static byte ESCAPE_CHAR = '%';,0,False
244,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
245,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
246,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
247,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
248,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
249,protected final byte PAD = PAD_DEFAULT;,0,False
250,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
251,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
252,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
253,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
254,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
255,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
256,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
257,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
258,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
259,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
260,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
261,"@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = input[inPos++];
if (b == pad) {
context.eof = true;
break;
}
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus > 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 1:
validateTrailingCharacters();
case 2:
validateCharacter(MASK_2BITS, context);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
validateTrailingCharacters();
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
validateCharacter(MASK_4BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
validateCharacter(MASK_1BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
validateTrailingCharacters();
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
validateCharacter(MASK_3BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
default:
throw new IllegalStateException(""Impossible modulus "" + context.modulus);
}
}
}",0,False
262,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
263,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
264,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
265,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
266,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
267,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
268,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0,False
269,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
270,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
271,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
272,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
273,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
274,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
275,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
276,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
277,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
278,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0,False
279,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
280,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
281,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
282,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0,False
283,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
284,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return new Base64(0, BaseNCodec.getChunkSeparator(), false, decodingPolicy).decode(bytes);
}",0,False
285,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
286,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else {
if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
}
return buffer.array();
}",0,False
287,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0,False
288,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
289,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
290,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
291,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
292,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
293,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
294,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
295,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
296,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
297,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
298,protected final byte PAD = PAD_DEFAULT;,0,False
299,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
300,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
301,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
302,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
303,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
304,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
305,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
306,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
307,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
308,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
309,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
310,protected final String charset;,0,False
311,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
312,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
}
}",0,False
313,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
if (lineLength > 0 && pos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
314,"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",0,False
315,"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",0,False
316,"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage());
}
}",0,False
317,"public static byte[] md5(String data) {
return md5(data.getBytes());
}",0,False
318,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
319,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
320,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
321,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
322,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
323,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
324,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
325,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == '%') {
try {
int u = Character.digit((char) bytes[++i], 16);
int l = Character.digit((char) bytes[++i], 16);
if (u == -1 || l == -1) {
throw new DecoderException(""Invalid URL encoding"");
}
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding"");
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
326,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write('%');
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
327,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
328,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
329,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
330,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
331,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
332,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
333,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
334,"public static int hash32(final String text) {
final byte[] bytes = text.getBytes();
return hash32(bytes, bytes.length);
}",0,False
335,"private static long[] hash128x64(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
336,"private static long[] hash128x64(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
337,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
338,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
339,"public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0,False
340,"public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0,False
341,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
342,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
343,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
344,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
345,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0,False
346,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
347,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
348,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else {
if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
}
return buffer.array();
}",0,False
349,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0,False
350,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
351,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
352,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
353,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
354,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
355,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
356,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
switch(modulus) {
case 2:
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3:
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
}
}
}",0,False
357,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
switch(modulus) {
case 2:
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3:
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
}
}
}",0,False
358,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
byte b = lineSeparator[lineSeparator.length - 1];
if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
359,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
byte b = lineSeparator[lineSeparator.length - 1];
if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
360,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
361,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
362,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,False
363,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,False
364,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
365,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
366,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
367,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
368,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
369,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
370,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
371,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
372,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
373,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
374,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
375,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
376,protected final byte PAD = PAD_DEFAULT;,0,False
377,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
378,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
379,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
380,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
381,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
382,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
383,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
384,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
385,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
386,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
387,"@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = input[inPos++];
if (b == pad) {
context.eof = true;
break;
}
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus > 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 1:
validateTrailingCharacters();
case 2:
validateCharacter(MASK_2BITS, context);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
validateTrailingCharacters();
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
validateCharacter(MASK_4BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
validateCharacter(MASK_1BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
validateTrailingCharacters();
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
validateCharacter(MASK_3BITS, context);
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
default:
throw new IllegalStateException(""Impossible modulus "" + context.modulus);
}
}
}",0,False
388,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
389,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
390,"private static void packInt(final int value, final byte[] dst, final int off, final int len) {
for (int i = 0; i < len; i++) {
dst[off + i] = (byte) (value >>> i * Byte.SIZE);
}
}",0,False
391,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
392,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
393,"public static int hash32(final byte[] data, final int length, final int seed) {
int h = seed ^ length;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 2);
int k = getLittleEndianInt(data, index);
k *= M32;
k ^= k >>> R32;
k *= M32;
h *= M32;
h ^= k;
}
final int index = (nblocks << 2);
switch(length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
}
h ^= h >>> 13;
h *= M32;
h ^= h >>> 15;
return h;
}",0,False
394,"public static long hash64(final byte[] data, final int length, final int seed) {
long h = (seed & 0xffffffffL) ^ (length * M64);
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = (i << 3);
long k = getLittleEndianLong(data, index);
k *= M64;
k ^= k >>> R64;
k *= M64;
h ^= k;
h *= M64;
}
final int index = (nblocks << 3);
switch(length - index) {
case 7:
h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
h ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
h ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
h ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
h ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
h ^= ((long) data[index] & 0xff);
h *= M64;
}
h ^= h >>> R64;
h *= M64;
h ^= h >>> R64;
return h;
}",0,False
395,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
396,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
397,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
398,"int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
399,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0,False
400,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
401,"@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
// Note: This fails to apply masking using 0xffffffffL to the seed.
long hash = seed;
final int nblocks = length >> 3;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 3);
long k = getLittleEndianLong(data, index);
k *= C1;
k = Long.rotateLeft(k, R1);
k *= C2;
hash ^= k;
hash = Long.rotateLeft(hash, R2) * M + N1;
}
long k1 = 0;
final int index = offset + (nblocks << 3);
switch(offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
}
hash ^= length;
hash = fmix64(hash);
return hash;
}",0,False
402,"@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
403,"private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
long h1 = seed;
long h2 = seed;
final int nblocks = length >> 4;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 4);
long k1 = getLittleEndianLong(data, index);
long k2 = getLittleEndianLong(data, index + 8);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
h1 = Long.rotateLeft(h1, R2);
h1 += h2;
h1 = h1 * M + N1;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
h2 = Long.rotateLeft(h2, R1);
h2 += h1;
h2 = h2 * M + N2;
}
long k1 = 0;
long k2 = 0;
final int index = offset + (nblocks << 4);
switch(offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
}
h1 ^= length;
h2 ^= length;
h1 += h2;
h2 += h1;
h1 = fmix64(h1);
h2 = fmix64(h2);
h1 += h2;
h2 += h1;
return new long[] { h1, h2 };
}",0,False
404,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
405,"public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
406,"@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
int hash = seed;
final int nblocks = length >> 2;
for (int i = 0; i < nblocks; i++) {
final int index = offset + (i << 2);
final int k = getLittleEndianInt(data, index);
hash = mix32(k, hash);
}
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
final int index = offset + (nblocks << 2);
int k1 = 0;
switch(offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
}
hash ^= length;
return fmix32(hash);
}",0,False
407,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
408,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
409,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
410,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
}
if (other == ANY_LANGUAGE) {
return this;
}
final SomeLanguages someLanguages = (SomeLanguages) other;
return from(languages.stream().filter(lang -> someLanguages.languages.contains(lang)).collect(Collectors.toSet()));
}",0,False
411,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
}
if (other == ANY_LANGUAGE) {
return other;
}
final SomeLanguages someLanguages = (SomeLanguages) other;
final Set<String> set = new HashSet<>(languages);
set.addAll(someLanguages.languages);
return from(set);
}",0,False
412,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
413,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return new Base64(0, BaseNCodec.getChunkSeparator(), false, decodingPolicy).decode(bytes);
}",0,False
414,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
return buffer.array();
}",0,False
415,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
final int expectedEncodingBytes = expectedEncodingBytes(bytes);
final boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0,False
416,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
417,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
418,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
final int bytesLength = bytes.length;
if (strict) {
int pos = 1;
for (int i = 0; i < bytesLength - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytesLength - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytesLength - 2; i < bytesLength; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytesLength - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
419,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
420,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
421,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
422,protected final byte PAD = PAD_DEFAULT;,0,False
423,"private static byte[] getBytes(String string, Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
424,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
425,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
426,"private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) {
int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
String saltString = m.group(4);
byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
427,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
428,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
429,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
430,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
431,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
432,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
433,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
434,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
435,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
436,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
437,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
438,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
439,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
440,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
441,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
442,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
443,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<String>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0,False
444,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
445,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
446,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
447,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
448,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
449,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
450,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
451,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
452,protected final byte PAD = PAD_DEFAULT;,0,False
453,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
454,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
455,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
456,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
457,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
458,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
459,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
460,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
461,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
462,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
463,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
464,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
465,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
466,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
467,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
468,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
469,protected final byte PAD = PAD_DEFAULT;,0,False
470,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
471,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
472,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
473,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
474,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
475,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
476,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
477,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
478,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
479,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
480,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
481,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
482,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
483,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
484,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
485,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
486,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
487,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
488,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
489,"@Override
public void update(final byte[] b, final int offset, final int len) {
int localCrc = crc;
final int remainder = len & 0x7;
int i = offset;
for (final int end = offset + len - remainder; i < end; i += 8) {
final int x = localCrc ^ ((((b[i] << 24) >>> 24) + ((b[i + 1] << 24) >>> 16)) + (((b[i + 2] << 24) >>> 8) + (b[i + 3] << 24)));
localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^ (T[((x << 8) >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400])) ^ ((T[((b[i + 4] << 24) >>> 24) + 0x300] ^ T[((b[i + 5] << 24) >>> 24) + 0x200]) ^ (T[((b[i + 6] << 24) >>> 24) + 0x100] ^ T[((b[i + 7] << 24) >>> 24)]));
}
switch(remainder) {
case 7:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 5:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 4:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 3:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 2:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 1:
localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
default:
}
crc = localCrc;
}",0,False
490,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
491,"@Override
public void update(final byte[] b, int off, int len) {
int localCrc = crc;
while (len > 7) {
final int c0 = (b[off + 0] ^ localCrc) & 0xff;
final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);
final int c4 = b[off + 4] & 0xff;
final int c5 = b[off + 5] & 0xff;
final int c6 = b[off + 6] & 0xff;
final int c7 = b[off + 7] & 0xff;
localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);
off += 8;
len -= 8;
}
switch(len) {
case 7:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1:
localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
default:
break;
}
crc = localCrc;
}",0,False
492,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(Math.min(languages.size(), sl.languages.size()));
for (final String lang : languages) {
if (sl.languages.contains(lang)) {
ls.add(lang);
}
}
return from(ls);
}
}",0,False
493,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages sl = (SomeLanguages) other;
final Set<String> ls = new HashSet<>(languages);
for (final String lang : sl.languages) {
ls.add(lang);
}
return from(ls);
}
}",0,False
494,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
495,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
496,"@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
if (bytes == null) {
return null;
}
int expectedEncodingBytes = expectedEncodingBytes(bytes);
boolean willEncode = expectedEncodingBytes != bytes.length;
if (willEncode || (plusForSpace && containsSpace(bytes))) {
return doEncode(bytes, expectedEncodingBytes, willEncode);
}
return bytes;
}",0,False
497,"@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.put((byte) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid percent decoding: "", e);
}
} else {
if (plusForSpace && b == '+') {
buffer.put((byte) ' ');
} else {
buffer.put(b);
}
}
}
return buffer.array();
}",0,False
498,private final byte ESCAPE_CHAR = '%';,0,False
499,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = SPACE;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
500,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == SPACE) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
501,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
if (bytes[++i] == CR) {
continue;
}
final int u = Utils.digit16(bytes[i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else if (b != CR && b != LF) {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
502,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
if (strict) {
int pos = 1;
for (int i = 0; i < bytes.length - 3; i++) {
final int b = getUnsignedOctet(i, bytes);
if (pos < SAFE_LENGTH) {
pos += encodeByte(b, !printable.get(b), buffer);
} else {
encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
pos = 1;
}
}
int b = getUnsignedOctet(bytes.length - 3, bytes);
boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);
pos += encodeByte(b, encode, buffer);
// simplification: if < 6 bytes left, do a soft line break as we may need
if (pos > SAFE_LENGTH - 2) {
buffer.write(ESCAPE_CHAR);
buffer.write(CR);
buffer.write(LF);
}
for (int i = bytes.length - 2; i < bytes.length; i++) {
b = getUnsignedOctet(i, bytes);
encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));
encodeByte(b, encode, buffer);
}
} else {
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
}
return buffer.toByteArray();
}",0,False
503,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL_SAFE;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Utils.hexDigit(b >> 4);
final char hex2 = Utils.hexDigit(b);
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
504,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
505,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
506,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
507,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
508,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
509,protected final byte PAD = PAD_DEFAULT;,0,False
510,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
511,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
512,"protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
513,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
514,"protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
515,"protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (int i = 0; i < bytes.length; i++) {
if (bytes[i] == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
516,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
517,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
518,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
519,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
520,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
521,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
522,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
523,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
524,protected final byte PAD = PAD_DEFAULT;,0,False
525,"public static byte[] getBytesUnchecked(String string, String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
526,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",0,False
527,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
528,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
529,"@Override
protected byte[] doDecoding(byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
530,"@Override
protected byte[] doEncoding(byte[] bytes) {
if (bytes == null) {
return null;
}
byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
531,"@Override
protected byte[] doDecoding(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
532,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
533,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
534,"public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
535,"public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
int u = Utils.digit16(bytes[++i]);
int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
536,protected final byte PAD = PAD_DEFAULT;,0,False
537,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
538,"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
if (string == null) {
return null;
}
try {
return string.getBytes(charsetName);
} catch (final UnsupportedEncodingException e) {
throw StringUtils.newIllegalStateException(charsetName, e);
}
}",0,False
539,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",0,False
540,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",0,False
541,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
542,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",0,False
543,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",0,False
544,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages sl = (SomeLanguages) other;
if (sl.languages.containsAll(languages)) {
return this;
} else {
final Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}
}",0,False
545,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.encodeBase64(bytes);
}",0,False
546,"@Override
protected byte[] doDecoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
return Base64.decodeBase64(bytes);
}",0,False
547,"@Override
protected byte[] doEncoding(final byte[] bytes) {
if (bytes == null) {
return null;
}
final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
if (this.encodeBlanks) {
for (int i = 0; i < data.length; i++) {
if (data[i] == BLANK) {
data[i] = UNDERSCORE;
}
}
}
return data;
}",0,False
548,"@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
boolean hasUnderscores = false;
for (final byte b : bytes) {
if (b == UNDERSCORE) {
hasUnderscores = true;
break;
}
}
if (hasUnderscores) {
final byte[] tmp = new byte[bytes.length];
for (int i = 0; i < bytes.length; i++) {
final byte b = bytes[i];
if (b != UNDERSCORE) {
tmp[i] = b;
} else {
tmp[i] = BLANK;
}
}
return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
}
return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}",0,False
549,"public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (printable == null) {
printable = PRINTABLE_CHARS;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (printable.get(b)) {
buffer.write(b);
} else {
encodeQuotedPrintable(b, buffer);
}
}
return buffer.toByteArray();
}",0,False
550,"public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid quoted-printable encoding"", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
551,"public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
if (bytes == null) {
return null;
}
if (urlsafe == null) {
urlsafe = WWW_FORM_URL;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (final byte c : bytes) {
int b = c;
if (b < 0) {
b = 256 + b;
}
if (urlsafe.get(b)) {
if (b == ' ') {
b = '+';
}
buffer.write(b);
} else {
buffer.write(ESCAPE_CHAR);
final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
buffer.write(hex1);
buffer.write(hex2);
}
}
return buffer.toByteArray();
}",0,False
552,"public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
if (bytes == null) {
return null;
}
final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
for (int i = 0; i < bytes.length; i++) {
final int b = bytes[i];
if (b == '+') {
buffer.write(' ');
} else if (b == ESCAPE_CHAR) {
try {
final int u = Utils.digit16(bytes[++i]);
final int l = Utils.digit16(bytes[++i]);
buffer.write((char) ((u << 4) + l));
} catch (final ArrayIndexOutOfBoundsException e) {
throw new DecoderException(""Invalid URL encoding: "", e);
}
} else {
buffer.write(b);
}
}
return buffer.toByteArray();
}",0,False
553,"public int compareTo(Phoneme o) {
for (int i = 0; i < phonemeText.length(); i++) {
if (i >= o.phonemeText.length()) {
return +1;
}
int c = phonemeText.charAt(i) - o.phonemeText.charAt(i);
if (c != 0) {
return c;
}
}
if (phonemeText.length() < o.phonemeText.length()) {
return -1;
}
return 0;
}",0,False
554,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
555,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
556,"@Override
public LanguageSet merge(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return this;
} else if (other == ANY_LANGUAGE) {
return other;
} else {
final SomeLanguages someLanguages = (SomeLanguages) other;
final Set<String> set = new HashSet<>(languages);
set.addAll(someLanguages.languages);
return from(set);
}
}",0,False
557,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 2:
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 3:
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 4:
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
context.buffer[context.pos++] = PAD;
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
context.buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0,False
558,"private static int[] desSetKey(byte[] key) {
int[] schedule = new int[32];
int c = fourBytesToInt(key, 0);
int d = fourBytesToInt(key, 4);
int[] results = new int[2];
permOp(d, c, 4, 0xf0f0f0f, results);
d = results[0];
c = results[1];
c = hPermOp(c, -2, 0xcccc0000);
d = hPermOp(d, -2, 0xcccc0000);
permOp(d, c, 1, 0x55555555, results);
d = results[0];
c = results[1];
permOp(c, d, 8, 0xff00ff, results);
c = results[0];
d = results[1];
permOp(d, c, 1, 0x55555555, results);
d = results[0];
c = results[1];
d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;
c &= 0xfffffff;
int j = 0;
for (int i = 0; i < 16; i++) {
if (SHIFT2[i]) {
c = c >>> 2 | c << 26;
d = d >>> 2 | d << 26;
} else {
c = c >>> 1 | c << 27;
d = d >>> 1 | d << 27;
}
c &= 0xfffffff;
d &= 0xfffffff;
int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] | SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] | SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];
int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] | SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];
schedule[j++] = (t << 16 | s & 0xffff) & 0xffffffff;
s = s >>> 16 | t & 0xffff0000;
s = s << 4 | s >>> 28;
schedule[j++] = s & 0xffffffff;
}
return schedule;
}",1,False
559,"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
final byte[] buffer = ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
final int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus >= 2) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
context.lbitWorkArea = context.lbitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
context.lbitWorkArea = context.lbitWorkArea >> 1;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
context.lbitWorkArea = context.lbitWorkArea >> 6;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
context.lbitWorkArea = context.lbitWorkArea >> 3;
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
}
}
}",1,False
560,"public static String crypt(byte[] original, String salt) {
if (salt == null) {
Random randomGenerator = new Random();
int numSaltChars = SALT_CHARS.length;
salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
} else if (!salt.matches(""^["" + B64.B64T + ""]{2,}$"")) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
for (; salt.length() < 2; salt = salt + ""A"") {
}
StringBuilder buffer = new StringBuilder(""             "");
char charZero = salt.charAt(0);
char charOne = salt.charAt(1);
buffer.setCharAt(0, charZero);
buffer.setCharAt(1, charOne);
int eSwap0 = CON_SALT[charZero];
int eSwap1 = CON_SALT[charOne] << 4;
byte[] key = new byte[8];
for (int i = 0; i < key.length; i++) {
key[i] = 0;
}
for (int i = 0; i < key.length && i < original.length; i++) {
int iChar = original[i];
key[i] = (byte) (iChar << 1);
}
int[] schedule = desSetKey(key);
int[] out = body(schedule, eSwap0, eSwap1);
byte[] b = new byte[9];
intToFourBytes(out[0], b, 0);
intToFourBytes(out[1], b, 4);
b[8] = 0;
int i = 2;
int y = 0;
int u = 128;
for (; i < 13; i++) {
int j = 0;
int c = 0;
for (; j < 6; j++) {
c <<= 1;
if ((b[y] & u) != 0) {
c |= 0x1;
}
u >>>= 1;
if (u == 0) {
y++;
u = 128;
}
buffer.setCharAt(i, (char) COV2CHAR[c]);
}
}
return buffer.toString();
}",1,False
561,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1,False
562,protected static byte ESCAPE_CHAR = '%';,0,False
563,"public String metaphone(final String txt) {
boolean hard = false;
final int txtLength = txt.length();
if (txt == null || txtLength == 0) {
return """";
}
if (txtLength == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
final StringBuilder local = new StringBuilder(40);
final StringBuilder code = new StringBuilder(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
final int wdsz = local.length();
int n = 0;
while (code.length() < this.getMaxCodeLen() && n < wdsz) {
final char symb = local.charAt(n);
if (symb != 'C' && isPreviousChar(local, n, symb)) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if (n == 0 && wdsz >= 3 && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && FRONTV.indexOf(local.charAt(n + 2)) >= 0) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if (n > 0 && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0 && !hard) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if (n > 0 && VARSON.indexOf(local.charAt(n - 1)) >= 0) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
default:
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",1,False
564,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
// top 6 bits:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0,False
565,"public final int end() {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",0,False
566,"@Deprecated
public static int hash32(final String data) {
final byte[] bytes = data.getBytes();
return hash32(bytes, 0, bytes.length, DEFAULT_SEED);
}",1,False
567,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
568,private final Languages.LanguageSet languageSet;,1,False
569,"private void run(String prefix, final MessageDigest messageDigest) throws IOException {
if (source == null) {
println(prefix, DigestUtils.digest(messageDigest, System.in));
return;
}
final File file = new File(source);
if (file.isFile()) {
println(prefix, DigestUtils.digest(messageDigest, file), source);
} else if (file.isDirectory()) {
run(prefix, messageDigest, file.listFiles());
} else {
final byte[] bytes = source.getBytes(Charset.defaultCharset());
println(prefix, DigestUtils.digest(messageDigest, bytes));
}
}",0,False
570,"public Soundex(char[] mapping) {
this.soundexMapping = mapping;
}",1,False
571,"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
final byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
final int result = DECODE_TABLE[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (context.eof && context.modulus != 0) {
final byte[] buffer = ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
context.ibitWorkArea = context.ibitWorkArea >> 4;
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
case 3:
context.ibitWorkArea = context.ibitWorkArea >> 2;
buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
}
}
}",1,False
572,private final byte ESCAPE_CHAR = '%';,1,False
573,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
if (buffer == null || buffer.length - pos < decodeSize) {
resizeBuffer();
}
switch(modulus) {
case 2:
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3:
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
}
}
}",0,False
574,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
575,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",1,False
576,protected final byte PAD = PAD_DEFAULT;,0,False
577,protected static byte ESCAPE_CHAR = '%';,1,False
578,"public static byte[] sha384(String data) {
return sha384(data.getBytes());
}",1,False
579,"public byte[] decode(byte[] array) throws DecoderException {
return decodeHex(new String(array).toCharArray());
}",1,False
580,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
final int savedPos = context.pos;
switch(context.modulus) {
case 1:
// top 6 bits:
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
}
break;
case 2:
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",1,False
581,"private static byte[] getBytes(final String string, final Charset charset) {
if (string == null) {
return null;
}
return string.getBytes(charset);
}",0,False
582,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
byte b = lineSeparator[lineSeparator.length - 1];
if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
if (buffer == null || buffer.length - pos < encodeSize) {
resizeBuffer();
}
modulus = (++modulus) % 3;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
x = (x << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[x & MASK_6BITS];
currentLinePos += 4;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
583,"private static int[] body(int[] schedule, int eSwap0, int eSwap1) {
int left = 0;
int right = 0;
int t = 0;
for (int j = 0; j < 25; j++) {
for (int i = 0; i < 32; i += 4) {
left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);
right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);
}
t = left;
left = right;
right = t;
}
t = right;
right = left >>> 1 | left << 31;
left = t >>> 1 | t << 31;
left &= 0xffffffff;
right &= 0xffffffff;
int[] results = new int[2];
permOp(right, left, 1, 0x55555555, results);
right = results[0];
left = results[1];
permOp(left, right, 8, 0xff00ff, results);
left = results[0];
right = results[1];
permOp(right, left, 2, 0x33333333, results);
right = results[0];
left = results[1];
permOp(left, right, 16, 65535, results);
left = results[0];
right = results[1];
permOp(right, left, 4, 0xf0f0f0f, results);
right = results[0];
left = results[1];
int[] out = new int[2];
out[0] = left;
out[1] = right;
return out;
}",1,False
584,private final byte ESCAPE_CHAR = '%';,1,False
585,"public String colognePhonetic(String text) {
if (text == null) {
return null;
}
final CologneInputBuffer input = new CologneInputBuffer(preprocess(text));
final CologneOutputBuffer output = new CologneOutputBuffer(input.length() * 2);
char nextChar;
final char CHAR_FIRST_POS = '/';
final char CHAR_IGNORE = '-';
char lastChar = CHAR_IGNORE;
char lastCode = CHAR_FIRST_POS;
char code;
char chr;
while (input.length() > 0) {
chr = input.removeNext();
if (input.length() > 0) {
nextChar = input.getNextChar();
} else {
nextChar = CHAR_IGNORE;
}
if (arrayContains(AEIJOUY, chr)) {
code = '0';
} else if (chr == 'H' || chr < 'A' || chr > 'Z') {
if (lastCode == CHAR_FIRST_POS) {
continue;
}
code = CHAR_IGNORE;
} else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {
code = '1';
} else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {
code = '2';
} else if (arrayContains(WFPV, chr)) {
code = '3';
} else if (arrayContains(GKQ, chr)) {
code = '4';
} else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {
code = '4';
input.addLeft('S');
} else if (chr == 'S' || chr == 'Z') {
code = '8';
} else if (chr == 'C') {
if (lastCode == CHAR_FIRST_POS) {
if (arrayContains(AHKLOQRUX, nextChar)) {
code = '4';
} else {
code = '8';
}
} else {
if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {
code = '8';
} else {
code = '4';
}
}
} else if (arrayContains(TDX, chr)) {
code = '8';
} else if (chr == 'R') {
code = '7';
} else if (chr == 'L') {
code = '5';
} else if (chr == 'M' || chr == 'N') {
code = '6';
} else {
code = chr;
throw new RuntimeException();
}
if (code != CHAR_IGNORE && (lastCode != code && (code != '0' || lastCode == CHAR_FIRST_POS) || code < '0' || code > '8')) {
output.addRight(code);
}
lastChar = chr;
lastCode = code;
}
return output.toString();
}",0,False
586,"public static String crypt(byte[] original, String salt) {
if (salt == null) {
Random randomGenerator = new Random();
int numSaltChars = SALT_CHARS.length;
salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
} else if (!salt.matches(""^["" + B64.B64T + ""]{2,}$"")) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
for (; salt.length() < 2; salt = salt + ""A"") {
}
StringBuilder buffer = new StringBuilder(""             "");
char charZero = salt.charAt(0);
char charOne = salt.charAt(1);
buffer.setCharAt(0, charZero);
buffer.setCharAt(1, charOne);
int eSwap0 = CON_SALT[charZero];
int eSwap1 = CON_SALT[charOne] << 4;
byte[] key = new byte[8];
for (int i = 0; i < key.length; i++) {
key[i] = 0;
}
for (int i = 0; i < key.length && i < original.length; i++) {
int iChar = original[i];
key[i] = (byte) (iChar << 1);
}
int[] schedule = desSetKey(key);
int[] out = body(schedule, eSwap0, eSwap1);
byte[] b = new byte[9];
intToFourBytes(out[0], b, 0);
intToFourBytes(out[1], b, 4);
b[8] = 0;
int i = 2;
int y = 0;
int u = 128;
for (; i < 13; i++) {
int j = 0;
int c = 0;
for (; j < 6; j++) {
c <<= 1;
if ((b[y] & u) != 0) {
c |= 0x1;
}
u >>>= 1;
if (u == 0) {
y++;
u = 128;
}
buffer.setCharAt(i, (char) COV2CHAR[c]);
}
}
return buffer.toString();
}",0,False
587,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0,False
588,"public Base64(int lineLength, byte[] lineSeparator) {
this.lineLength = lineLength;
this.lineSeparator = lineSeparator;
if (lineLength > 0) {
this.encodeSize = 4 + lineSeparator.length;
} else {
this.encodeSize = 4;
}
this.decodeSize = encodeSize - 1;
if (containsBase64Byte(lineSeparator)) {
String sep;
try {
sep = new String(lineSeparator, ""UTF-8"");
} catch (UnsupportedEncodingException uee) {
sep = new String(lineSeparator);
}
throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
}
}",1,False
589,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
590,"public static final char[] US_ENGLISH_MAPPING = ""01360240043788015936020505"".toCharArray();",1,False
591,"public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
this.lineLength = lineLength;
this.lineSeparator = new byte[lineSeparator.length];
System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
if (lineLength > 0) {
this.encodeSize = 4 + lineSeparator.length;
} else {
this.encodeSize = 4;
}
this.decodeSize = this.encodeSize - 1;
if (containsBase64Byte(lineSeparator)) {
String sep;
try {
sep = new String(lineSeparator, ""UTF-8"");
} catch (UnsupportedEncodingException uee) {
sep = new String(lineSeparator);
}
throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
}
this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
}",1,False
592,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
593,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1,False
594,"private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) throws Exception {
int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Invalid salt value: null"");
}
Pattern p = Pattern.compile(""^\\$([56])\\$(rounds=(\\d+)\\$)?([\\.\\/a-zA-Z0-9]{1,16}).*"");
Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.valueOf(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
String saltString = m.group(4);
byte[] saltBytes = saltString.getBytes(""UTF-8"");
int saltLen = saltBytes.length;
MessageDigest ctx = MessageDigest.getInstance(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = MessageDigest.getInstance(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = MessageDigest.getInstance(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = MessageDigest.getInstance(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = MessageDigest.getInstance(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
StringBuilder buffer = new StringBuilder(saltPrefix + (roundsCustom ? ROUNDS_PREFIX + rounds + ""$"" : """") + saltString + ""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",1,False
595,"public static byte[] sha512(String data) {
return sha512(data.getBytes());
}",1,False
596,protected final byte PAD = '=';,1,False
597,"public static long[] hash128(final String data) {
final byte[] origin = data.getBytes();
return hash128(origin, 0, origin.length, DEFAULT_SEED);
}",0,False
598,"public static long hash64(final String text) {
final byte[] bytes = text.getBytes();
return hash64(bytes, bytes.length);
}",1,False
599,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
600,"public static int hash32(final String text) {
final byte[] bytes = text.getBytes();
return hash32(bytes, bytes.length);
}",1,False
601,"private void run(String prefix, final MessageDigest messageDigest) throws IOException {
if (inputs == null) {
println(prefix, DigestUtils.digest(messageDigest, System.in));
return;
}
for (String source : inputs) {
final File file = new File(source);
if (file.isFile()) {
println(prefix, DigestUtils.digest(messageDigest, file), source);
} else if (file.isDirectory()) {
run(prefix, messageDigest, file.listFiles());
} else {
final byte[] bytes = source.getBytes(Charset.defaultCharset());
println(prefix, DigestUtils.digest(messageDigest, bytes));
}
}
}",1,False
602,protected static byte ESCAPE_CHAR = '%';,0,False
603,"public static String crypt(byte[] original, String salt) {
if (salt == null) {
Random randomGenerator = new Random();
int numSaltChars = SALT_CHARS.length;
salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
} else if (!salt.matches(""^["" + B64.B64T + ""]{2,}$"")) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
for (; salt.length() < 2; salt = salt + ""A"") {
}
StringBuilder buffer = new StringBuilder(""             "");
char charZero = salt.charAt(0);
char charOne = salt.charAt(1);
buffer.setCharAt(0, charZero);
buffer.setCharAt(1, charOne);
int eSwap0 = CON_SALT[charZero];
int eSwap1 = CON_SALT[charOne] << 4;
byte[] key = new byte[8];
for (int i = 0; i < key.length; i++) {
key[i] = 0;
}
for (int i = 0; i < key.length && i < original.length; i++) {
int iChar = original[i];
key[i] = (byte) (iChar << 1);
}
int[] schedule = desSetKey(key);
int[] out = body(schedule, eSwap0, eSwap1);
byte[] b = new byte[9];
intToFourBytes(out[0], b, 0);
intToFourBytes(out[1], b, 4);
b[8] = 0;
int i = 2;
int y = 0;
int u = 128;
for (; i < 13; i++) {
int j = 0;
int c = 0;
for (; j < 6; j++) {
c <<= 1;
if ((b[y] & u) != 0) {
c |= 0x1;
}
u >>>= 1;
if (u == 0) {
y++;
u = 128;
}
buffer.setCharAt(i, (char) COV2CHAR[c]);
}
}
return buffer.toString();
}",0,False
604,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
int savedPos = context.pos;
switch(context.modulus) {
case 1:
// top 6 bits:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2:
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
}
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
if (0 == context.modulus) {
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",0,False
605,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",1,False
606,"public Languages.LanguageSet guessLanguages(String input) {
// todo: locale?
String text = input.toLowerCase();
// System.out.println(""Testing text: '"" + text + ""'"");
Set<String> langs = new HashSet<String>(this.languages.getLanguages());
for (LangRule rule : this.rules) {
if (rule.matches(text)) {
if (rule.acceptOnMatch) {
langs.retainAll(rule.languages);
} else {
langs.removeAll(rule.languages);
}
// System.out.println(""Current languages: "" + langs);
} else {
}
}
Languages.LanguageSet ls = Languages.LanguageSet.from(langs);
return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;
}",1,False
607,"public Object encode(Object object) throws EncoderException {
try {
byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
return encodeHex(byteArray);
} catch (ClassCastException e) {
throw new EncoderException(e.getMessage(), e);
}
}",1,False
608,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus) {
return;
}
ensureBufferSize(encodeSize);
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
if (lineLength > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BITS_PER_ENCODED_BYTE;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
609,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus) {
return;
}
ensureBufferSize(encodeSize);
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
if (lineLength > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BITS_PER_ENCODED_CHAR;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
610,"@Deprecated
public static long[] hash128(final String data) {
final byte[] bytes = data.getBytes();
return hash128(bytes, 0, bytes.length, DEFAULT_SEED);
}",1,False
611,"@Override
public LanguageSet restrictTo(LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
SomeLanguages sl = (SomeLanguages) other;
Set<String> ls = new HashSet<String>(this.languages);
ls.retainAll(sl.languages);
return from(ls);
}
}",0,False
612,"public String metaphone(String txt) {
boolean hard = false;
if (txt == null || txt.length() == 0) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase(java.util.Locale.ENGLISH);
}
char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
StringBuilder local = new StringBuilder(40);
StringBuilder code = new StringBuilder(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while (code.length() < this.getMaxCodeLen() && n < wdsz) {
char symb = local.charAt(n);
if (symb != 'C' && isPreviousChar(local, n, symb)) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if (n == 0 && wdsz >= 3 && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && FRONTV.indexOf(local.charAt(n + 2)) >= 0) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if (n > 0 && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0 && !hard) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if (n > 0 && VARSON.indexOf(local.charAt(n - 1)) >= 0) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",1,False
613,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
ensureBufferSize(decodeSize);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (eof && modulus >= 2) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5:
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6:
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7:
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
614,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
modulus = (++modulus) % 4;
x = x << 6;
switch(modulus) {
case 3:
x = x << 6;
case 0:
buf[pos++] = (byte) ((x >> 16) & 0xff);
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 8) & 0xff);
}
default:
eof = true;
return;
}
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (byte) ((++modulus) % 4);
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & 0xff);
buf[pos++] = (byte) ((x >> 8) & 0xff);
buf[pos++] = (byte) (x & 0xff);
}
}
}
}
}
}",0,False
615,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",1,False
616,"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize, context);
byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (context.eof && context.modulus != 0) {
ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
context.ibitWorkArea = context.ibitWorkArea >> 4;
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
case 3:
context.ibitWorkArea = context.ibitWorkArea >> 2;
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
617,"@SuppressWarnings(""boxing"")
@Override
public String toString() {
return String.format(""%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, "" + ""modulus=%s, pos=%s, readPos=%s]"", this.getClass().getSimpleName(), buffer, currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);
}",1,False
618,"@Override
public String toString() {
return String.format(""%s[%s]"", super.toString(), args);
}",1,False
619,"public static LanguageSet NO_LANGUAGES = new LanguageSet() {
@Override
public LanguageSet restrictTo(LanguageSet other) {
return this;
}
@Override
public boolean contains(String language) {
return false;
}
@Override
public boolean isSingleton() {
return false;
}
@Override
public String getAny() {
throw new NoSuchElementException(""Can't fetch any language from the empty language set."");
}
@Override
public boolean isEmpty() {
return true;
}
};",1,False
620,"private static int[] desSetKey(byte[] key) {
int[] schedule = new int[32];
int c = fourBytesToInt(key, 0);
int d = fourBytesToInt(key, 4);
int[] results = new int[2];
permOp(d, c, 4, 0xf0f0f0f, results);
d = results[0];
c = results[1];
c = hPermOp(c, -2, 0xcccc0000);
d = hPermOp(d, -2, 0xcccc0000);
permOp(d, c, 1, 0x55555555, results);
d = results[0];
c = results[1];
permOp(c, d, 8, 0xff00ff, results);
c = results[0];
d = results[1];
permOp(d, c, 1, 0x55555555, results);
d = results[0];
c = results[1];
d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;
c &= 0xfffffff;
int j = 0;
for (int i = 0; i < 16; i++) {
if (SHIFT2[i]) {
c = c >>> 2 | c << 26;
d = d >>> 2 | d << 26;
} else {
c = c >>> 1 | c << 27;
d = d >>> 1 | d << 27;
}
c &= 0xfffffff;
d &= 0xfffffff;
int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] | SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] | SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];
int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] | SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];
schedule[j++] = (t << 16 | s & 0xffff) & 0xffffffff;
s = s >>> 16 | t & 0xffff0000;
s = s << 4 | s >>> 28;
schedule[j++] = s & 0xffffffff;
}
return schedule;
}",1,False
621,"public static byte[] sha384(String data) {
return sha384(data.getBytes());
}",1,False
622,"private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
final int keyLen = keyBytes.length;
int rounds = ROUNDS_DEFAULT;
boolean roundsCustom = false;
if (salt == null) {
throw new IllegalArgumentException(""Salt must not be null"");
}
final Matcher m = SALT_PATTERN.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
if (m.group(3) != null) {
rounds = Integer.parseInt(m.group(3));
rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
roundsCustom = true;
}
final String saltString = m.group(4);
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final int saltLen = saltBytes.length;
MessageDigest ctx = DigestUtils.getDigest(algorithm);
ctx.update(keyBytes);
// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
ctx.update(saltBytes);
MessageDigest altCtx = DigestUtils.getDigest(algorithm);
altCtx.update(keyBytes);
altCtx.update(saltBytes);
altCtx.update(keyBytes);
byte[] altResult = altCtx.digest();
int cnt = keyBytes.length;
while (cnt > blocksize) {
ctx.update(altResult, 0, blocksize);
cnt -= blocksize;
}
ctx.update(altResult, 0, cnt);
// NB: this step differs significantly from the MD5 algorithm. It
cnt = keyBytes.length;
while (cnt > 0) {
if ((cnt & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(keyBytes);
}
cnt >>= 1;
}
altResult = ctx.digest();
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= keyLen; i++) {
altCtx.update(keyBytes);
}
byte[] tempResult = altCtx.digest();
final byte[] pBytes = new byte[keyLen];
int cp = 0;
while (cp < keyLen - blocksize) {
System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
altCtx = DigestUtils.getDigest(algorithm);
for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
altCtx.update(saltBytes);
}
tempResult = altCtx.digest();
// Remark: The salt is limited to 16 chars, how does this make sense?
final byte[] sBytes = new byte[saltLen];
cp = 0;
while (cp < saltLen - blocksize) {
System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
cp += blocksize;
}
System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
for (int i = 0; i <= rounds - 1; i++) {
ctx = DigestUtils.getDigest(algorithm);
if ((i & 1) != 0) {
ctx.update(pBytes, 0, keyLen);
} else {
ctx.update(altResult, 0, blocksize);
}
if (i % 3 != 0) {
ctx.update(sBytes, 0, saltLen);
}
if (i % 7 != 0) {
ctx.update(pBytes, 0, keyLen);
}
if ((i & 1) != 0) {
ctx.update(altResult, 0, blocksize);
} else {
ctx.update(pBytes, 0, keyLen);
}
altResult = ctx.digest();
}
// size specified above, consisting of multiple pieces:
final StringBuilder buffer = new StringBuilder(saltPrefix);
if (roundsCustom) {
buffer.append(ROUNDS_PREFIX);
buffer.append(rounds);
buffer.append(""$"");
}
buffer.append(saltString);
buffer.append(""$"");
// follows:
// characters as output:
// 1. character: the six low bits of the first byte
// 2. character: the two high bits of the first byte and the
// 3. character: the four high bytes from the second byte and
// 4. character: the six high bits from the third byte
// This was just a safeguard in the C implementation:
if (blocksize == 32) {
B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
} else {
B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
}
Arrays.fill(tempResult, (byte) 0);
Arrays.fill(pBytes, (byte) 0);
Arrays.fill(sBytes, (byte) 0);
ctx.reset();
altCtx.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
return buffer.toString();
}",1,False
623,"public String metaphone(String txt) {
boolean hard = false;
if ((txt == null) || (txt.length() == 0)) {
return """";
}
if (txt.length() == 1) {
return txt.toUpperCase();
}
char[] inwd = txt.toUpperCase().toCharArray();
StringBuffer local = new StringBuffer(40);
StringBuffer code = new StringBuffer(10);
switch(inwd[0]) {
case 'K':
case 'G':
case 'P':
if (inwd[1] == 'N') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'A':
if (inwd[1] == 'E') {
local.append(inwd, 1, inwd.length - 1);
} else {
local.append(inwd);
}
break;
case 'W':
if (inwd[1] == 'R') {
local.append(inwd, 1, inwd.length - 1);
break;
}
if (inwd[1] == 'H') {
local.append(inwd, 1, inwd.length - 1);
local.setCharAt(0, 'W');
} else {
local.append(inwd);
}
break;
case 'X':
inwd[0] = 'S';
local.append(inwd);
break;
default:
local.append(inwd);
}
int wdsz = local.length();
int n = 0;
while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
char symb = local.charAt(n);
if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
n++;
} else {
switch(symb) {
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
if (n == 0) {
code.append(symb);
}
break;
case 'B':
if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
break;
}
code.append(symb);
break;
case 'C':
if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
break;
}
if (regionMatch(local, n, ""CIA"")) {
code.append('X');
break;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break;
}
if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
code.append('K');
break;
}
if (isNextChar(local, n, 'H')) {
if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
code.append('K');
} else {
code.append('X');
}
} else {
code.append('K');
}
break;
case 'D':
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
code.append('J');
n += 2;
} else {
code.append('T');
}
break;
case 'G':
if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
break;
}
if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
break;
}
if (isPreviousChar(local, n, 'G')) {
hard = true;
} else {
hard = false;
}
if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
code.append('J');
} else {
code.append('K');
}
break;
case 'H':
if (isLastChar(wdsz, n)) {
break;
}
if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local, n + 1)) {
code.append('H');
}
break;
case 'F':
case 'J':
case 'L':
case 'M':
case 'N':
case 'R':
code.append(symb);
break;
case 'K':
if (n > 0) {
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb);
}
break;
case 'P':
if (isNextChar(local, n, 'H')) {
code.append('F');
} else {
code.append(symb);
}
break;
case 'Q':
code.append('K');
break;
case 'S':
if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T':
if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local, n, ""TCH"")) {
break;
}
if (regionMatch(local, n, ""TH"")) {
code.append('0');
} else {
code.append('T');
}
break;
case 'V':
code.append('F');
break;
case 'W':
case 'Y':
if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
code.append(symb);
}
break;
case 'X':
code.append('K');
code.append('S');
break;
case 'Z':
code.append('S');
break;
}
n++;
}
if (code.length() > this.getMaxCodeLen()) {
code.setLength(this.getMaxCodeLen());
}
}
return code.toString();
}",1,False
624,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
x = x << 6;
switch(modulus) {
case 2:
x = x << 6;
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3:
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
break;
}
eof = true;
return;
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buf[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
}",0,False
625,public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1,False
626,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
modulus = (++modulus) % 4;
x = x << 6;
switch(modulus) {
case 3:
x = x << 6;
case 0:
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
}
default:
eof = true;
return;
}
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buf[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
}",1,False
627,private final byte ESCAPE_CHAR = '%';,1,False
628,"@Override
void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(decodeSize);
byte b = in[inPos++];
if (b == PAD) {
eof = true;
break;
} else {
if (b >= 0 && b < DECODE_TABLE.length) {
int result = DECODE_TABLE[b];
if (result >= 0) {
modulus = (modulus + 1) % BYTES_PER_ENCODED_BLOCK;
bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (modulus == 0) {
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as base64 decoder is concerned: actual
if (eof && modulus != 0) {
ensureBufferSize(decodeSize);
switch(modulus) {
case 2:
bitWorkArea = bitWorkArea >> 4;
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3:
bitWorkArea = bitWorkArea >> 2;
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
629,"public static byte[] sha512(String data) {
return sha512(data.getBytes());
}",1,False
630,"@SuppressWarnings(""boxing"")
@Override
public String toString() {
return String.format(""%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, modulus=%s, pos=%s, readPos=%s]"", this.getClass().getSimpleName(), buffer, currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);
}",0,False
631,"String removeDoubleConsonants(final String name) {
String replacedName = name.toUpperCase();
for (final String dc : DOUBLE_CONSONANT) {
if (replacedName.contains(dc)) {
final String singleLetter = dc.substring(0, 1);
replacedName = replacedName.replace(dc, singleLetter);
}
}
return replacedName;
}",1,False
632,"public static Mac getInitializedMac(final HmacAlgorithms algorithm, final byte[] key) {
return getInitializedMac(algorithm, key);
}",0,False
633,protected static byte ESCAPE_CHAR = '%';,1,False
634,"int getMinRating(final int sumLength) {
int minRating = 0;
if (sumLength <= FOUR) {
minRating = FIVE;
} else if (sumLength >= FIVE && sumLength <= SEVEN) {
minRating = FOUR;
} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
minRating = THREE;
} else if (sumLength == TWELVE) {
minRating = TWO;
} else {
minRating = ONE;
}
return minRating;
}",1,False
635,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
636,"public byte[] encode(byte[] array) {
return new String(encodeHex(array)).getBytes();
}",1,False
637,"private String cleanInput(String input) {
if (input == null) {
return null;
}
input = input.trim();
if (input.length() == 0) {
return null;
}
return input.toUpperCase();
}",1,False
638,"@Override
void decode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
}
for (int i = 0; i < inAvail; i++) {
byte b = in[inPos++];
if (b == PAD) {
context.eof = true;
break;
} else {
ensureBufferSize(decodeSize, context);
if (b >= 0 && b < this.decodeTable.length) {
int result = this.decodeTable[b];
if (result >= 0) {
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
if (context.modulus == 0) {
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
}
}
}
}
}
// Two forms of EOF as far as Base32 decoder is concerned: actual
if (context.eof && context.modulus >= 2) {
ensureBufferSize(decodeSize, context);
switch(context.modulus) {
case 2:
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3:
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4:
context.lbitWorkArea = context.lbitWorkArea >> 4;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5:
context.lbitWorkArea = context.lbitWorkArea >> 1;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6:
context.lbitWorkArea = context.lbitWorkArea >> 6;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7:
context.lbitWorkArea = context.lbitWorkArea >> 3;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
}
}
}",0,False
639,"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
640,"public static byte[] sha256(String data) {
return sha256(data.getBytes());
}",1,False
641,"static String clean(String str) {
if (str == null || str.length() == 0) {
return str;
}
int len = str.length();
char[] chars = new char[len];
int count = 0;
for (int i = 0; i < len; i++) {
if (Character.isLetter(str.charAt(i))) {
chars[count++] = str.charAt(i);
}
}
if (count == len) {
return str.toUpperCase();
}
return new String(chars, 0, count).toUpperCase();
}",1,False
642,"void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2:
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
}
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (++modulus) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",1,False
643,"public final int end() {
int result = hash;
// Note: This fails to apply masking using 0xff to the 3 remaining bytes.
int k1 = 0;
switch(unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
}
result ^= totalLen;
return fmix32(result);
}",1,False
644,"private static int[] body(int[] schedule, int eSwap0, int eSwap1) {
int left = 0;
int right = 0;
int t = 0;
for (int j = 0; j < 25; j++) {
for (int i = 0; i < 32; i += 4) {
left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);
right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);
}
t = left;
left = right;
right = t;
}
t = right;
right = left >>> 1 | left << 31;
left = t >>> 1 | t << 31;
left &= 0xffffffff;
right &= 0xffffffff;
int[] results = new int[2];
permOp(right, left, 1, 0x55555555, results);
right = results[0];
left = results[1];
permOp(left, right, 8, 0xff00ff, results);
left = results[0];
right = results[1];
permOp(right, left, 2, 0x33333333, results);
right = results[0];
left = results[1];
permOp(left, right, 16, 65535, results);
left = results[0];
right = results[1];
permOp(right, left, 4, 0xf0f0f0f, results);
right = results[0];
left = results[1];
int[] out = new int[2];
out[0] = left;
out[1] = right;
return out;
}",1,False
645,"public static byte[] decodeBase64(final String base64String) {
if (base64String == null) {
return null;
}
if ("""".equals(base64String)) {
return new byte[0];
}
return ApacheModifiedMiGBase64.decode(base64String.toCharArray());
}",1,False
646,"@Deprecated
public static long[] hash128(final String data) {
final byte[] bytes = data.getBytes();
return hash128(bytes, 0, bytes.length, DEFAULT_SEED);
}",1,False
647,"public static byte[] sha256(String data) {
return sha256(data.getBytes());
}",1,False
648,"public RefinedSoundex(char[] mapping) {
this.soundexMapping = mapping;
}",1,False
649,"void decode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
}
for (int i = 0; i < inAvail; i++) {
if (buf == null || buf.length - pos < decodeSize) {
resizeBuf();
}
byte b = in[inPos++];
if (b == PAD) {
modulus = (++modulus) % 4;
x = x << 6;
switch(modulus) {
case 3:
x = x << 6;
case 0:
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
}
default:
eof = true;
return;
}
} else {
if (b >= 0 && b < base64ToInt.length) {
int result = base64ToInt[b];
if (result >= 0) {
modulus = (++modulus) % 4;
x = (x << 6) + result;
if (modulus == 0) {
buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buf[pos++] = (byte) (x & MASK_8BITS);
}
}
}
}
}
}",1,False
650,"public static byte[] sha(String data) {
return sha(data.getBytes());
}",1,False
651,"public long getEncodedLength(byte[] pArray) {
long len = ((pArray.length + unencodedBlockSize - 1) / unencodedBlockSize) * encodedBlockSize;
if (lineLength > 0) {
len += ((len + lineLength - 1) / lineLength) * chunkSeparatorLength;
}
return len;
}",1,False
652,"public static byte[] md5(String data) {
return md5(data.getBytes());
}",1,False
653,"public static long hash64(final String text) {
final byte[] bytes = text.getBytes();
return hash64(bytes, bytes.length);
}",1,False
654,"@Override
void encode(byte[] in, int inPos, int inAvail) {
if (eof) {
return;
}
if (inAvail < 0) {
eof = true;
if (0 == modulus && lineLength == 0) {
return;
}
ensureBufferSize(encodeSize);
int savedPos = pos;
switch(modulus) {
case 1:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 3) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 2) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 11) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 6) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 1) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 4) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 19) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 14) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 9) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 4) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 1) & MASK_5BITS];
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4:
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 27) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 22) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 17) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 12) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 7) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 2) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea << 3) & MASK_5BITS];
buffer[pos++] = PAD;
break;
}
currentLinePos += pos - savedPos;
if (lineLength > 0 && currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
ensureBufferSize(encodeSize);
modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
bitWorkArea = (bitWorkArea << 8) + b;
if (0 == modulus) {
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 35) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 30) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 25) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 20) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 15) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 10) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) (bitWorkArea >> 5) & MASK_5BITS];
buffer[pos++] = encodeTable[(int) bitWorkArea & MASK_5BITS];
currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
pos += lineSeparator.length;
currentLinePos = 0;
}
}
}
}
}",0,False
655,"public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
final int keyLen = keyBytes.length;
String saltString;
if (salt == null) {
saltString = B64.getRandomSalt(8);
} else {
final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
final Matcher m = p.matcher(salt);
if (m == null || !m.find()) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
saltString = m.group(1);
}
final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);
final MessageDigest ctx = DigestUtils.getMd5Digest();
ctx.update(keyBytes);
ctx.update(prefix.getBytes(Charsets.UTF_8));
ctx.update(saltBytes);
MessageDigest ctx1 = DigestUtils.getMd5Digest();
ctx1.update(keyBytes);
ctx1.update(saltBytes);
ctx1.update(keyBytes);
byte[] finalb = ctx1.digest();
int ii = keyLen;
while (ii > 0) {
ctx.update(finalb, 0, ii > 16 ? 16 : ii);
ii -= 16;
}
Arrays.fill(finalb, (byte) 0);
ii = keyLen;
final int j = 0;
while (ii > 0) {
if ((ii & 1) == 1) {
ctx.update(finalb[j]);
} else {
ctx.update(keyBytes[j]);
}
ii >>= 1;
}
final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
finalb = ctx.digest();
for (int i = 0; i < ROUNDS; i++) {
ctx1 = DigestUtils.getMd5Digest();
if ((i & 1) != 0) {
ctx1.update(keyBytes);
} else {
ctx1.update(finalb, 0, BLOCKSIZE);
}
if (i % 3 != 0) {
ctx1.update(saltBytes);
}
if (i % 7 != 0) {
ctx1.update(keyBytes);
}
if ((i & 1) != 0) {
ctx1.update(finalb, 0, BLOCKSIZE);
} else {
ctx1.update(keyBytes);
}
finalb = ctx1.digest();
}
B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
ctx.reset();
ctx1.reset();
Arrays.fill(keyBytes, (byte) 0);
Arrays.fill(saltBytes, (byte) 0);
Arrays.fill(finalb, (byte) 0);
return passwd.toString();
}",1,False
656,"public String caverphone(String txt) {
// NOTE: Version 1.0 of Caverphone is easily derivable from this code
if (txt == null || txt.length() == 0) {
return ""1111111111"";
}
txt = txt.toLowerCase();
txt = txt.replaceAll(""[^a-z]"", """");
txt = txt.replaceAll(""e$"", """");
txt = txt.replaceAll(""^cough"", ""cou2f"");
txt = txt.replaceAll(""^rough"", ""rou2f"");
txt = txt.replaceAll(""^tough"", ""tou2f"");
txt = txt.replaceAll(""^enough"", ""enou2f"");
txt = txt.replaceAll(""^trough"", ""trou2f"");
txt = txt.replaceAll(""^gn"", ""2n"");
txt = txt.replaceAll(""^mb"", ""m2"");
txt = txt.replaceAll(""cq"", ""2q"");
txt = txt.replaceAll(""ci"", ""si"");
txt = txt.replaceAll(""ce"", ""se"");
txt = txt.replaceAll(""cy"", ""sy"");
txt = txt.replaceAll(""tch"", ""2ch"");
txt = txt.replaceAll(""c"", ""k"");
txt = txt.replaceAll(""q"", ""k"");
txt = txt.replaceAll(""x"", ""k"");
txt = txt.replaceAll(""v"", ""f"");
txt = txt.replaceAll(""dg"", ""2g"");
txt = txt.replaceAll(""tio"", ""sio"");
txt = txt.replaceAll(""tia"", ""sia"");
txt = txt.replaceAll(""d"", ""t"");
txt = txt.replaceAll(""ph"", ""fh"");
txt = txt.replaceAll(""b"", ""p"");
txt = txt.replaceAll(""sh"", ""s2"");
txt = txt.replaceAll(""z"", ""s"");
txt = txt.replaceAll(""^[aeiou]"", ""A"");
txt = txt.replaceAll(""[aeiou]"", ""3"");
txt = txt.replaceAll(""j"", ""y"");
txt = txt.replaceAll(""^y3"", ""Y3"");
txt = txt.replaceAll(""^y"", ""A"");
txt = txt.replaceAll(""y"", ""3"");
txt = txt.replaceAll(""3gh3"", ""3kh3"");
txt = txt.replaceAll(""gh"", ""22"");
txt = txt.replaceAll(""g"", ""k"");
txt = txt.replaceAll(""s+"", ""S"");
txt = txt.replaceAll(""t+"", ""T"");
txt = txt.replaceAll(""p+"", ""P"");
txt = txt.replaceAll(""k+"", ""K"");
txt = txt.replaceAll(""f+"", ""F"");
txt = txt.replaceAll(""m+"", ""M"");
txt = txt.replaceAll(""n+"", ""N"");
txt = txt.replaceAll(""w3"", ""W3"");
txt = txt.replaceAll(""wh3"", ""Wh3"");
txt = txt.replaceAll(""w$"", ""3"");
txt = txt.replaceAll(""w"", ""2"");
txt = txt.replaceAll(""^h"", ""A"");
txt = txt.replaceAll(""h"", ""2"");
txt = txt.replaceAll(""r3"", ""R3"");
txt = txt.replaceAll(""r$"", ""3"");
txt = txt.replaceAll(""r"", ""2"");
txt = txt.replaceAll(""l3"", ""L3"");
txt = txt.replaceAll(""l$"", ""3"");
txt = txt.replaceAll(""l"", ""2"");
txt = txt.replaceAll(""2"", """");
txt = txt.replaceAll(""3$"", ""A"");
txt = txt.replaceAll(""3"", """");
txt = txt + ""111111"" + ""1111"";
return txt.substring(0, 10);
}",1,False
657,"public static LanguageSet ANY_LANGUAGE = new LanguageSet() {
@Override
public LanguageSet restrictTo(LanguageSet other) {
return other;
}
@Override
public boolean contains(String language) {
return true;
}
@Override
public boolean isSingleton() {
return false;
}
@Override
public String getAny() {
throw new NoSuchElementException(""Can't fetch any language from the any language set."");
}
@Override
public boolean isEmpty() {
return false;
}
};",1,False
658,"public static String crypt(byte[] original, String salt) {
if (salt == null) {
Random randomGenerator = new Random();
int numSaltChars = SALT_CHARS.length;
salt = """" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];
} else if (!salt.matches(""^["" + B64.B64T + ""]{2,}$"")) {
throw new IllegalArgumentException(""Invalid salt value: "" + salt);
}
for (; salt.length() < 2; salt = salt + ""A"") ;
StringBuilder buffer = new StringBuilder(""             "");
char charZero = salt.charAt(0);
char charOne = salt.charAt(1);
buffer.setCharAt(0, charZero);
buffer.setCharAt(1, charOne);
int eSwap0 = CON_SALT[charZero];
int eSwap1 = CON_SALT[charOne] << 4;
byte[] key = new byte[8];
for (int i = 0; i < key.length; i++) {
key[i] = 0;
}
for (int i = 0; i < key.length && i < original.length; i++) {
int iChar = original[i];
key[i] = (byte) (iChar << 1);
}
int[] schedule = desSetKey(key);
int[] out = body(schedule, eSwap0, eSwap1);
byte[] b = new byte[9];
intToFourBytes(out[0], b, 0);
intToFourBytes(out[1], b, 4);
b[8] = 0;
int i = 2;
int y = 0;
int u = 128;
for (; i < 13; i++) {
int j = 0;
int c = 0;
for (; j < 6; j++) {
c <<= 1;
if ((b[y] & u) != 0) {
c |= 0x1;
}
u >>>= 1;
if (u == 0) {
y++;
u = 128;
}
buffer.setCharAt(i, (char) COV2CHAR[c]);
}
}
return buffer.toString();
}",0,False
659,"public static int hash32(final String text) {
final byte[] bytes = text.getBytes();
return hash32(bytes, bytes.length);
}",1,False
660,"@Deprecated
public static int hash32(final String data) {
final byte[] bytes = data.getBytes();
return hash32(bytes, 0, bytes.length, DEFAULT_SEED);
}",1,False
661,"public static int hash32(final String data) {
final byte[] origin = data.getBytes();
return hash32(origin, 0, origin.length, DEFAULT_SEED);
}",0,False
662,"@Override
void encode(byte[] in, int inPos, int inAvail, Context context) {
if (context.eof) {
return;
}
if (inAvail < 0) {
context.eof = true;
if (0 == context.modulus && lineLength == 0) {
return;
}
final byte[] buffer = ensureBufferSize(encodeSize, context);
final int savedPos = context.pos;
switch(context.modulus) {
case 1:
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 2:
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 3:
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 4:
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
buffer[context.pos++] = PAD;
break;
}
context.currentLinePos += context.pos - savedPos;
if (lineLength > 0 && context.currentLinePos > 0) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
}
} else {
for (int i = 0; i < inAvail; i++) {
final byte[] buffer = ensureBufferSize(encodeSize, context);
context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
int b = in[inPos++];
if (b < 0) {
b += 256;
}
context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
if (0 == context.modulus) {
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
if (lineLength > 0 && lineLength <= context.currentLinePos) {
System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
context.pos += lineSeparator.length;
context.currentLinePos = 0;
}
}
}
}
}",1,False
663,"public static byte[] sha(String data) {
return sha(data.getBytes());
}",1,False
664,"@Override
public LanguageSet restrictTo(final LanguageSet other) {
if (other == NO_LANGUAGES) {
return other;
} else if (other == ANY_LANGUAGE) {
return this;
} else {
final SomeLanguages someLanguages = (SomeLanguages) other;
final Set<String> set = new HashSet<>(Math.min(languages.size(), someLanguages.languages.size()));
for (final String lang : languages) {
if (someLanguages.languages.contains(lang)) {
set.add(lang);
}
}
return from(set);
}
}",0,False
