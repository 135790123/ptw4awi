source,target,raw_preds
"@Deprecated
public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"", """", """", ""CONSTANT_MethodHandle"", ""CONSTANT_MethodType"", """", ""CONSTANT_InvokeDynamic"" };",1,False
"@Deprecated
public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0,True
"return exception_table;
",0,False
"@Deprecated
public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",1,True
"@Deprecated
public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0,True
"this.bootstrap_arguments = bootstrap_arguments;
",0,False
"this.constant_pool = constant_pool;
",0,False
"current_class = classNamesJList.getSelectedValue().toString();
",1,False
"this.local_variable_table = local_variable_table;
",0,False
"@Deprecated
public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",0,True
"return local_variable_type_table;
",0,False
"this.parameter_annotation_table = parameter_annotation_table;
",0,False
"Frame._this = null;
",0,False
"public static final short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",1,False
"return annotation_table;
",0,False
"this.arg_names = arg_names;
",0,False
"@Deprecated
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"", ""LocalVariableTypeTable"", ""EnclosingMethod"", ""StackMapTable"", ""BootstrapMethods"", ""MethodParameters"" };",1,True
"this.bootstrap_arguments = bootstrap_arguments;
",0,False
"@Deprecated
public static final int[] CONSUME_STACK = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 3, 4, 3, 4, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 3, 4, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 2, 1, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 4, 2, 4, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 4, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 1, 2, 1, 0, 0, UNPREDICTABLE, 1, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, UNPREDICTABLE, 1, 1, 0, 0, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0,False
"this.line_number_table = line_number_table;
",0,False
"@Deprecated
public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",1,False
"this.evalues = datums;
",0,False
"return evalues;
",0,False
"this.bootstrap_arguments = bootstrap_arguments;
",0,False
"this.bootstrap_arguments = bootstrap_arguments;
",0,False
"return code;
",0,False
"return attributes;
",0,False
"this.constant_pool = constant_pool;
",0,False
"str = String.valueOf(((ConstantInteger) c).getBytes());
",0,False
"str = String.valueOf(((ConstantDouble) c).getBytes());
",0,False
"this.bytes = bytes;
",0,False
"this.fields = fields;
",0,False
"this.local_variable_table = local_variable_table;
",0,False
"this.parameters = parameters;
",0,False
"this.parameter_annotation_table = parameter_annotation_table;
",0,False
"return parameter_annotation_table;
",0,False
"this.map = map;
",0,False
"return types_of_locals;
",0,False
"return bytes;
",0,False
"this.bytes = bytes;
",0,False
"this.bytes = bytes;
",0,False
"this.bytes = bytes;
",0,False
"this.bytes = bytes;
",0,False
"bh_list = this;
",0,False
"ConstantClass s = (ConstantClass) c;
",0,False
"return new Double(value);
",0,False
"return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
",0,False
"return new CHECKCAST(cp.addClass((ObjectType) t));
",0,False
"int i = (l + r) / 2;
",0,False
"return new Double(((org.apache.commons.bcel6.classfile.ConstantDouble) c).getBytes());
",0,False
"Arrays.sort(lg, new Comparator<LocalVariableGen>() {
@Override
public int compare(LocalVariableGen o1, LocalVariableGen o2) {
return o1.getIndex() - o2.getIndex();
",0,False
"_out.println(""il.append(new IINC("" + i.getIndex() + "", "" + ((IINC) i).getIncrement()
",0,False
"BranchHandle bh = (BranchHandle) branch_map.get(bi);
",0,False
"dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
",0,False
"BranchHandle bh = (BranchHandle) branch_map.get(bi);
",0,False
"type = ((NEWARRAY) i).getType();
",0,False
"PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + "".html""));
",0,False
private final IvjEventHandler ivjEventHandler = new IvjEventHandler();,0,False
"LocalVariables lvs = new LocalVariables(locals.length);
for (int i=0; i<locals.length; i++){
lvs.locals[i] = this.locals[i];
}
return lvs;
",0,False
"String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",0,False
"String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0,False
"final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
",0,False
"str = constantToString(((ConstantNameAndType) c).getNameIndex(),
",0,False
"this.bytes = bytes;
",0,False
"return interfaces;
",0,False
"this.methods = methods;
",0,False
"this.interfaces = interfaces;
",0,True
"this.lineNumberTable = line_number_table;
",0,False
"this.localVariableTable = local_variable_table;
",0,False
"return parameters;
",0,False
"ch = in.read();
",0,False
"return new String(buf);
",0,False
"this.map = map;
",0,False
"buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
",0,False
"return addDouble(((ConstantDouble) c).getBytes());
",0,False
"return new SimpleElementValueGen((SimpleElementValue) value, cpool,
",0,False
"value = new Float(f);
",0,False
"return targets;
",0,False
private final InstructionHandle[] targets;,0,False
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_attributes.html""));
",0,False
"dim = ((MULTIANEWARRAY) i).getDimensions();
case Const.ANEWARRAY:
case Const.NEWARRAY:
if (type instanceof ArrayType) {
",0,False
"_out = new PrintWriter(out);
",0,False
"constant_pool = java_class.getConstantPool();
",0,False
"public static final String[] DEFAULT_IGNORED_PACKAGES = {
""java."", ""javax."", ""sun.""
};
private final Hashtable<String, Class<?>> classes = new Hashtable<>();
private final String[] ignored_packages;
private Repository repository = SyntheticRepository.getInstance();
public ClassLoader() {
this(DEFAULT_IGNORED_PACKAGES);
}
public ClassLoader(final java.lang.ClassLoader deferTo) {
super(deferTo);
this.ignored_packages = DEFAULT_IGNORED_PACKAGES;
this.repository = new ClassLoaderRepository(deferTo);
}
public ClassLoader(final String[] ignored_packages) {
this.ignored_packages = ignored_packages;
}
public ClassLoader(final java.lang.ClassLoader deferTo, final String[] ignored_packages) {
this(ignored_packages);
this.repository = new ClassLoaderRepository(deferTo);
}
@Override
protected Class<?> loadClass( final String class_name, final boolean resolve ) throws ClassNotFoundException {
Class<?> cl = null;
if ((cl = classes.get(class_name)) == null) {
for (final String ignored_package : ignored_packages) {
if (class_name.startsWith(ignored_package)) {
cl = getParent().loadClass(class_name);
break;
}
}
if (cl == null) {
JavaClass clazz = null;
if (class_name.contains(BCEL_TOKEN)) {
clazz = createClass(class_name);
} else { // Fourth try: Load classes via repository
if ((clazz = repository.loadClass(class_name)) != null) {
clazz = modifyClass(clazz);
} else {
throw new ClassNotFoundException(class_name);
}
}
if (clazz != null) {
final byte[] bytes = clazz.getBytes();
cl = defineClass(class_name, bytes, 0, bytes.length);
} else {
cl = Class.forName(class_name);
}
}
if (resolve) {
resolveClass(cl);
}
}
classes.put(class_name, cl);
return cl;
}
protected JavaClass modifyClass( final JavaClass clazz ) {
return clazz;
}
protected JavaClass createClass( final String class_name ) {
final int index = class_name.indexOf(BCEL_TOKEN);
final String real_name = class_name.substring(index + BCEL_TOKEN.length());
JavaClass clazz = null;
try {
final byte[] bytes = Utility.decode(real_name, true);
final ClassParser parser = new ClassParser(new ByteArrayInputStream(bytes), ""foo"");
clazz = parser.parse();
} catch (final IOException e) {
e.printStackTrace();
return null;
}
final ConstantPool cp = clazz.getConstantPool();
final ConstantClass cl = (ConstantClass) cp.getConstant(clazz.getClassNameIndex(),
Const.CONSTANT_Class);
final ConstantUtf8 name = (ConstantUtf8) cp.getConstant(cl.getNameIndex(),
Const.CONSTANT_Utf8);
name.setBytes(class_name.replace('.', '/'));
return clazz;
",0,False
"public static final String[] DEFAULT_IGNORED_PACKAGES = { ""java."", ""javax."", ""sun."" };",0,False
"return resolved.getFileName().toString();
",0,False
"} catch (final Exception e) {
",0,False
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
",0,False
"loadedClasses = new LinkedHashMap<String, JavaClass>(initialCapacity, cacheSize, accessOrder) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(final Map.Entry<String, JavaClass> eldest) {
return size() > cacheSize;
",0,False
"this.classLoader = new URLClassLoader(new URL[] {jrtFsPath.toUri().toURL() });
",0,True
"new GraphicalVerifier();
",0,False
"contentPane = (JPanel) this.getContentPane();
",0,False
private final IvjEventHandler ivjEventHandler = new IvjEventHandler();,0,False
"if (methodNr < 0 || methodNr >= localVariablesInfos.length) {
",0,False
"if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC|Const.ACC_PRIVATE|Const.ACC_PROTECTED|Const.ACC_STATIC|
",0,False
"@Deprecated
protected static UninitializedObjectType _this;",0,False
"objref = GENERIC_ARRAY;
",0,False
"public static final short[][] TYPE_OF_OPERANDS = { {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, { T_SHORT }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_BYTE, T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_BYTE }, {}, {}, {}, {}, {}, {}, {}, {}, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT, T_BYTE, T_BYTE }, { T_SHORT }, { T_BYTE }, { T_SHORT }, {}, {}, { T_SHORT }, { T_SHORT }, {}, {}, { T_BYTE }, { T_SHORT, T_BYTE }, { T_SHORT }, { T_SHORT }, { T_INT }, { T_INT }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} };",0,True
"public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0,False
"@Deprecated
public static final Class<?>[] EXCS_ARRAY_EXCEPTION = { NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION };",0,False
"return new StackMap(name_index, length, file, constant_pool);
",0,False
"return bootstrap_methods;
",0,False
"this.bootstrap_methods = bootstrap_methods;
",0,False
"return exception_table;
",0,False
"return code;
",0,False
"return attributes;
",0,False
"return new Float(bytes);
",0,False
"ConstantMethodType cmt = (ConstantMethodType) c;
",0,False
"str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class)
",0,False
"str = String.valueOf(((ConstantFloat) c).getBytes());
",0,False
"return constant_pool;
",0,False
"this.bytes = bytes;
",0,False
"this.interfaces = interfaces;
",0,True
"return parameterAnnotationEntries;
",0,False
"return annotation_table;
",0,False
"this.parameter_annotation_table = parameter_annotation_table;
",0,False
"this.parameter_annotation_table = parameter_annotation_table;
",0,False
"return map;
",0,False
"this.map = map;
",0,False
"this.bytes = bytes;
",0,False
"this.bytes = bytes;
",0,False
"return null;
",0,False
"ArrayType array = (ArrayType) type;
",0,False
"if (bh_list == null) {
return new BranchHandle(i);
}
BranchHandle bh = bh_list;
bh_list = (BranchHandle) bh.getNext();
",0,False
"return addInteger(((ConstantInteger) c).getBytes());
",0,False
"return new Double(value);
",0,False
"return new EnumElementValueGen((EnumElementValue) value, cpool,
",0,False
"return new SimpleElementValueGen((SimpleElementValue) value, cpool,
",0,False
"return new INSTANCEOF(cp.addClass((ObjectType) t));
",0,False
"return new Float(((org.apache.commons.bcel6.classfile.ConstantFloat) c).getBytes());
",0,False
"return indices;
",0,False
"class_package = class_name.substring(0, index);
",0,False
"this.ignored_packages = ignored_packages;
",0,False
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_code.html""));
",0,False
private final boolean packFrame = false;,0,False
"if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC|Const.ACC_PRIVATE|Const.ACC_PROTECTED|Const.ACC_STATIC|
",0,False
"return null;
",0,False
"modulus = (++modulus) % 4;
",0,False
"switch (modulus) {
case 1 :
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 :
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"if (m == null || !m.find()) {
",0,False
"} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
",0,False
"return null;
",0,False
"return md5(data.getBytes());
",0,False
"return sha(data.getBytes());
",0,True
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"if (m == null || !m.find()) {
",0,False
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (modulus) {
case 2 : 
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5 : 
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6 : 
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7 : 
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; 
buffer[pos++] = PAD;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; 
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; 
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0,False
"switch (modulus) {
case 2 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3 : 
bitWorkArea = bitWorkArea >> 2; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"return null;
",0,False
"switch(symb) {
case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
if (n == 0) {
code.append(symb);
}
break ; 
case 'B' :
if ( isPreviousChar(local, n, 'M') &&
isLastChar(wdsz, n) ) { 
break;
}
code.append(symb);
break;
case 'C' : 
if ( isPreviousChar(local, n, 'S') &&
!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) {
break;
}
if (regionMatch(local, n, ""CIA"")) { 
code.append('X');
break;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break; 
}
if (isPreviousChar(local, n, 'S') &&
isNextChar(local, n, 'H') ) { 
code.append('K') ;
break ;
}
if (isNextChar(local, n, 'H')) { 
if ((n == 0) &&
(wdsz >= 3) &&
isVowel(local,2) ) { 
code.append('K');
} else {
code.append('X'); 
}
} else {
code.append('K');
}
break ;
case 'D' :
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'G') &&
(FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { 
code.append('J'); n += 2 ;
} else {
code.append('T');
}
break ;
case 'G' : 
if (isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local,n,'H') &&
!isVowel(local,n+2)) {
break;
}
if ((n > 0) &&
( regionMatch(local, n, ""GN"") ||
regionMatch(local, n, ""GNED"") ) ) {
break; 
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true ;
} else {
hard = false ;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) &&
(!hard)) {
code.append('J');
} else {
code.append('K');
}
break ;
case 'H':
if (isLastChar(wdsz, n)) {
break ; 
}
if ((n > 0) &&
(VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local,n+1)) {
code.append('H'); 
}
break;
case 'F':
case 'J' :
case 'L' :
case 'M':
case 'N' :
case 'R' :
code.append(symb);
break;
case 'K' :
if (n > 0) { 
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb); 
}
break ;
case 'P' :
if (isNextChar(local,n,'H')) {
code.append('F');
} else {
code.append(symb);
}
break ;
case 'Q' :
code.append('K');
break;
case 'S' :
if (regionMatch(local,n,""SH"") ||
regionMatch(local,n,""SIO"") ||
regionMatch(local,n,""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T' :
if (regionMatch(local,n,""TIA"") ||
regionMatch(local,n,""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local,n,""TCH"")) {
break;
}
if (regionMatch(local,n,""TH"")) {
code.append('0');
} else {
code.append('T');
}
break ;
case 'V' :
code.append('F'); break ;
case 'W' : case 'Y' : 
if (!isLastChar(wdsz,n) &&
isVowel(local,n+1)) {
code.append(symb);
}
break ;
case 'X' :
code.append('K'); code.append('S');
break ;
case 'Z' :
code.append('S'); break ;
",0,False
"return null;
",0,False
"return null;
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"if (m == null || !m.find()) {
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"if (m == null || !m.find()) {
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
"dst[off + i] = (byte) (value >>> i * Byte.SIZE);
",0,False
"k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
",0,False
"k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
",0,False
"k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
",0,False
"switch (offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
",0,False
"final SomeLanguages someLanguages = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
protected static byte ESCAPE_CHAR = '%';,0,False
"SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
",0,False
"k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
",0,False
"return null;
",0,False
"modulus = (++modulus) % 3;
",0,False
"return null;
",0,False
"h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
",0,False
"switch (offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
",0,False
"modulus = (++modulus) % 4;
",0,False
"switch (modulus) {
case 2 : 
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3 : 
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
",0,False
"return null;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; 
buffer[pos++] = PAD;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
",0,False
"k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
",0,False
"switch (unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
",0,False
"k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
",0,False
"k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
"return null;
",0,False
"return null;
",0,False
"String replacedName = name.toUpperCase();
",0,False
"return null;
",0,False
"return null;
",0,False
"String replacedName = name.toUpperCase();
",0,False
"return null;
",0,False
"switch(len) {
case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (modulus) {
case 2 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3 : 
bitWorkArea = bitWorkArea >> 2; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0,False
"return null;
",0,False
"switch (modulus) {
case 2 : 
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5 : 
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6 : 
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7 : 
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0,False
"SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
",0,False
"String replacedName = name.toUpperCase();
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"final byte[] buffer = ensureBufferSize(encodeSize, context);
",0,False
private final Languages.LanguageSet languageSet;,1,False
private final byte ESCAPE_CHAR = '%';,1,False
protected final byte PAD = PAD_DEFAULT;,0,False
"return sha384(data.getBytes());
",1,True
"return decodeHex(new String(array).toCharArray());
",1,False
"switch (context.modulus) { 
case 1 : 
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS]; 
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS]; 
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2 : 
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
",0,False
"public static final char[] US_ENGLISH_MAPPING = ""01360240043788015936020505"".toCharArray();",1,False
"rounds = Integer.valueOf(m.group(3));
",1,False
protected final byte PAD = '=';,1,False
"final byte[] bytes = text.getBytes();
",1,True
"run(prefix, messageDigest, file.listFiles());
",1,False
"modulus = (++modulus) % BITS_PER_ENCODED_BYTE;
",0,False
"return String.format(""%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, "" +
",1,False
"public static LanguageSet NO_LANGUAGES = new LanguageSet() {
@Override
public LanguageSet restrictTo(LanguageSet other) {
return this;
}
@Override
public boolean contains(String language) {
return false;
}
@Override
public boolean isSingleton() {
return false;
}
@Override
public String getAny() {
throw new NoSuchElementException(""Can't fetch any language from the empty language set."");
}
@Override
public boolean isEmpty() {
return true;
}
};",1,False
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",1,False
"return sha256(data.getBytes());
",1,True
"final byte[] bytes = text.getBytes();
",1,True
"if (m == null || !m.find()) {
",1,False
"txt = txt.toLowerCase();
",1,False
"public static LanguageSet ANY_LANGUAGE = new LanguageSet() {
@Override
public LanguageSet restrictTo(LanguageSet other) {
return other;
}
@Override
public boolean contains(String language) {
return true;
}
@Override
public boolean isSingleton() {
return false;
}
@Override
public String getAny() {
throw new NoSuchElementException(""Can't fetch any language from the any language set."");
}
@Override
public boolean isEmpty() {
return false;
}
};",1,False
"switch (context.modulus) { 
case 1 : 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; 
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 2 : 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; 
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 3 : 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; 
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
buffer[context.pos++] = PAD;
break;
case 4 : 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; 
buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; 
buffer[context.pos++] = PAD;
",1,False
"return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
",0,False
private final Predicate<? super E> predicate;,0,False
private final Predicate<? super T> iPredicate;,0,False
private final Predicate<? super T> iPredicate;,0,False
private final Closure<? super E> iDefault;,0,False
private final Predicate<? super I>[] iPredicates;,0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"return (List<E>) super.decorated();
",0,False
"return (List<E>) decorated();
",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"return (LinkEntry<K, V>) super.getEntry(key);
",0,False
"V currentValue, nextValue;",0,False
"moveToMRU((LinkEntry<K, V>) entry);  
",0,False
"protected Node<K, V> next;",0,False
"private final Transformer<? super K, ? extends K> keyTransformer;",0,False
"return (UnmodifiableMultiValuedMap<K, V>) map;
",0,False
protected final AbstractMapMultiSet<E> parent;,0,False
"return (Set<E>) super.decorated();
",0,False
"out.writeObject(comparator());
",0,False
"parent.remove(last.getKey());
",0,False
private final Comparator<? super E> comparator;,0,False
private final Closure<? super T> iClosure;,0,False
"return null;
",0,False
private final Predicate<? super T> iPredicate2;,0,False
private final Predicate<? super T> iPredicate;,0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"return hash;
",0,False
"V currentValue, nextValue;",0,False
"buf.append(CollectionUtils.COMMA);
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
",0,False
"moveToMRU((LinkEntry<K, V>) entry);  
",0,False
"protected Node<K, V> next;",0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"final ArrayList<V> list = (ArrayList<V>) coll;
",0,False
"private final Transformer<? super K, ? extends K> keyTransformer;",0,False
"return (Set<E>) super.decorated();
",0,False
"return (Set<E>) super.decorated();
",0,False
"return (SortedSet<E>) decorated();
",0,False
"if (listSize < 0) {
",0,False
"map.size();  
",0,False
"return this.doEquals(obj, KEY);
",0,False
"return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
",0,False
"protected final Transformer<? super E, ? extends E> transformer;",0,False
private final Comparator<T> comparator;,0,False
"return null;
",0,False
"this.array = array;
",0,False
"this.keys = keys;
",0,False
"return (List<E>) super.decorated();
",0,False
"return hash;
",0,False
"buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
",0,False
"delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
",0,False
"total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
",0,False
"SynchronizedBagSet(final Set<E> set, final Object lock) {
super(set, lock);
}
",0,False
"private UnmodifiableBidiMap<V, K> inverse;",0,False
"protected final Transformer<? super E, ? extends E> transformer;",0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
private final Factory<? extends O> iFactory;,0,False
"return null;
",0,False
"return null;
",0,False
private final Predicate<? super I>[] iPredicates;,0,False
"this.array = array;
",0,False
"return this.array;
",0,False
"return (List<E>) super.decorated();
",0,False
"return (LinkEntry<K, V>) super.getEntry(key);
",0,False
protected final AbstractMapMultiSet<E> parent;,0,False
"return (Set<E>) super.decorated();
",0,False
"return (SortedSet<E>) decorated();
",0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
"return null;
",0,False
"return (List<E>) super.decorated();
",0,False
"return (List<E>) decorated();
",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"entry = entry.next();
",0,False
"return hash;
",0,False
"total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"List<V> list = (List<V>) createCollection();
",0,False
"final List<V> list = (List<V>) getMapping();
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
private transient Collection<V> valuesView;,0,False
"private final Transformer<C, K> keyTransformer;",0,False
private final Comparator<? super E> comparator;,0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
private final Predicate<? super T> iPredicate;,0,False
private final Closure<? super E> iDefault;,0,False
"return (LinkEntry<K, V>) super.getEntry(key);
",0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"final V value = last.getValue();
",0,False
"final Object value = last.getValue();
",0,False
private final Predicate<? super E> predicate;,0,False
private final Closure<? super E>[] iClosures;,0,False
private final Comparator<T> comparator;,0,False
private final Predicate<? super E> iPredicate;,0,False
"return (List<E>) super.decorated();
",0,False
"final ArrayList<V> list = (ArrayList<V>) coll;
",0,False
"return (UnmodifiableMultiValuedMap<K, V>) map;
",0,False
"return defaultValue;
",0,False
"SynchronizedBagSet(final Set<E> set, final Object lock) {
super(set, lock);
}
",0,False
"return null;
",0,False
"private final Transformer<? super I, ? extends O> iFalseTransformer;",0,False
private transient Method iCloneMethod;,0,False
"this.array = array;
",0,False
"this.keys = keys;
",0,False
"V currentValue, nextValue;",0,False
"total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
",0,False
"delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
",0,False
"moveToMRU((LinkEntry<K, V>) entry);  
",0,False
"List<V> list = (List<V>) getMapping();
",0,False
"List<V> list = (List<V>) createCollection();
",0,False
"SynchronizedBagSet(final Set<E> set, final Object lock) {
super(set, lock);
}
",0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
"return (List<E>) super.decorated();
",0,False
"return (List<E>) super.decorated();
",0,False
"return hash;
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = (List<V>) getMapping();
",0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
",0,False
"private final Transformer<C, K> keyTransformer;",0,False
"return null;
",0,False
"return null;
",0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"return (List<E>) super.decorated();
",0,False
"if (((ReferenceEntry<K, V>) entry).purge(ref)) {
",0,False
"return hash;
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = (List<V>) getMapping();
",0,False
"if (listSize < 0) {
",0,False
"private UnmodifiableBidiMap<V, K> inverse;",0,False
"return null;
",0,False
"return (List<E>) super.decorated();
",0,False
"left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);
",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"entry = entry.next();
",0,False
"return hash;
",0,False
"delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
",0,False
"return (SortedSet<E>) decorated();
",0,False
"catch (Exception e)
",0,False
".get(positionToIndex(getPosition())));
",1,False
"return new Long(n.longValue());
",1,False
"file = new File(fileName);
",0,False
"file = new File(fileName);
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",1,False
"pstmt = conn.prepareStatement(query.toString());
",1,False
private ConfigurationSourceData sourceData;,0,False
"catch (final Exception e)
",0,False
"getConfiguration().addProperty(name, new Byte(array[i]));
",1,False
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",1,False
"file = new File(fileName);
",0,False
"catch (final Exception e)
",0,False
"file = new File(appendPath(basePath, fileName));
",0,False
public PrintStream debugStream = System.out;,0,False
"file = new File(fileName);
",0,False
"file = new File(appendPath(basePath, fileName));
",0,False
"Node node = new Node();
String key = String();
node.setName(key);
jj_consume_token(EQUAL);
Object value = Element();
node.setValue(value);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
return node;
",0,False
"return locations;
",1,False
"this.configurations = configurations;
",1,False
"switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_BEGIN:
return Array();
case DICT_BEGIN:
return Dictionary();
case STRING:
case QUOTED_STRING:
return String();
case DATA:
return Data();
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"getConfiguration().addProperty(name, new Float(array[i]));
",1,False
"catch (final Exception ex)
",0,False
private FileLocator locator;,0,False
"if ((jjbitVec0[i2] & l2) == 0L)
break;
if (kind > 19)
kind = 19;
jjCheckNAdd(3);
break;
",0,False
"file = new File(appendPath(basePath, fileName));
",0,False
"if (layout == null)
",0,False
"parent.mkdirs();
",1,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
"catch (Exception e)
",0,False
private ConfigurationSourceData sourceData;,0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"return (src != null) ? src.clone() : null;
",0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"writer = new OutputStreamWriter(out);
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"if (file != null && file.exists())
",0,False
protected Configuration configuration;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0,False
private NodeCombiner nodeCombiner;,0,False
"synchronized (configs)
",0,False
private ConfigurationNode rootNode;,0,False
"catch (Exception ex)
",0,False
"return new Short(n.shortValue());
",0,False
"return new Double(n.doubleValue());
",0,False
"catch (Exception ex)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
"final ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"result.setErrorHandler(new DefaultHandler() {
@Override
public void error(final SAXParseException ex) throws SAXException {
throw ex;
",0,False
private AutoSaveListener autoSaveListener;,0,False
"return new ConfigurationBuilderResultCreatedEvent(this, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED,
",0,False
"staticCatalog = catalog;
",0,False
"final ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
private final NodeHandler<T> handler;,0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"return getShort(key, new Short(defaultValue)).shortValue();
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
protected Configuration configuration;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"if (configs != null)
",0,False
private ConfigurationNode rootNode;,0,False
"super();
reloadLock = new Lock(LOCK_NAME);
}
public HierarchicalReloadableConfiguration(Object lock)
{
super();
reloadLock = lock == null ? new Lock(LOCK_NAME) : lock;
}
public HierarchicalReloadableConfiguration(HierarchicalConfiguration c)
{
super(c);
reloadLock = new Lock(LOCK_NAME);
}
@Override
public Object getReloadLock()
{
return reloadLock;
",0,False
"instanceId = ++counter;
",0,False
"if (init)
",0,False
private ReloadingStrategy fileStrategy;,0,False
"{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
",0,False
"return new Integer(n.intValue());
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"catch (Exception ex)
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
private ConfigurationNode node;,0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"return getFloat(key, new Float(defaultValue)).floatValue();
",0,False
"if (file != null && file.exists())
",0,False
protected Configuration configuration;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
private final Object reloadLock;,0,False
"instanceId = ++counter;
",0,False
"catch (Exception ex)
",0,False
"configurationsMap.putIfAbsent(pattern, configuration);
",0,False
private final String protocol;,0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"catch (Exception ex)
",0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"return new Float(n.floatValue());
",0,False
"writer = new OutputStreamWriter(out);
",0,False
"getLogger().debug(os.toString());
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"instanceId = ++counter;
",0,False
"if (init)
",0,False
"catch (Exception e)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
public Token currentToken;,0,False
"String key = null;
Object value = null;
Node node = new Node();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{if (true) return node;}
",0,False
"token = jj_consume_token(DATE);
{if (true) return parseDate(token.image);}
",0,False
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0,False
"jjstateSet[jjnewStateCnt++] = jjnextStates[start];
}
while (start++ != end);
}
",0,False
"ReInit(stream);
SwitchTo(lexState);
}
",0,False
"if (lexState >= 1 || lexState < 0)
{
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
}
else
{
curLexState = lexState;
}
}
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"jjCheckNAdd(jjnextStates[start]);
jjCheckNAdd(jjnextStates[start + 1]);
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
}
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"String name = (url == null) ? fileName : url.toString();
",0,False
"staticCatalog = catalog;
",0,False
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0,False
"return getShort(key, new Short(defaultValue)).shortValue();
",0,False
"reader = new InputStreamReader(in);
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"return count % 2 == 1;
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"catch (Exception e)
",0,False
"catch (Exception e)
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"out.print(""<*D"" + DATE_FORMAT.format((Date) value) + "">"");
",0,False
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"String key = null;
Object value = null;
Node node = new Node();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{if (true) return node;}
",0,False
private boolean jj_semLA;,0,False
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0,False
"ReInit(stream);
SwitchTo(lexState);
}
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
}
",0,False
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"List lst = (List) namedNodes.get(node.getName());
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
protected Configuration configuration;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
private final Object reloadLock;,0,False
"configurationsMap.putIfAbsent(pattern, configuration);
",0,False
"if (init)
",0,False
"return new Byte(n.byteValue());
",0,False
"return new Short(n.shortValue());
",0,False
"catch (Exception ex)
",0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"catch (Exception ex)
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"catch (Exception ex)
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
@Override
protected void addPropertyInternal(String key, Object value)
{
config.addProperty(makePath(key), value);
}
@Override
protected void clearInternal()
{
getConfig().clear();
}
@Override
protected void clearPropertyDirect(String key)
{
config.clearProperty(makePath(key));
}
@Override
protected boolean containsKeyInternal(String key)
{
return config.containsKey(makePath(key));
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
@Override
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
@Override
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
@Override
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
@Override
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
@Override
public int getInt(String key)
{
return config.getInt(makePath(key));
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
@Override
protected Iterator<String> getKeysInternal()
{
return config.getKeys(makePath());
}
@Override
protected Iterator<String> getKeysInternal(String prefix)
{
return config.getKeys(makePath(prefix));
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
@Override
public List<Object> getList(String key)
{
return config.getList(makePath(key));
}
@Override
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public long getLong(String key)
{
return config.getLong(makePath(key));
}
@Override
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
@Override
protected Object getPropertyInternal(String key)
{
return config.getProperty(makePath(key));
}
@Override
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public short getShort(String key)
{
return config.getShort(makePath(key));
}
@Override
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
@Override
public String getString(String key)
{
return config.getString(makePath(key));
}
@Override
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
@Override
protected boolean isEmptyInternal()
{
return getConfig().isEmpty();
}
@Override
protected void setPropertyInternal(String key, Object value)
{
getConfig().setProperty(key, value);
}
@Override
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
@Override
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
@Override
protected void setRootNodeInternal(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNodeInternal(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
@Override
protected void addNodesInternal(String key, Collection<? extends ConfigurationNode> nodes)
{
getConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
@Override
public List<SubnodeConfiguration> configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
@Override
protected List<ConfigurationNode> clearTreeInternal(String key)
{
config.clearTree(makePath(key));
return Collections.emptyList();
}
@Override
protected int getMaxIndexInternal(String key)
{
return config.getMaxIndex(makePath(key));
}
@Override
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void write(Writer writer) throws ConfigurationException, IOException
{
fetchFileBased().write(writer);
}
public void read(Reader reader) throws ConfigurationException, IOException
{
fetchFileBased().read(reader);
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return getConfig().getErrorListeners();
}
private BaseHierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return substitute(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return substitute(pathPattern) + item;
}
private String substitute(String pattern)
{
Object value = getInterpolator().interpolate(pattern);
return (value != null) ? value.toString() : null;
}
private FileBased fetchFileBased() throws ConfigurationException
{
if (!(config instanceof FileBased))
{
throw new ConfigurationException(
""Wrapped configuration does not implement FileBased!""
+ "" No I/O operations are supported."");
}
return (FileBased) config;
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"catch (Exception ex)
",0,False
private FileLocator locator;,0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"String name = (url == null) ? fileName : url.toString();
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
private final ImmutableConfiguration configuration;,0,False
private ConfigurationSourceData sourceData;,0,False
private final String protocol;,0,False
"catch (Exception e)
",0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0,False
protected Configuration configuration;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"catch (Exception e)
",0,False
"if (configs != null)
",0,False
private ConfigurationNode rootNode;,0,False
"super();
reloadLock = new Lock(LOCK_NAME);
}
public HierarchicalReloadableConfiguration(Object lock)
{
super();
reloadLock = lock == null ? new Lock(LOCK_NAME) : lock;
}
public HierarchicalReloadableConfiguration(HierarchicalConfiguration c)
{
super(c);
reloadLock = new Lock(LOCK_NAME);
}
public Object getReloadLock()
{
return reloadLock;
",0,False
private final Object reloadLock;,0,False
"catch (Exception ex)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"catch (Exception ex)
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"catch (Exception e)
",0,False
"if (name == null)
",0,False
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0,False
"List lst = (List) namedNodes.remove(name);
",0,False
"List lst = (List) namedNodes.get(node.getName());
",0,False
private ConfigurationNode node;,0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"writer = new OutputStreamWriter(out);
",0,False
"public class CombinedConfiguration extends HierarchicalReloadableConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, AbstractConfiguration> namedConfigurations;
private boolean ignoreReloadExceptions = true;
private boolean reloadRequired;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(NodeCombiner comb, Lock lock)
{
super(lock);
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(Lock lock)
{
this(null, lock);
}
public CombinedConfiguration()
{
this(null, null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Adding configuration "" + config + "" with name "" + name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return namedConfigurations.get(name);
}
public List<AbstractConfiguration> getConfigurations()
{
List<AbstractConfiguration> list = new ArrayList<AbstractConfiguration>(configurations.size());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
public List<String> getConfigurationNameList()
{
List<String> list = new ArrayList<String>(configurations.size());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
reloadRequired = true;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
@Override
public ConfigurationNode getRootNode()
{
synchronized (getReloadLock())
{
if (reloadRequired || combinedRoot == null)
{
combinedRoot = constructCombinedNode();
reloadRequired = false;
}
return combinedRoot;
}
}
@Override
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, AbstractConfiguration>();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
@Override
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (ConfigData cd : configurations)
{
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List<ConfigurationNode> nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator<ConfigurationNode> it = nodes.iterator();
Configuration source = findSourceConfiguration(it.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration(it.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
@Override
protected List<ConfigurationNode> fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
synchronized (getReloadLock())
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
}
return this;
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"if (configs != null)
",0,False
"super();
reloadLock = new Lock(LOCK_NAME);
}
public HierarchicalReloadableConfiguration(Object lock)
{
super();
reloadLock = lock == null ? new Lock(LOCK_NAME) : lock;
}
public HierarchicalReloadableConfiguration(HierarchicalConfiguration c)
{
super(c);
reloadLock = new Lock(LOCK_NAME);
}
@Override
public Object getReloadLock()
{
return reloadLock;
",0,False
"synchronized (counterLock)
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"if (init)
",0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"result = namedNodes.get(name);
",0,False
"{
@Override
protected Object interpolate(final Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
"catch (final Exception ex)
",0,False
"{
@Override
public InputSource resolveEntity(final String publicId, final String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
private AutoSaveListener autoSaveListener;,0,False
private final String protocol;,0,False
"final String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"catch (final Exception ex)
",0,False
"{
@Override
public InputSource resolveEntity(final String publicId, final String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"catch (final Exception e)
",0,False
"staticCatalog = catalog;
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"return (src != null) ? src.clone() : null;
",0,False
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0,False
"return getShort(key, new Short(defaultValue)).shortValue();
",0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"writer = new OutputStreamWriter(out);
",0,False
private ConfigurationNode combinedRoot;,0,False
"ResultSet rs = ps.executeQuery();
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
"public class MultiFileHierarchicalConfiguration extends AbstractHierarchicalFileConfiguration
implements ConfigurationListener, ConfigurationErrorListener, EntityResolverSupport
{
private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = """";
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
public void clear()
{
this.getConfiguration().clear();
}
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public <T> List<T> getList(String key, List<T> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public <T> List<T> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubConfiguration<ConfigurationNode> configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubConfiguration<ConfigurationNode> configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<SubConfiguration<ConfigurationNode>> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
public void load() throws ConfigurationException
{
this.getConfiguration();
}
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public ConfigurationNode getRootNode()
{
return getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
Collection<ConfigurationListener> listeners = getConfigurationListeners();
for (ConfigurationListener listener : listeners)
{
listener.configurationChanged(event);
}
}
}
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
Collection<ConfigurationErrorListener> listeners = getErrorListeners();
for (ConfigurationErrorListener listener : listeners)
{
listener.configurationError(event);
}
}
}
protected Object resolveContainerStore(String key)
{
if (recursive.get())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = getSubstitutor().replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
public void load() throws ConfigurationException
{
}
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Logger log = Logger.getLogger(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (!ignoreException)
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private ReloadingStrategy createReloadingStrategy()
{
if (getReloadingStrategy() == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(getReloadingStrategy());
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"if (init)
",0,False
"catch (Exception ex)
",0,False
"return new Float(n.floatValue());
",0,False
"return new Long(n.longValue());
",0,False
"token = jj_consume_token(DATE);
{if (true) return parseDate(token.image);}
",0,False
"token = jj_consume_token(DATA);
{if (true) return filterData(token.image);}
",0,False
"if ((jjbitVec0[i2] & l2) == 0L)
{
break;
}
if (kind > 21)
{
kind = 21;
}
jjCheckNAdd(8);
break;
",0,False
"if (lexState >= 1 || lexState < 0)
{
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
}
else
{
curLexState = lexState;
}
}
",0,False
"ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (tabSize - (column % tabSize));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
public int endColumn;,0,False
"return (configuration.getURL() != null) ? fileFromURL(configuration
",0,False
"List<ConfigurationNode> nodes = namedNodes.remove(name);
",0,False
private ConfigurationNode node;,0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"catch (Exception ex)
",0,False
"{
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0,False
"switch (state)
{
case 0:
if (c == '\\')
{
state = 1;
}
else if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c))
{
key.append(c);
}
else
{
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
",0,False
"{
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
private DocumentBuilder documentBuilder;,0,False
"initProperty(bean, propName, properties.get(propName));
",0,False
"throw new IllegalArgumentException(""No such property name=["" + name + ""]"");
",0,False
"String key = null;
Object value = null;
Node node = new Node();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{if (true) return node;}
",0,False
"jjstateSet[jjnewStateCnt++] = jjnextStates[start];
}
while (start++ != end);
}
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
}
",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
private AutoSaveListener autoSaveListener;,0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"catch (Exception e)
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"catch (Exception e)
",0,False
"return new Byte(n.byteValue());
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
private final NodeHandler<T> handler;,0,False
"reader = new InputStreamReader(in);
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
protected Configuration configuration;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0,False
"super();
reloadLock = new Lock(LOCK_NAME);
}
public HierarchicalReloadableConfiguration(Object lock)
{
super();
reloadLock = lock == null ? new Lock(LOCK_NAME) : lock;
}
public HierarchicalReloadableConfiguration(HierarchicalConfiguration c)
{
super(c);
reloadLock = new Lock(LOCK_NAME);
}
@Override
public Object getReloadLock()
{
return reloadLock;
",0,False
private final Object reloadLock;,0,False
"catch (Exception ex)
",0,False
"if (init)
",0,False
"return new Short(n.shortValue());
",0,False
"catch (Exception e)
",0,False
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0,False
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"catch (Exception e)
",0,False
"{
@Override
public String lookup(String key)
{
Object value = ip.resolve(key);
return (value != null) ? value.toString() : null;
",0,False
"catch (Exception ex)
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"return (src != null) ? src.clone() : null;
",0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"value = array.length == 0 ? null : new Byte(array[0]);
",0,False
"{
public boolean evaluate(Object obj)
{
String key = (String) obj;
return key.startsWith(prefix + ""."") || key.equals(prefix);
",0,False
"reader = new InputStreamReader(in);
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"{
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0,False
private ConfigurationNode rootNode;,0,False
"return bsCount % 2 == 1;
",0,False
"getConfiguration().addProperty(name, new Byte(array[i]));
",0,False
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_BEGIN:
case DICT_BEGIN:
case DATA:
case STRING:
case QUOTED_STRING:
element = Element();
list.add(element);
label_2:
while (true)
{
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(ARRAY_SEPARATOR);
element = Element();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
return list;
",0,False
public PrintStream debugStream = System.out;,0,False
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0,False
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0,False
"addValue(new Integer(value));
",0,False
"return (configuration.getURL() != null) ? fileFromURL(configuration
",0,False
"List lst = (List) namedNodes.remove(name);
",0,False
private ConfigurationNode node;,0,False
"final BaseHierarchicalConfiguration result = new BaseHierarchicalConfiguration() {
@Override
protected Object interpolate(final Object value) {
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator() {
return parent.getInterpolator();
",0,False
private final ImmutableConfiguration configuration;,0,False
private AutoSaveListener autoSaveListener;,0,False
"return new ConfigurationBuilderResultCreatedEvent(this, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED,
",0,False
private final String protocol;,0,False
"} catch (final Exception ex) {
",0,False
"final ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
"reader = new InputStreamReader(in);
",0,False
"ResultSet rs = ps.executeQuery();
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0,False
"catch (Exception ex)
",0,False
"{
configuration = config;
name = n;
atPath = parseAt(at);
this.at = at;
}
public AbstractHierarchicalConfiguration<?> getConfiguration()
{
return configuration;
}
public String getName()
{
return name;
}
public String getAt()
{
return at;
}
public Object getRootNode()
{
return rootNode;
}
public CombinedNode getTransformedRoot()
{
CombinedNode result = new CombinedNode();
CombinedNode atParent = result;
if (atPath != null)
{
for (String name : atPath)
{
CombinedNode node = new CombinedNode();
node.setName(name);
atParent.addChild(name, node);
atParent = node;
}
}
rootNode = append(atParent, getConfiguration());
return result;
}
private <T> T append(CombinedNode atParent,
AbstractHierarchicalConfiguration<T> config)
{
T root = config.getRootNode();
atParent.appendChildren(root, config.getNodeHandler());
atParent.appendAttributes(root, config.getNodeHandler());
return root;
}
private Collection<String> parseAt(String at)
{
if (at == null)
{
return null;
}
Collection<String> result = new ArrayList<String>();
DefaultConfigurationKey.KeyIterator it = new DefaultConfigurationKey(
AT_ENGINE, at).iterator();
while (it.hasNext())
{
result.add(it.nextKey());
}
return result;
",0,False
"public class CombinedConfiguration extends
AbstractHierarchicalConfiguration<Object> implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final CombinedNodeHandler COMBINED_NODE_HANDLER = new CombinedNodeHandler();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private CombinedNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
private boolean ignoreReloadExceptions = true;
public CombinedConfiguration(NodeCombiner comb)
{
super(new CombinedConfigurationNodeHandler());
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public void addConfiguration(AbstractHierarchicalConfiguration<?> config,
String name, String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.getNodeHandler().initNodeHandlerRegistry(getCombinedNodeHandler());
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractHierarchicalConfiguration<?> config,
String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractHierarchicalConfiguration<?> config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return namedConfigurations.get(name);
}
public List<AbstractHierarchicalConfiguration<?>> getConfigurations()
{
List<AbstractHierarchicalConfiguration<?>> list = new ArrayList<AbstractHierarchicalConfiguration<?>>();
for (ConfigData configuration : configurations)
{
list.add(configuration.getConfiguration());
}
return list;
}
public List<String> getConfigurationNameList()
{
List<String> list = new ArrayList<String>();
for (ConfigData configuration : configurations)
{
list.add((configuration).getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
synchronized (getNodeCombiner()) 
{
combinedRoot = null;
}
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (!event.isBeforeUpdate())
{
invalidate();
}
}
@Override
public Object getRootNode()
{
synchronized (getNodeCombiner())
{
if (combinedRoot == null)
{
getCombinedNodeHandler().setHandlers(createSubHandlers());
combinedRoot = constructCombinedNode();
}
return combinedRoot;
}
}
@Override
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
@Override
public Object clone()
{
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (ConfigData cd : configurations)
{
copy
.addConfiguration(
(AbstractHierarchicalConfiguration<?>) ConfigurationUtils
.cloneConfiguration(cd
.getConfiguration()), cd
.getName(), cd.getAt());
}
return copy;
}
catch (CloneNotSupportedException cnsex)
{
throw new ConfigurationRuntimeException(cnsex);
}
}
@Override
public Object getProperty(String key)
{
if (isForceReloadCheck())
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
return super.getProperty(key);
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
NodeList<Object> nodes = fetchNodeList(key);
if (nodes.size() == 0)
{
return null;
}
Configuration source = findSourceConfiguration(nodes, 0);
for (int idx = 1; idx < nodes.size(); idx++)
{
Configuration src = findSourceConfiguration(nodes, idx);
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected Map<Class<?>, NodeHandler<?>> createSubHandlers()
{
Map<Class<?>, NodeHandler<?>> result = new HashMap<Class<?>, NodeHandler<?>>();
for (ConfigData cd : configurations)
{
result.put(cd.getConfiguration().getRootNode().getClass(), cd
.getConfiguration().getNodeHandler());
}
return result;
}
@Override
protected NodeList<Object> fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
;
}
}
}
private CombinedNode constructCombinedNode()
{
initSubHandlers();
if (getNumberOfConfigurations() < 1)
{
return new CombinedNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
CombinedNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node, getNodeHandler(),
it.next().getTransformedRoot(), getNodeHandler());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node, getNodeHandler());
getLogger().debug(os.toString());
}
return node;
}
}
private void initSubHandlers()
{
Map<Class<?>, NodeHandler<?>> handlers = new HashMap<Class<?>, NodeHandler<?>>(
createSubHandlers());
handlers.put(CombinedNode.class, COMBINED_NODE_HANDLER);
getCombinedNodeHandler().setHandlers(handlers);
}
private Configuration findSourceConfiguration(Object node)
{
Object root = null;
Object current = node;
while (current != null)
{
root = current;
current = getNodeHandler().getParent(current);
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
return this;
}
private Configuration findSourceConfiguration(NodeList<Object> nl, int idx)
{
return nl.isNode(idx) ? findSourceConfiguration(nl.getNode(idx))
: findSourceConfiguration(nl.getAttributeParent(idx));
}
private CombinedConfigurationNodeHandler getCombinedNodeHandler()
{
return (CombinedConfigurationNodeHandler) getNodeHandler();
",0,False
"getLogger().debug(os.toString());
",0,False
"return new ConfigurationNodeIteratorChildren<T>(this, test, reverse,
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"catch (Exception e)
",0,False
"Object value = null;
Token token;
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_BEGIN:
value = Array();
{if (true) return value;}
break;
case OBJECT_BEGIN:
value = Object();
{if (true) return value;}
break;
case STRING:
value = String();
{if (true) return value;}
break;
case INTEGER:
token = jj_consume_token(INTEGER);
{if (true) return new BigInteger(token.image);}
break;
case REAL:
token = jj_consume_token(REAL);
{if (true) return new BigDecimal(token.image);}
break;
case TRUE:
token = jj_consume_token(TRUE);
{if (true) return Boolean.TRUE;}
break;
case FALSE:
token = jj_consume_token(FALSE);
{if (true) return Boolean.FALSE;}
break;
case NULL:
token = jj_consume_token(NULL);
{if (true) return null;}
break;
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 5; i++) jj_la1[i] = -1;
}
",0,False
"List children = new ArrayList();
ConfigurationNode child = null;
jj_consume_token(OBJECT_BEGIN);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
child = Property();
if (child != null) children.add(child);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case LIST_SEPARATOR:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
jj_consume_token(LIST_SEPARATOR);
child = Property();
if (child != null) children.add(child);
}
break;
default:
jj_la1[1] = jj_gen;
;
}
jj_consume_token(OBJECT_END);
JSONConfiguration configuration = new JSONConfiguration();
ConfigurationNode root = configuration.getRootNode();
for (int i = 0; i < children.size(); i++)
{
child = (ConfigurationNode) children.get(i);
root.addChild(child);
}
{if (true) return configuration;}
",0,False
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_BEGIN:
case OBJECT_BEGIN:
case STRING:
case INTEGER:
case REAL:
case TRUE:
case FALSE:
case NULL:
element = Value();
list.add(element);
label_2:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case LIST_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(LIST_SEPARATOR);
element = Value();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
{if (true) return list;}
",0,False
"buffer = null;
bufline = null;
bufcolumn = null;
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
}
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
",0,False
public int endLine;,0,False
"return(""Lexical error at line "" +
",0,False
public Token currentToken;,0,False
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
ConfigurationNode child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof AbstractHierarchicalConfiguration)
{
AbstractHierarchicalConfiguration conf = (AbstractHierarchicalConfiguration) child.getValue();
ConfigurationNode root = (ConfigurationNode) conf.getRootNode();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (ConfigurationNode) children.get(i);
configuration.getRootNode().addChild(child);
}
{if (true) return configuration;}
",0,False
"return null;
",0,False
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"return(""Lexical error at line "" +
",0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
private final Object reloadLock;,0,False
"configurationsMap.putIfAbsent(pattern, configuration);
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"catch (Exception ex)
",0,False
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"if (name == null)
",0,False
"staticCatalog = catalog;
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0,False
"reader = new InputStreamReader(in);
",0,False
"parent.mkdirs();
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"switch (state)
{
case 0:
if (c == '\\')
{
state = 1;
}
else if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c))
{
key.append(c);
}
else
{
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
",0,False
private DocumentBuilder documentBuilder;,0,False
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration)
{
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
{if (true) return configuration;}
",0,False
"String key = null;
Object value = null;
Node node = new Node();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{if (true) return node;}
",0,False
"token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0,False
"buffer = null;
bufline = null;
bufcolumn = null;
}
",0,False
"catch (Exception e)
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
".get(positionToIndex(getPosition())));
",0,False
"final PrintStream stream = new PrintStream(os);
",0,False
"} catch (final Exception ex) {
",0,False
private ConfigurationSourceData sourceData;,0,False
"final String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"} catch (final Exception e) {
",0,False
private final QueryResult<T> attributeResult;,0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"return getShort(key, new Short(defaultValue)).shortValue();
",0,False
"catch (Exception e)
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"switch (state)
{
case 0:
if (c == '\\')
{
state = 1;
}
else if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c))
{
key.append(c);
}
else
{
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
",0,False
"return bsCount % 2 == 1;
",0,False
"catch (Exception e)
",0,False
"Token token = null;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
return unescapeQuotes(removeQuotes(token.image));
case STRING:
token = jj_consume_token(STRING);
return token.image;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_BEGIN:
return Array();
case DICT_BEGIN:
return Dictionary();
case STRING:
case QUOTED_STRING:
return String();
case DATA:
return Data();
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"return null;
",0,False
"if ((jjbitVec0[i2] & l2) == 0L)
break;
if (kind > 19)
kind = 19;
jjCheckNAdd(3);
break;
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
public Token specialToken;,0,False
"addValue(format.parse(value));
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
".get(positionToIndex(getPosition())));
",0,False
private ConfigurationNode node;,0,False
"getLogger().debug(os.toString());
",0,False
"catch (Exception ex)
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
private final Configuration configuration;,0,False
"{
@Override
public String lookup(String key)
{
Object value = ip.resolve(key);
return (value != null) ? value.toString() : null;
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
private ConfigurationListener changeListener;,0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private NodeCombiner nodeCombiner;
private ConfigurationNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
public ConfigurationNode getRootNode()
{
return combinedRoot;
}
@Override
protected void clearInternal()
{
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
beginRead(false);
try
{
List<ConfigurationNode> nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator<ConfigurationNode> it = nodes.iterator();
Configuration source = findSourceConfiguration(it.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration(it.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(optimize);
if (combinedRoot != null)
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if(optimize)
{
return;
}
try
{
if (combinedRoot == null)
{
combinedRoot = constructCombinedNode();
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private void invalidateInternal()
{
combinedRoot = null;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
return this;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addConfigurationListener(this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeConfigurationListener(this);
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"if (file != null && file.exists())
",0,False
private NodeCombiner nodeCombiner;,0,False
"{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
@Override
protected void addPropertyInternal(String key, Object value)
{
config.addProperty(makePath(key), value);
}
@Override
protected void clearInternal()
{
getConfig().clear();
}
@Override
protected void clearPropertyDirect(String key)
{
config.clearProperty(makePath(key));
}
@Override
protected boolean containsKeyInternal(String key)
{
return config.containsKey(makePath(key));
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
@Override
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
@Override
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
@Override
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
@Override
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
@Override
public int getInt(String key)
{
return config.getInt(makePath(key));
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
@Override
protected Iterator<String> getKeysInternal()
{
return config.getKeys(makePath());
}
@Override
protected Iterator<String> getKeysInternal(String prefix)
{
return config.getKeys(makePath(prefix));
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
@Override
public List<Object> getList(String key)
{
return config.getList(makePath(key));
}
@Override
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public long getLong(String key)
{
return config.getLong(makePath(key));
}
@Override
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
@Override
protected Object getPropertyInternal(String key)
{
return config.getProperty(makePath(key));
}
@Override
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public short getShort(String key)
{
return config.getShort(makePath(key));
}
@Override
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
@Override
public String getString(String key)
{
return config.getString(makePath(key));
}
@Override
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
@Override
protected boolean isEmptyInternal()
{
return getConfig().isEmpty();
}
@Override
protected void setPropertyInternal(String key, Object value)
{
getConfig().setProperty(key, value);
}
@Override
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
@Override
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
@Override
protected void setRootNodeInternal(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNodeInternal(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
@Override
protected void addNodesInternal(String key, Collection<? extends ConfigurationNode> nodes)
{
getConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
@Override
public List<SubnodeConfiguration> configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
@Override
protected List<ConfigurationNode> clearTreeInternal(String key)
{
config.clearTree(makePath(key));
return Collections.emptyList();
}
@Override
protected int getMaxIndexInternal(String key)
{
return config.getMaxIndex(makePath(key));
}
@Override
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void write(Writer writer) throws ConfigurationException, IOException
{
fetchFileBased().write(writer);
}
public void read(Reader reader) throws ConfigurationException, IOException
{
fetchFileBased().read(reader);
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return getConfig().getErrorListeners();
}
private BaseHierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return substitute(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return substitute(pathPattern) + item;
}
private String substitute(String pattern)
{
Object value = getInterpolator().interpolate(pattern);
return (value != null) ? value.toString() : null;
}
private FileBased fetchFileBased() throws ConfigurationException
{
if (!(config instanceof FileBased))
{
throw new ConfigurationException(
""Wrapped configuration does not implement FileBased!""
+ "" No I/O operations are supported."");
}
return (FileBased) config;
",0,False
"catch (Exception ex)
",0,False
private final String protocol;,0,False
private AutoSaveListener autoSaveListener;,0,False
private ConfigurationSourceData sourceData;,0,False
"return new Double(n.doubleValue());
",0,False
"return new Byte(n.byteValue());
",0,False
"catch (Exception e)
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"List<ConfigurationNode> lst = namedNodes.get(node.getName());
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"catch (Exception ex)
",0,False
"public static final EventType<ConfigurationBuilderResultCreatedEvent> RESULT_CREATED =
new EventType<ConfigurationBuilderResultCreatedEvent>(ANY,
""RESULT_CREATED"");
private final ImmutableConfiguration configuration;
public ConfigurationBuilderResultCreatedEvent(
ConfigurationBuilder<?> source,
EventType<? extends ConfigurationBuilderResultCreatedEvent> evType,
ImmutableConfiguration createdConfiguration)
{
super(source, evType);
if (createdConfiguration == null)
{
throw new IllegalArgumentException(
""Configuration must not be null!"");
}
configuration = createdConfiguration;
}
public ImmutableConfiguration getConfiguration()
{
return configuration;
",0,False
private final ImmutableConfiguration configuration;,0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
private final String protocol;,0,False
"ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"catch (Exception ex)
",0,False
private final Configuration configuration;,0,False
"catch (Exception e)
",0,False
private final EventType<?> errorOperationType;,0,False
private final EventType<? extends Event> eventType;,0,False
"catch (Exception ex)
",0,False
"if (locator.getEncoding() != null)
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
"String name = (url == null) ? fileName : url.toString();
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"} catch (final Exception ex) {
",0,False
"result.setErrorHandler(new DefaultHandler() {
@Override
public void error(final SAXParseException ex) throws SAXException {
throw ex;
",0,False
private AutoSaveListener autoSaveListener;,0,False
private ConfigurationSourceData sourceData;,0,False
"return sourceURL != null ? sourceURL.toExternalForm() : StringUtils.EMPTY;
",0,False
"} catch (final Exception ex) {
",0,False
"} catch (final Exception e) {
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
private NodeCombiner nodeCombiner;,0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private NodeCombiner nodeCombiner;
private ConfigurationNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
public ConfigurationNode getRootNode()
{
return combinedRoot;
}
@Override
protected void clearInternal()
{
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
beginRead(false);
try
{
List<ConfigurationNode> nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator<ConfigurationNode> it = nodes.iterator();
Configuration source = findSourceConfiguration(it.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration(it.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(optimize);
if (combinedRoot != null)
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if(optimize)
{
return;
}
try
{
if (combinedRoot == null)
{
combinedRoot = constructCombinedNode();
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private void invalidateInternal()
{
combinedRoot = null;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
return this;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addConfigurationListener(this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeConfigurationListener(this);
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"catch (Exception ex)
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"catch (Exception e)
",0,False
"return propertyDescriptors;
",0,False
"return additionalBeanInfo;
",0,False
private AutoSaveListener autoSaveListener;,0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"staticCatalog = catalog;
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"reader = new InputStreamReader(in);
",0,False
private volatile ConfigurationNode combinedRoot;,0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"catch (Exception ex)
",0,False
"{
super(name);
setReference(elem);
}
public void setValue(Object value)
{
super.setValue(value);
if (getReference() != null && document != null)
{
if (isAttribute())
{
updateAttribute();
}
else
{
updateElement(value);
}
}
}
protected void removeReference()
{
if (getReference() != null)
{
Element element = (Element) getReference();
if (isAttribute())
{
updateAttribute();
}
else
{
org.w3c.dom.Node parentElem = element.getParentNode();
if (parentElem != null)
{
parentElem.removeChild(element);
}
}
}
}
private void updateElement(Object value)
{
Text txtNode = findTextNodeForUpdate();
if (value == null)
{
if (txtNode != null)
{
((Element) getReference()).removeChild(txtNode);
}
}
else
{
if (txtNode == null)
{
txtNode = document
.createTextNode(PropertyConverter.escapeDelimiters(
value.toString(), getListDelimiter()));
if (((Element) getReference()).getFirstChild() != null)
{
((Element) getReference()).insertBefore(txtNode,
((Element) getReference()).getFirstChild());
}
else
{
((Element) getReference()).appendChild(txtNode);
}
}
else
{
txtNode.setNodeValue(PropertyConverter.escapeDelimiters(
value.toString(), getListDelimiter()));
}
}
}
private void updateAttribute()
{
XMLBuilderVisitor.updateAttribute(getParent(), getName(), getListDelimiter());
}
private Text findTextNodeForUpdate()
{
Text result = null;
Element elem = (Element) getReference();
NodeList children = elem.getChildNodes();
Collection textNodes = new ArrayList();
for (int i = 0; i < children.getLength(); i++)
{
org.w3c.dom.Node nd = children.item(i);
if (nd instanceof Text)
{
if (result == null)
{
result = (Text) nd;
}
else
{
textNodes.add(nd);
}
}
}
if (result instanceof CDATASection)
{
textNodes.add(result);
result = null;
}
for (Iterator it = textNodes.iterator(); it.hasNext();)
{
elem.removeChild((org.w3c.dom.Node) it.next());
}
return result;
",0,False
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration)
{
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
{if (true) return configuration;}
",0,False
"token = jj_consume_token(DATE);
{if (true) return parseDate(token.image);}
",0,False
private boolean jj_semLA;,0,False
"token = jj_consume_token(DATA);
{if (true) return filterData(token.image);}
",0,False
"token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"if (lexState >= 1 || lexState < 0)
{
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
}
else
{
curLexState = lexState;
}
}
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"if ((jjbitVec0[i2] & l2) == 0L)
{
break;
}
if (kind > 21)
{
kind = 21;
}
jjCheckNAdd(8);
break;
",0,False
"jjstateSet[jjnewStateCnt++] = jjnextStates[start];
}
while (start++ != end);
}
",0,False
"jjCheckNAdd(jjnextStates[start]);
jjCheckNAdd(jjnextStates[start + 1]);
}
",0,False
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
private ConfigurationNode node;,0,False
"return getFloat(key, new Float(defaultValue)).floatValue();
",0,False
"value = array.length == 0 ? null : new Byte(array[0]);
",0,False
"public class CombinedConfiguration extends HierarchicalConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
synchronized (getNodeCombiner()) 
{
combinedRoot = null;
}
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
invalidate();
}
public ConfigurationNode getRootNode()
{
synchronized (getNodeCombiner())
{
if (combinedRoot == null)
{
combinedRoot = constructCombinedNode();
}
return combinedRoot;
}
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Object getProperty(String key)
{
if (isForceReloadCheck())
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
;
}
}
}
return super.getProperty(key);
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
return node;
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"switch (state)
{
case 0:
if (c == '\\')
{
state = 1;
}
else if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c))
{
key.append(c);
}
else
{
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
",0,False
"return new Long(n.longValue());
",0,False
"catch (Exception e)
",0,False
"catch (Exception e)
",0,False
"getConfiguration().addProperty(name, new Short(array[i]));
",0,False
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (8 - (column & 07));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0,False
public Token specialToken;,0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"addValue(format.parse(value));
",0,False
"result = (List) namedNodes.get(name);
",0,False
"getLogger().debug(os.toString());
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
private final NodeHandler<T> handler;,0,False
"writer = new OutputStreamWriter(out);
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
protected Configuration configuration;,0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
private ReloadingStrategy fileStrategy;,0,False
"return new Long(n.longValue());
",0,False
"return new Double(n.doubleValue());
",0,False
"return new Integer(n.intValue());
",0,False
"catch (Exception ex)
",0,False
private DocumentBuilder documentBuilder;,0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"staticCatalog = catalog;
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"catch (final Exception ex)
",0,False
"catch (final Exception e)
",0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"return new Float(n.floatValue());
",0,False
"catch (final Exception ex)
",0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0,False
"return getByte(key, new Byte(defaultValue));
",0,False
"if (file != null && file.exists())
",0,False
"{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
",0,False
private FlatNode root;,0,False
"public class CombinedConfiguration extends
AbstractHierarchicalConfiguration<Object> implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final CombinedNodeHandler COMBINED_NODE_HANDLER = new CombinedNodeHandler();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private CombinedNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
private boolean ignoreReloadExceptions = true;
public CombinedConfiguration(NodeCombiner comb)
{
super(new CombinedConfigurationNodeHandler());
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public void addConfiguration(AbstractHierarchicalConfiguration<?> config,
String name, String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.getNodeHandler().initNodeHandlerRegistry(getCombinedNodeHandler());
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractHierarchicalConfiguration<?> config,
String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractHierarchicalConfiguration<?> config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return namedConfigurations.get(name);
}
public List<AbstractHierarchicalConfiguration<?>> getConfigurations()
{
List<AbstractHierarchicalConfiguration<?>> list = new ArrayList<AbstractHierarchicalConfiguration<?>>();
for (ConfigData configuration : configurations)
{
list.add(configuration.getConfiguration());
}
return list;
}
public List<String> getConfigurationNameList()
{
List<String> list = new ArrayList<String>();
for (ConfigData configuration : configurations)
{
list.add((configuration).getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
synchronized (getNodeCombiner()) 
{
combinedRoot = null;
}
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (!event.isBeforeUpdate())
{
invalidate();
}
}
@Override
public Object getRootNode()
{
synchronized (getNodeCombiner())
{
if (combinedRoot == null)
{
getCombinedNodeHandler().setHandlers(createSubHandlers());
combinedRoot = constructCombinedNode();
}
return combinedRoot;
}
}
@Override
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
@Override
public Object clone()
{
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (ConfigData cd : configurations)
{
copy
.addConfiguration(
(AbstractHierarchicalConfiguration<?>) ConfigurationUtils
.cloneConfiguration(cd
.getConfiguration()), cd
.getName(), cd.getAt());
}
return copy;
}
catch (CloneNotSupportedException cnsex)
{
throw new ConfigurationRuntimeException(cnsex);
}
}
@Override
public Object getProperty(String key)
{
if (isForceReloadCheck())
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
return super.getProperty(key);
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
NodeList<Object> nodes = fetchNodeList(key);
if (nodes.size() == 0)
{
return null;
}
Configuration source = findSourceConfiguration(nodes, 0);
for (int idx = 1; idx < nodes.size(); idx++)
{
Configuration src = findSourceConfiguration(nodes, idx);
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected Map<Class<?>, NodeHandler<?>> createSubHandlers()
{
Map<Class<?>, NodeHandler<?>> result = new HashMap<Class<?>, NodeHandler<?>>();
for (ConfigData cd : configurations)
{
result.put(cd.getConfiguration().getRootNode().getClass(), cd
.getConfiguration().getNodeHandler());
}
return result;
}
@Override
protected NodeList<Object> fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
;
}
}
}
private CombinedNode constructCombinedNode()
{
initSubHandlers();
if (getNumberOfConfigurations() < 1)
{
return new CombinedNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
CombinedNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node, getNodeHandler(),
it.next().getTransformedRoot(), getNodeHandler());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node, getNodeHandler());
getLogger().debug(os.toString());
}
return node;
}
}
private void initSubHandlers()
{
Map<Class<?>, NodeHandler<?>> handlers = new HashMap<Class<?>, NodeHandler<?>>(
createSubHandlers());
handlers.put(CombinedNode.class, COMBINED_NODE_HANDLER);
getCombinedNodeHandler().setHandlers(handlers);
}
private Configuration findSourceConfiguration(Object node)
{
Object root = null;
Object current = node;
while (current != null)
{
root = current;
current = getNodeHandler().getParent(current);
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
return this;
}
private Configuration findSourceConfiguration(NodeList<Object> nl, int idx)
{
return nl.isNode(idx) ? findSourceConfiguration(nl.getNode(idx))
: findSourceConfiguration(nl.getAttributeParent(idx));
}
private CombinedConfigurationNodeHandler getCombinedNodeHandler()
{
return (CombinedConfigurationNodeHandler) getNodeHandler();
",0,False
"T node1 = ((ConfigurationNodePointer<T>) pointer1).getConfigurationNode();
",0,False
private NodeHandler<T> nodeHandler;,0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"retval += "" \"""";
",0,False
"ReInit(dstream, encoding, startline, startcolumn, 4096);
}
",0,False
"ReInit(dstream, encoding, 1, 1, 4096);
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0,False
"ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
}
",0,False
"ReInit(dstream, 1, 1, 4096);
}
",0,False
public int endColumn;,0,False
"if (lexState >= 1 || lexState < 0)
{
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
}
else
{
curLexState = lexState;
}
}
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
}
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
",0,False
"this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
",0,False
"if (name == null)
",0,False
"staticCatalog = catalog;
",0,False
"List<ConfigurationNode> nodes = namedNodes.remove(name);
",0,False
"ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
private ConfigurationSourceData sourceData;,0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"return new Float(n.floatValue());
",0,False
"catch (Exception e)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"catch (Exception ex)
",0,False
private final ImmutableConfiguration configuration;,0,False
private AutoSaveListener autoSaveListener;,0,False
"return new Float(n.floatValue());
",0,False
"catch (Exception e)
",0,False
"{
@Override
public String lookup(String key)
{
Object value = ip.resolve(key);
return (value != null) ? value.toString() : null;
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"return (src != null) ? src.clone() : null;
",0,False
private boolean closed;,0,False
"} catch (final Exception t) {
",0,False
"return null;
",0,False
"return DelegatingResultSet.wrapResultSet(this, statement.executeQuery(sql));
",0,False
"return connection.prepareStatement(sql, columnIndexes);
",0,False
"return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnIndexes));
",0,False
"return connection.prepareStatement(sql, autoGeneratedKeys);
",0,False
"return connection.prepareStatement(sql);
",0,False
"return null;
",0,False
"return null;
",0,False
"validationPreparedStatement = getInnermostDelegateInternal().prepareStatement(sql);
",0,False
"} catch (final Exception ignored) {
",0,False
"stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append("" You have set value of \"""")
",0,False
"return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
",0,False
"return connection.prepareStatement(sql, columnIndexes);
",0,False
"conn.validate(validationQuery, validationQueryTimeoutSeconds);
",0,False
"connection.prepareStatement(sql));
",0,False
"return connection.prepareStatement(sql, columnIndexes);
",0,False
"return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnIndexes)));
",0,False
"this.userPassword = userPassword;
",1,True
"return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
",0,False
"return statement.executeUpdate(sql, autoGeneratedKeys);
",0,False
"protected static final HashMap<String, ObjectPool<? extends Connection>> pools = new HashMap<>();",0,False
"return statement.executeLargeUpdate(sql, columnIndexes);
",0,False
"return statement.executeUpdate(sql, columnIndexes);
",0,False
"return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, autoGeneratedKeys)));
",0,False
private char[] userPassword;,0,True
private boolean closed;,0,False
"} catch (final Exception closePoolException) {
",0,False
"rulesBinder.addError( e );
",0,False
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0,False
"{
@Override
protected void loadRules()
{
loadXMLRules( xmlRulesResource );
}
",0,False
"Formatter formatter = new Formatter().format(""CallMethodRule[methodName=%s, paramCount=%s, paramTypes={"",
",0,False
"Formatter formatter = new Formatter(""[CallMethodRule]"");
",0,False
private String currChildNamespaceURI = null;,0,False
"this.annotations = annotations;
",0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"Object paramValues[] = new Object[paramTypes.length];
",0,False
private String currChildNamespaceURI = null;,0,False
protected static String versionNumber = null;,0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
"new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
",0,False
"version = new Float( versionNumber ).floatValue();
",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"if (this.paramTypes.length > 0) {
",0,False
protected String namespaceURI = null;,0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"} catch (Exception ex){
",0,False
"version = new Float( versionNumber ).floatValue();
",0,False
protected static String versionNumber = null;,0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"} catch (Exception e) {
",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
private FromXmlRuleSet ruleSet;,0,False
"return ( null );
",0,False
"{
public Constructor<?>[] run()
{
return type.getDeclaredConstructors();
",0,False
"{
@Override
protected void loadRules()
{
loadXMLRules( xmlRulesResource );
}
",0,False
"return memoryRulesBinder.forPattern( pattern );
",0,False
"new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
",0,False
"this.annotations = annotations;
",0,False
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0,False
protected static String versionNumber = null;,0,False
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
protected String namespaceURI = null;,0,False
private String currChildNamespaceURI = null;,0,False
"private final Map<Class<?>, FromAnnotationsRuleSet> data = new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
}
};",0,False
"version = new Float( versionNumber ).floatValue();
",0,False
protected static float version;,0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"{
public Constructor<?>[] run()
{
return type.getDeclaredConstructors();
",0,False
"return null;
",0,False
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"private String matchPrefix = null;
private Rules decoratedRules = null;
private List<Rule> rules = new ArrayList<Rule>(1);
private AnyChildRule rule;
public AnyChildRules(AnyChildRule rule) {
this.rule = rule;
rules.add(rule);
}
public Digester getDigester() { return null; }
public void setDigester(Digester digester) {}
public String getNamespaceURI() { return null; }
public void setNamespaceURI(String namespaceURI) {}
public void add(String pattern, Rule rule) {}
public void clear() {}
public List<Rule> match(String namespaceURI, String matchPath) {
List<Rule> match = decoratedRules.match(namespaceURI, matchPath);
if ((matchPath.startsWith(matchPrefix))
&& (matchPath.indexOf('/', matchPrefix.length()) == -1)) {
if ((match == null || match.size()==0)) {
// just one rule: the one passed to this object's
return rules;
} else {
LinkedList<Rule> newMatch = new LinkedList<Rule>(match);
newMatch.addLast(rule);
return newMatch;
}
} else {
return match;
}
}
public List<Rule> rules() {
if (this.getDigester().getLog().isDebugEnabled()) {
this.getDigester().getLog().debug(""AnyChildRules.rules invoked."");
}
return decoratedRules.rules();
}
public void init(String prefix, Rules rules) {
matchPrefix = prefix;
decoratedRules = rules;
}
public Rules getOldRules() {
return decoratedRules;
",0,False
private String currChildNamespaceURI = null;,0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0,False
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0,False
protected String namespaceURI = null;,0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
protected static float version;,0,False
"} catch (Exception ex){
",0,False
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"// TODO: Consider making following four constants static in 2.0
public final String DFLT_PLUGIN_CLASS_ATTR_NS = null;",0,False
"public static String DFLT_PROPS_ATTR = ""setprops"";",0,False
"|| rulesBinder.isAlreadyBound( type ) )
",0,False
"this.updated = updated;
",0,False
"addRules( d, connection );
",0,False
"return updated;
",0,False
"buf.replace( idx, idx + from.length(), to );
",0,False
"catch ( final Exception e )
",0,False
"return ( null );
",0,False
"return ( null );
",0,False
"return ( null );
",0,False
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0,False
"return memoryRulesBinder.forPattern( pattern );
",0,False
"this.updated = updated;
",0,False
"String address = emails.get( type );
",0,False
"Object paramValues[] = new Object[paramTypes.length];
",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
"{
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry( Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest )
{
return size() > cacheSize;
",0,False
private final float loadFactor = 0.75f;,0,False
private final int cacheSize = 255;,0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"return ( null );
",0,False
"{
public Field[] run()
{
return type.getDeclaredFields();
",0,False
"return null;
",0,False
"if ( paramTypes.length == 0 )
",0,False
"return null;
",0,False
"return ( null );
",0,False
"rulesBinder.addError( e );
",0,False
"|| rulesBinder.isAlreadyBound( type ) )
",0,False
"if (paramTypes.length == 0) {
",0,False
protected String namespaceURI = null;,0,False
protected static float version;,0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
"return ( null );
",0,False
"{
public Constructor<?>[] run()
{
return type.getDeclaredConstructors();
",0,False
"return memoryRulesBinder.forPattern( pattern );
",0,False
"Object[] paramValues = new Object[paramTypes.length];
",0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",1,False
private Substitutor substitutor;,1,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",1,False
"public static String DFLT_METHOD_NAME = ""addRules"";",1,False
"return (null);
",0,False
"invokeExactMethod( parent, methodName, new Object[] { child }, paramTypes );
",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",1,False
"public static String DFLT_METHOD_ATTR = ""method"";",1,False
Object delegate;,1,False
"if ( proxyManager == null )
{
synchronized ( this )
{
if ( proxyManager == null )
",1,True
"if (paramTypes.length == 0) {
",0,False
"String nameLower = name.toLowerCase();
",0,False
protected byte padding = (byte) '=';,0,False
".trim().toLowerCase();
",0,False
"file.delete();
",1,False
"return new String(rawdata);
",0,False
"outputFile.delete();
",1,False
protected int cachedCharacter = -1;,1,True
"throw (FileUploadException) e.getCause();
",0,False
"String nameLower = name.toLowerCase();
",1,False
"FileInputStream input = new FileInputStream(dfosFile);
",0,False
"&&  subContentType.toLowerCase()
",1,False
protected int bytesWritten = 0;,1,False
"subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
",0,False
protected boolean lastWhitespace = false;,1,True
"if (fileItem instanceof FileItemHeadersSupport) {
",0,False
"this.chars = charArray;
",1,False
"header += "" "" + headerPart.substring(nonWs, end);
",0,False
"String nameLower = name.toLowerCase();
",1,False
"String cdl = pContentDisposition.toLowerCase();
",0,False
"return null;
",0,False
"&& pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
",0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"paramName = paramName.toLowerCase();
",0,False
"dfosFile.delete();
",0,False
"outputFile.delete();
",0,False
"String nameLower = name.toLowerCase();
",0,False
"if (fileItem instanceof FileItemHeadersSupport) {
",0,False
"&&  subContentType.toLowerCase()
",0,False
"this(null, null, null);
",0,False
"String nameLower = name.toLowerCase();
",0,False
"return null;
",0,False
"this.chars = chars;
",0,False
"paramName = paramName.toLowerCase();
",0,False
"if (!""post"".equals(request.getMethod().toLowerCase())) {
",0,False
"if (cd != null && cd.toLowerCase().startsWith(FORM_DATA)) {
",0,False
private boolean opened;,0,False
"this.chars = chars;
",0,False
"paramName = paramName.toLowerCase();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"String cdl = cd.toLowerCase();
",0,False
"private static final String UID =
new java.rmi.server.UID().toString()
.replace(':', '_').replace('-', '_');
private static int counter = 0;
private String fieldName;
private String contentType;
private boolean isFormField;
private String fileName;
private long size = -1;
private int sizeThreshold;
private File repository;
private byte[] cachedContent;
private transient DeferredFileOutputStream dfos;
private File dfosFile;
public DiskFileItem(String fieldName, String contentType,
boolean isFormField, String fileName, int sizeThreshold,
File repository) {
this.fieldName = fieldName;
this.contentType = contentType;
this.isFormField = isFormField;
this.fileName = fileName;
this.sizeThreshold = sizeThreshold;
this.repository = repository;
}
public InputStream getInputStream()
throws IOException {
if (!isInMemory()) {
return new FileInputStream(dfos.getFile());
}
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return new ByteArrayInputStream(cachedContent);
}
public String getContentType() {
return contentType;
}
public String getCharSet() {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(getContentType(), ';');
return (String) params.get(""charset"");
}
public String getName() {
return fileName;
}
public boolean isInMemory() {
if (cachedContent != null) {
return true;
}
return dfos.isInMemory();
}
public long getSize() {
if (size >= 0) {
return size;
} else if (cachedContent != null) {
return cachedContent.length;
} else if (dfos.isInMemory()) {
return dfos.getData().length;
} else {
return dfos.getFile().length();
}
}
public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}
public String getString(final String charset)
throws UnsupportedEncodingException {
return new String(get(), charset);
}
public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}
public void write(File file) throws Exception {
if (isInMemory()) {
FileOutputStream fout = null;
try {
fout = new FileOutputStream(file);
fout.write(get());
} finally {
if (fout != null) {
fout.close();
}
}
} else {
File outputFile = getStoreLocation();
if (outputFile != null) {
size = outputFile.length();
if (!outputFile.renameTo(file)) {
BufferedInputStream in = null;
BufferedOutputStream out = null;
try {
in = new BufferedInputStream(
new FileInputStream(outputFile));
out = new BufferedOutputStream(
new FileOutputStream(file));
IOUtils.copy(in, out);
} finally {
if (in != null) {
try {
in.close();
} catch (IOException e) {
}
}
if (out != null) {
try {
out.close();
} catch (IOException e) {
}
}
}
}
} else {
throw new FileUploadException(
""Cannot write uploaded file to disk!"");
}
}
}
public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
public String getFieldName() {
return fieldName;
}
public void setFieldName(String fieldName) {
this.fieldName = fieldName;
}
public boolean isFormField() {
return isFormField;
}
public void setFormField(boolean state) {
isFormField = state;
}
public OutputStream getOutputStream()
throws IOException {
if (dfos == null) {
File outputFile = getTempFile();
dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);
}
return dfos;
}
public File getStoreLocation() {
return dfos.getFile();
}
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
protected File getTempFile() {
File tempDir = repository;
if (tempDir == null) {
tempDir = new File(System.getProperty(""java.io.tmpdir""));
}
String tempFileName = ""upload_"" + UID + ""_"" + getUniqueId() + "".tmp"";
File f = new File(tempDir, tempFileName);
FileCleaner.track(f, this);
return f;
}
private static String getUniqueId() {
final int limit = 100000000;
int current;
synchronized (DiskFileItem.class) {
current = counter++;
}
String id = Integer.toString(current);
if (current < limit) {
id = (""00000000"" + id).substring(id.length());
}
return id;
}
public String toString() {
return ""name="" + this.getName()
+ "", StoreLocation=""
+ String.valueOf(this.getStoreLocation())
+ "", size=""
+ this.getSize()
+ ""bytes, ""
+ ""isFormField="" + isFormField()
+ "", FieldName=""
+ this.getFieldName();
}
private void writeObject(ObjectOutputStream out) throws IOException {
if (dfos.isInMemory()) {
cachedContent = get();
} else {
cachedContent = null;
dfosFile = dfos.getFile();
}
out.defaultWriteObject();
}
private void readObject(ObjectInputStream in)
throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"header += "" "" + headerPart.substring(nonWs, end);
",0,False
"&& pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
",0,False
"return (String) headers.get(name.toLowerCase());
",0,False
"this(null, null, null);
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"return (String) headers.get(name.toLowerCase());
",0,False
"String cdl = pContentDisposition.toLowerCase();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"&& pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
",0,False
"boundary = boundaryStr.getBytes();
",0,False
"this(null, null, null);
",0,False
"paramName = paramName.toLowerCase();
",0,False
"fis.read(fileData);
",0,False
".trim().toLowerCase();
",0,False
"if (contentType.toLowerCase().startsWith(MULTIPART)) {
",0,False
"this(null, null, null);
",0,False
"this.chars = chars;
",0,False
"outputFile.delete();
",0,False
"dfosFile.delete();
",0,False
"if (!""post"".equals(request.getMethod().toLowerCase())) {
",0,False
"header += "" "" + headerPart.substring(nonWs, end);
",0,False
"boundary = boundaryStr.getBytes();
",0,False
"headerValue += "","" + iter2.next();
",0,False
"&& pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
",0,False
"paramName = paramName.toLowerCase();
",0,False
"this.chars = chars;
",0,False
"outputFile.delete();
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"} catch (UnsupportedEncodingException e) {
",0,False
"if (pContentDisposition != null
",0,False
"String name) {
",0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"}
",0,False
"&& pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
",0,False
"dfosFile.delete();
",0,False
"&& pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
",0,False
"this.chars = chars;
",0,False
"dfosFile.delete();
",0,False
"return new String(rawdata);
",0,False
"outputFile.delete();
",0,False
"if (!""post"".equals(request.getMethod().toLowerCase())) {
",0,False
"String nameLower = name.toLowerCase();
",0,False
"String nameLower = name.toLowerCase();
",0,False
"return baos.toString();
",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"outputFile.delete();
",0,False
"outputFile.delete();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"String cdl = cd.toLowerCase();
",0,False
"return cachedContent;
",0,False
"dfosFile.delete();
",0,False
"fis.read(fileData);
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"this(null, null, null);
",0,False
"this.chars = chars;
",0,False
"outputFile.delete();
",0,False
"return null;
",0,False
private boolean opened;,0,False
"throw (FileUploadException) e.getCause();
",0,False
"skip(av);
",0,False
"return cachedContent;
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"boundary = boundaryStr.getBytes(); 
",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"headers = baos.toString();
",0,False
"outputFile.delete();
",0,False
"String charset = word.substring(2, charsetPos).toLowerCase();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"return cachedContent;
",0,False
"catch ( Exception e )
",0,False
public boolean silent;,0,False
"DependencyManagement depMgt = project.getDependencyManagement();
",0,False
private MavenProject project;,0,False
"if ( ""pom"".equals( project.getPackaging() ) )
",0,False
private File cpFile;,0,False
boolean outputFilterFile;,0,False
protected ArtifactRepositoryFactory repositoryFactory;,0,False
"ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(
",0,False
"if ( parent.list().length < 2 )
",0,False
"message += ""  "" + missingArtifact.getId() + ""\n"";
",0,False
"catch ( Exception e )
",0,False
"File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
",0,False
"installer.install( artifact.getFile(), baseArtifact, targetRepository );
",0,False
protected MavenProject project;,0,False
"Set<Artifact> artifacts = project.getArtifacts();
",0,False
protected boolean outputScope;,0,False
"outputFile.getParentFile().mkdirs();
",0,False
"writer = new FileWriter( file, append );
",0,False
"location.mkdirs();
",0,False
protected List reactorProjects;,0,False
private boolean excludeTransitive;,0,False
"marker.getParentFile().mkdirs();
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"@Parameter
protected boolean ignorePermissions;",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"return recommendedVersion.compareTo( theVersion ) <= 0;
",0,False
"marker.getParentFile().mkdirs();
",0,False
"location.mkdirs();
",0,False
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0,False
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"marker.getParentFile().mkdirs();
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"out.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"catch ( Exception e )
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"private class ModuleDescriptor
{
String name;
boolean automatic = true;
",0,False
"marker.createNewFile();
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
",0,False
"out.getParentFile().mkdirs();
",0,False
"file.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
protected List reactorProjects;,0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
protected MavenProject project;,0,False
"Dependency depMgtDependency = (Dependency) mismatch.get( resolvedArtifact );
",0,False
"logArtifacts( unusedDeclared, false );
",0,False
"if ( !cpFile.isFile() )
",0,False
"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"if ( dependencyManagement != null && dependencyManagement.getDependencies() != null )
{
map = new HashMap();
for ( Iterator i = dependencyManagement.getDependencies().iterator(); i.hasNext(); )
{
Dependency d = (Dependency) i.next();
try
{
VersionRange versionRange = VersionRange.createFromVersionSpec( d.getVersion() );
Artifact artifact = artifactFactory.createDependencyArtifact( d.getGroupId(), d.getArtifactId(),
versionRange, d.getType(), d
.getClassifier(), d.getScope(), d
.isOptional() );
map.put( d.getManagementKey(), artifact );
}
catch ( InvalidVersionSpecificationException e )
{
throw new MojoExecutionException( ""Unable to parse version"", e );
}
}
}
else
{
map = Collections.EMPTY_MAP;
}
return map;
",0,False
"marker.createNewFile();
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"this.fileMappers = fileMappers;
",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"this.fileMappers = fileMappers;
",0,False
protected List reactorProjects;,0,False
protected List reactorProjects;,0,False
protected MavenProject project;,0,False
"deleteTarget.delete();
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"Set results = artifacts;
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"this.fileMappers = fileMappers;
",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"private class ModuleDescriptor
{
String name;
boolean automatic = true;
",0,False
"marker.createNewFile();
",0,False
protected boolean appendOutput;,0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
"DependencyManagement depMgt = project.getDependencyManagement();
",0,False
private MavenProjectHelper projectHelper;,0,False
private File cpFile;,0,False
"private Map<String, ArtifactRepositoryLayout> repositoryLayouts;",0,False
"if ( parent.list().length < 2 )
",0,False
protected List<MavenProject> reactorProjects;,0,False
protected List<MavenProject> reactorProjects;,0,False
"artifactRepositoryManager.createArtifactRepository( local.getId(), url, local.getLayout(),
",0,False
private List<ArtifactRepository> remotePluginRepositories;,0,False
"marker.getParentFile().mkdirs();
",0,False
"clearMarker.delete();
",0,False
private ArrayList artifactItems;,0,False
private boolean excludeTransitive;,0,False
"markersDirectory.mkdirs();
",0,False
private ArtifactFactory factory;,0,False
"catch ( Exception e )
",0,False
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"out.getParentFile().mkdirs();
",0,False
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0,False
"marker.getParentFile().mkdirs();
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"return this.fileMappers;
",0,False
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0,False
"marker.createNewFile();
",0,False
protected List reactorProjects;,0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
"DependencyManagement depMgt = project.getDependencyManagement();
",0,False
private File cpFile;,0,False
"BufferedReader r = new BufferedReader( new FileReader( outputFile ) );
",0,False
"Writer w = new BufferedWriter( new FileWriter( out ) );
",0,False
protected boolean outputScope;,0,False
"writer = new FileWriter( file );
",0,False
"marker.getParentFile().mkdirs();
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"this.fileMappers = fileMappers;
",0,False
"catch ( Exception e )
",0,False
"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
",0,False
"{
public boolean include( Artifact artifact )
{
return artifact.isSnapshot();
",0,False
"return recommendedVersion.compareTo( theVersion ) <= 0;
",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"marker.getParentFile().mkdirs();
",0,False
"catch ( Exception e )
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"if ( artifact != null )
",0,False
"this.fileMappers = fileMappers;
",0,False
"this.fileMappers = fileMappers;
",0,False
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
",0,False
"out.getParentFile().mkdirs();
",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"private class ModuleDescriptor
{
String name;
boolean automatic = true;
",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"marker.createNewFile();
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"Set results = artifacts;
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"catch ( Exception e )
",0,False
"if ( artifact != null )
",0,False
"return this.fileMappers;
",0,False
"try ( Writer w = new BufferedWriter( new FileWriter( out ) ) )
",0,True
"return this.fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"try ( FileWriter writer = new FileWriter( file, append ) )
",0,True
"writer = new FileWriter( file, append );
",0,False
protected List reactorProjects;,0,False
"Iterator iter = artifactItems.iterator();
",0,False
"markersDirectory.mkdirs();
",0,False
"log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext())
{
Artifact artifact = (Artifact) iter.next();
log.debug(""""+artifact);
}
}
",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
"Set results = artifacts;
",0,False
"catch ( Exception e )
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0,False
"private class ModuleDescriptor
{
String name;
boolean automatic = true;
",0,False
"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
",0,False
"return (cpString.equals(oldCp) || ( cpString != null && cpString.equals( oldCp ) ) );
",0,False
protected boolean appendOutput;,0,False
"r = new BufferedReader( new FileReader( outputFile ) );
",1,False
"marker.getParentFile().mkdirs();
",0,False
private File markersDirectory;,0,False
protected boolean useSubDirectoryPerType;,0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker);
",0,False
"@Deprecated
public static String PROVIDER;",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"file.setGroup(grp);
",0,False
"return null;
",0,False
"return null;
",0,False
"if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}
",0,False
"ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(
""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
",0,False
public String identifier;,0,False
"__queue.notify();
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
",0,False
"(encoding == null ? buffer.toString().getBytes() : buffer.toString().getBytes(encoding));
",0,False
"return null;
",0,False
"return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
",0,False
"if (!(pObject instanceof byte[])) {
throw new RuntimeException(""Parameter supplied to Base64 encode is not a byte[]"");
}
return encode((byte[]) pObject);
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return (IOException) getCause(); 
",0,False
"return null;
",0,False
"__receiveState = _STATE_DATA;
break; 
",0,False
"return null;
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
"final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) { 
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
"" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
"" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(
""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(
""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"") 
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for(String s : l) {
System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[]{args.getClass()});
String[] args2 = new String[args.length-1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object)args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"return null;
",0,False
"ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(
""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
",0,False
"num = size = 0;
",0,False
"(SSLSocket) ssf.createSocket(_socket_, host, port, true);
",0,False
"return null;
",0,False
"__queue.notify();
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"modulus = (++modulus) % 3;
",0,False
"@Deprecated
public static String TRUSTSTORE_ALGORITHM;",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"return null;
",0,False
"return null;
",0,False
"ThreadContainer root = new ThreadContainer();
Iterator<Map.Entry<String, ThreadContainer>> iter = idTable.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, ThreadContainer> entry = iter.next();
ThreadContainer c = entry.getValue();
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(
""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
",0,False
"idTable = null;
",0,False
"return null;
",0,False
"num = size = 0;
",0,False
"return null;
",0,False
"__receiveState = _STATE_DATA;
break; 
",0,False
"__queue.wait(100);
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0,False
"long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int)countLong;
",0,False
"reader = new BufferedReader(new InputStreamReader(stream));
",0,False
"return sendCommand(CMD_ADAT, new String(Base64.encodeBase64(data)));
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"ThreadContainer c = idTable.get(key);
",0,False
"return null;
",0,False
public int size;,0,False
"return null;
",0,False
"return null;
",0,False
"__queue.wait(100);
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"if (pObject instanceof byte[]) {
return decode((byte[]) pObject);
} else if (pObject instanceof String) {
return decode((String) pObject);
} else {
throw new RuntimeException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
",0,False
"modulus = (++modulus) % 3;
",0,False
"this(new PrintWriter(stream), suppressLogin);
",0,False
"final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) { 
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
"" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
"" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(
""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(
""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"") 
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for(String s : l) {
System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[]{args.getClass()});
String[] args2 = new String[args.length-1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object)args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}
",0,False
"file.setGroup(grp);
",0,False
"return (IOException) getCause(); 
",0,False
"return null;
",0,False
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
bogusIdCount++ ; 
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0,False
"__queue.notify();
",0,False
"__queue.notify();
",0,False
"return null;
",0,False
"return null;
",0,False
"output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"file.setUser(usr);
",0,False
"file.setGroup(grp);
",0,False
"createCommandSupport();
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"ThreadContainer c = idTable.get(key);
",0,False
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0,False
"if (messages == null) {
return null;
}
HashMap<String,ThreadContainer> idTable = new HashMap<String,ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
",0,False
"return null;
",0,False
"aytMonitor.wait(timeout);
",0,False
"return null;
",0,False
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",0,False
"modulus = (++modulus) % 4;
",0,False
"return null;
",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
",0,False
"file.setUser(usr);
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"__queue.wait(100);
",0,False
"return null;
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0,False
"long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int)countLong;
",0,False
"return null;
",0,False
"@Deprecated
public static String KEYSTORE_ALGORITHM;",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"return null;
",0,False
"return null;
",0,False
"ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(
""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
",0,False
"Iterator<String> iter = idTable.keySet().iterator();
",0,False
"ThreadContainer container = idTable.get(id);
",0,False
"digest = md5.digest(timestamp.getBytes());
",0,False
"(SSLSocket) ssf.createSocket(_socket_, ip, port, true);
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"aytMonitor.wait(timeout);
",0,False
"_output_.write(terminalType.getBytes());
",0,False
"return null;
",0,False
"modulus = (++modulus) % 3;
",0,False
"if (pObject instanceof byte[]) {
return decode((byte[]) pObject);
} else if (pObject instanceof String) {
return decode((String) pObject);
} else {
throw new RuntimeException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
",0,False
"return null;
",0,False
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",1,False
"return null;
",0,False
public String identifier;,0,False
"Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())
",0,False
"file.setGroup(grp);
",0,False
"(SSLSocket) ssf.createSocket(_socket_, ip, port, true);
",0,False
public int size;,0,False
"(SSLSocket) ssf.createSocket(_socket_, host, port, false);
",1,False
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",1,False
"ThreadContainer c = idTable.get(key);
",1,False
"writeLock.tryLock();
",0,False
"} catch (Exception e2) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"latch.notify();
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e1) {
",0,False
private int maxSleeping;,0,True
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"latch.notify();
",0,False
"scheduledFuture.cancel(false);
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception e) {
",0,False
private int _maxSleeping = StackObjectPool.DEFAULT_MAX_SLEEPING;,0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
private int _minIdle = DEFAULT_MIN_IDLE;,0,False
private GenericObjectPoolConfig config;,0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"ObjectQueue pool = _poolMap.get(key);
",0,False
"} catch (Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"final LinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"latch.notify();
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
private long _maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;,0,False
"} catch (Exception e) {
",0,False
private int _numTestsPerEvictionRun = GenericKeyedObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;,0,False
"} catch (Exception e) {
",0,False
"latch.notify();
",0,False
"final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
",0,False
"final long lastActiveDiff =
this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int)Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"writeLock.tryLock();
",0,False
"} catch (final Exception e1) {
",0,False
"scheduledFuture.cancel(false);
",0,False
"writeLock.tryLock();
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"result = result * ((counter - 1) / counter) +
",1,True
"writeLock.tryLock();
",1,False
"} catch (Exception e) {
",1,False
private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1,True
"} catch (Exception e) {
",1,False
"writeLock.tryLock();
",1,False
"writeLock.tryLock();
",1,False
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;,1,True
private int initIdleCapacity;,1,False
private int maxSleeping;,1,True
"ObjectDeque<T> queue = poolMap.get(k);
",1,False
"writeLock.tryLock();
",1,False
"writeLock.tryLock();
",1,False
"Collection c = (Collection) m.get(key);
",1,False
"return _factory;
",1,True
"readLock.tryLock();
",1,True
"ObjectDeque<T> queue = poolMap.get(key);
",1,False
"poolMap.get(k).getIdleObjects();
",1,False
"synchronized (poolMap) {
",1,False
"_numActive--;
",1,True
"_activeCount.put(key,new Integer(1));
",1,False
private int maxSleeping;,1,True
"} catch (Exception e2) {
",1,False
protected int _totActive = 0;,1,False
protected PoolableObjectFactory _factory = null;,1,True
"} catch (Exception e) {
",1,False
"final ObjectDeque<T> queue = poolMap.get(k);
",1,False
private int maxSleeping;,1,True
private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1,True
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1,True
private Exception borrowedBy = null;,1,True
"synchronized (poolMap) {
",1,False
private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1,True
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"Collection c = (Collection) m.get(key);
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"latch.notify();
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"private Listable _prev = null;
private Listable _next = null;
private Object _val = null;
Listable(Listable prev, Listable next, Object val) {
_prev = prev;
_next = next;
_val = val;
}
Listable next() {
return _next;
}
Listable prev() {
return _prev;
}
Object value() {
return _val;
}
void setNext(Listable next) {
_next = next;
}
void setPrev(Listable prev) {
_prev = prev;
}
Object setValue(Object val) {
Object temp = _val;
_val = val;
return temp;
",0,False
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory getFactory() {
return _factory;
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
protected int _totIdle = 0;,0,True
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class Cursor extends ListIter implements ListIterator<E> {
boolean _valid = false;
Cursor(int index) {
super(index);
_valid = true;
registerCursor(this);
}
@Override
public int previousIndex() {
throw new UnsupportedOperationException();
}
@Override
public int nextIndex() {
throw new UnsupportedOperationException();
}
@Override
public void add(E o) {
checkForComod();
Listable<E> elt = insertListable(_cur.prev(),_cur.next(),o);
_cur.setPrev(elt);
_cur.setNext(elt.next());
_lastReturned = null;
_nextIndex++;
_expectedModCount++;
}
protected void listableRemoved(Listable<E> elt) {
if(null == _head.prev()) {
_cur.setNext(null);
} else if(_cur.next() == elt) {
_cur.setNext(elt.next());
}
if(null == _head.next()) {
_cur.setPrev(null);
} else if(_cur.prev() == elt) {
_cur.setPrev(elt.prev());
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableInserted(Listable<E> elt) {
if(null == _cur.next() && null == _cur.prev()) {
_cur.setNext(elt);
} else if(_cur.prev() == elt.prev()) {
_cur.setNext(elt);
}
if(_cur.next() == elt.next()) {
_cur.setPrev(elt);
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableChanged(Listable<E> elt) {
if(_lastReturned == elt) {
_lastReturned = null;
}
}
@Override
protected void checkForComod() {
if(!_valid) {
throw new ConcurrentModificationException();
}
}
protected void invalidate() {
_valid = false;
}
public void close() {
if(_valid) {
_valid = false;
unregisterCursor(this);
}
}
",0,False
"public class GenericKeyedObjectPool<K, V> extends BaseKeyedObjectPool<K, V> implements KeyedObjectPool<K, V> {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap<K, ObjectQueue>();
_poolList = new CursorableLinkedList<K>();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public void setMaxTotal(int maxTotal) {
synchronized(this) {
_maxTotal = maxTotal;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
@Override
public V borrowObject(K key) throws Exception {
long starttime = System.currentTimeMillis();
Latch<K, V> latch = new Latch<K, V>(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
latch.getPool().decrementInternalProcessingCount();
doAllocate = true;
} else {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
returnObject(latch.getkey(), latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
V obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair<V>(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
}
allocate();
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
@Override
public void clear() {
Map<K,  List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K,  List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext();) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final K key = keyiter.next();
final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set<Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final List<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
@Override
public void clear(K key) {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K , List<ObjectTimestampPair<V>>>();
final ObjectQueue pool;
synchronized (this) {
pool = _poolMap.remove(key);
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map<K,  List<ObjectTimestampPair<V>>> m, KeyedPoolableObjectFactory<K, V> factory) {
for (Iterator<Entry<K,  List<ObjectTimestampPair<V>>>> entries = m.entrySet().iterator(); entries.hasNext();) {
Entry<K,  List<ObjectTimestampPair<V>>> entry = entries.next();
K key = entry.getKey();
List<ObjectTimestampPair<V>> c = entry.getValue();
for (Iterator<ObjectTimestampPair<V>> it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,it.next().value);
} catch(Exception e) {
} finally {
synchronized(this) {
ObjectQueue objectQueue =
_poolMap.get(key);
if (objectQueue != null) {
objectQueue.decrementInternalProcessingCount();
if (objectQueue.internalProcessingCount == 0 &&
objectQueue.activeCount == 0 &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_totalInternalProcessing--;
}
}
allocate();
}
}
}
}
@Override
public synchronized int getNumActive() {
return _totalActive;
}
@Override
public synchronized int getNumIdle() {
return _totalIdle;
}
@Override
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
@Override
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}
private void addObjectToPool(K key, V obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
@Override
public void invalidateObject(K key, V obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
}
allocate(); 
}
}
@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
@Deprecated
@Override
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext();) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
_evictionCursor.previous() :
_evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue =
_poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() &&
objectQueue.activeCount == 0 &&
objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
CursorableLinkedList<ObjectTimestampPair<V>> queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
@SuppressWarnings(""unchecked"")
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle((K)keysCopy[i]);
}
}
}
private void ensureMinIdle(K key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
}
allocate();
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList<ObjectTimestampPair<V>> queue = new CursorableLinkedList<ObjectTimestampPair<V>>();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair<T> implements Comparable<T> {
//CHECKSTYLE: stop VisibilityModifier
@Deprecated
T value;
@Deprecated
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(T val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(T val, long time) {
value = val;
tstamp = time;
}
@Override
public String toString() {
return value + "";"" + tstamp;
}
@SuppressWarnings(""unchecked"")
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair<T>) obj);
}
public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public T getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
@Override
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private final class Latch<LK, LV> {
private final LK _key;
private ObjectQueue _pool;
private ObjectTimestampPair<LV> _pair;
private boolean _mayCreate = false;
private Latch(LK key) {
_key = key;
}
private synchronized LK getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair<LV> getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair<LV> pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map<K, ObjectQueue> _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory<K, V> _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList<K> _poolList = null;
private CursorableLinkedList<ObjectTimesta",0,False
"catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"@Deprecated
protected int _totIdle = 0;",0,False
"Stack<V> s = _pools.get(key);
",0,False
"} catch (Exception e) {
",0,False
"this(null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this(null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this(null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap<K, Stack<V>>();
_activeCount = new HashMap<K, Integer>();
}
@Override
public synchronized V borrowObject(K key) throws Exception {
assertOpen();
Stack<V> stack = (_pools.get(key));
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
V obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
@Override
public synchronized void invalidateObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
@Override
public synchronized int getNumIdle() {
return _totIdle;
}
@Override
public synchronized int getNumActive() {
return _totActive;
}
@Override
public synchronized int getNumActive(K key) {
return getActiveCount(key);
}
@Override
public synchronized int getNumIdle(K key) {
try {
return(_pools.get(key)).size();
} catch(Exception e) {
return 0;
}
}
@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while(it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
@Override
public synchronized void clear(K key) {
Stack<V> stack = _pools.remove(key);
destroyStack(key,stack);
}
private synchronized void destroyStack(K key, Stack<V> stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator<V> it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while(it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Deprecated
@Override
public synchronized void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory<K, V> getFactory() {
return _factory;
}
private int getActiveCount(K key) {
try {
return _activeCount.get(key).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map<K, Stack<V>> getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map<K, Integer> getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
@Deprecated
protected HashMap<K, Stack<V>> _pools = null;
@Deprecated
protected KeyedPoolableObjectFactory<K, V> _factory = null;
@Deprecated
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
@Deprecated
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
@Deprecated
protected int _totActive = 0;
@Deprecated
protected int _totIdle = 0;
@Deprecated
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
for (;;) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy);
}
private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext();) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDefecit(pool, false);
for (int i = 0; i < objectDeficit && calculateDefecit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
buf.append(""\t"").append(_poolMap.get(it.next())).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return _numTestsPerEvictionRun;
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDefecit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"catch (Exception e) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
_numInternalProcessing--;
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
allocate();
}
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy);
}
private void destroy(Collection c) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"private Listable _prev = null;
private Listable _next = null;
private Object _val = null;
Listable(Listable prev, Listable next, Object val) {
_prev = prev;
_next = next;
_val = val;
}
Listable next() {
return _next;
}
Listable prev() {
return _prev;
}
Object value() {
return _val;
}
void setNext(Listable next) {
_next = next;
}
void setPrev(Listable prev) {
_prev = prev;
}
Object setValue(Object val) {
Object temp = _val;
_val = val;
return temp;
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator entries = m.entrySet().iterator(); entries.hasNext();) {
Map.Entry entry = (Entry) entries.next();
Object key = entry.getKey();
Collection c = (Collection) entry.getValue();
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
//CHECKSTYLE: stop VisibilityModifier
Object value;
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public Object getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int minIdle) {
synchronized(this) {
_minIdle = minIdle;
}
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public void setConfig(GenericObjectPool.Config conf) {
synchronized (this) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
}
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
_numInternalProcessing--;
doAllocate = true;
} else {
_numInternalProcessing--;
_numActive++;
returnObject(latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
}
allocate();
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection c, PoolableObjectFactory factory) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
}
allocate();
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
final PoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectQueue pool = _poolMap.get(key);
",0,False
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0,False
private ClassLoader _factoryClassLoader = null;,0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"@Deprecated
protected int _totActive = 0;",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"boolean _valid = false;
Cursor(int index) {
super(index);
_valid = true;
registerCursor(this);
}
public int previousIndex() {
throw new UnsupportedOperationException();
}
public int nextIndex() {
throw new UnsupportedOperationException();
}
public void add(Object o) {
checkForComod();
Listable elt = insertListable(_cur.prev(),_cur.next(),o);
_cur.setPrev(elt);
_cur.setNext(elt.next());
_lastReturned = null;
_nextIndex++;
_expectedModCount++;
}
protected void listableRemoved(Listable elt) {
if(null == _head.prev()) {
_cur.setNext(null);
} else if(_cur.next() == elt) {
_cur.setNext(elt.next());
}
if(null == _head.next()) {
_cur.setPrev(null);
} else if(_cur.prev() == elt) {
_cur.setPrev(elt.prev());
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableInserted(Listable elt) {
if(null == _cur.next() && null == _cur.prev()) {
_cur.setNext(elt);
} else if(_cur.prev() == elt.prev()) {
_cur.setNext(elt);
}
if(_cur.next() == elt.next()) {
_cur.setPrev(elt);
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableChanged(Listable elt) {
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void checkForComod() {
if(!_valid) {
throw new ConcurrentModificationException();
}
}
protected void invalidate() {
_valid = false;
}
public void close() {
if(_valid) {
_valid = false;
unregisterCursor(this);
}
}
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory getFactory() {
return _factory;
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"catch (Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"if (!idleQueue.offerFirst(this)) {
",0,False
"ObjectDeque<T> queue = poolMap.get(k);
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0,False
"} catch (Exception e1) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"catch (Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"this((PoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle) {
this((PoolableObjectFactory)null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this((PoolableObjectFactory)null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized int getNumIdle() {
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected Stack _pool = null;
protected PoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _numActive = 0;
public synchronized PoolableObjectFactory getFactory() {
return _factory;
}
public int getMaxSleeping() {
return _maxSleeping;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"private Listable _prev = null;
private Listable _next = null;
private Object _val = null;
Listable(Listable prev, Listable next, Object val) {
_prev = prev;
_next = next;
_val = val;
}
Listable next() {
return _next;
}
Listable prev() {
return _prev;
}
Object value() {
return _val;
}
void setNext(Listable next) {
_next = next;
}
void setPrev(Listable prev) {
_prev = prev;
}
Object setValue(Object val) {
Object temp = _val;
_val = val;
return temp;
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
protected int _totIdle = 0;,0,True
"} catch (Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"ObjectDeque<T> queue = poolMap.get(k);
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"l.notify();
",0,False
"public class GenericKeyedObjectPool<K, V> extends BaseKeyedObjectPool<K, V> implements KeyedObjectPool<K, V> {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap<K, ObjectQueue>();
_poolList = new CursorableLinkedList<K>();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public void setMaxTotal(int maxTotal) {
synchronized(this) {
_maxTotal = maxTotal;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
@Override
public V borrowObject(K key) throws Exception {
long starttime = System.currentTimeMillis();
Latch<K, V> latch = new Latch<K, V>(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
latch.getPool().decrementInternalProcessingCount();
doAllocate = true;
} else {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
returnObject(latch.getkey(), latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
V obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair<V>(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
}
allocate();
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
@Override
public void clear() {
Map<K,  List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K,  List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext();) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final K key = keyiter.next();
final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set<Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final List<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
@Override
public void clear(K key) {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K , List<ObjectTimestampPair<V>>>();
final ObjectQueue pool;
synchronized (this) {
pool = _poolMap.remove(key);
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map<K,  List<ObjectTimestampPair<V>>> m, KeyedPoolableObjectFactory<K, V> factory) {
for (Iterator<Entry<K,  List<ObjectTimestampPair<V>>>> entries = m.entrySet().iterator(); entries.hasNext();) {
Entry<K,  List<ObjectTimestampPair<V>>> entry = entries.next();
K key = entry.getKey();
List<ObjectTimestampPair<V>> c = entry.getValue();
for (Iterator<ObjectTimestampPair<V>> it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,it.next().value);
} catch(Exception e) {
} finally {
synchronized(this) {
ObjectQueue objectQueue =
_poolMap.get(key);
if (objectQueue != null) {
objectQueue.decrementInternalProcessingCount();
if (objectQueue.internalProcessingCount == 0 &&
objectQueue.activeCount == 0 &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_totalInternalProcessing--;
}
}
allocate();
}
}
}
}
@Override
public synchronized int getNumActive() {
return _totalActive;
}
@Override
public synchronized int getNumIdle() {
return _totalIdle;
}
@Override
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
@Override
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}
private void addObjectToPool(K key, V obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
@Override
public void invalidateObject(K key, V obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
}
allocate(); 
}
}
@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
@Deprecated
@Override
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext();) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
_evictionCursor.previous() :
_evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue =
_poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() &&
objectQueue.activeCount == 0 &&
objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
CursorableLinkedList<ObjectTimestampPair<V>> queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
@SuppressWarnings(""unchecked"")
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle((K)keysCopy[i]);
}
}
}
private void ensureMinIdle(K key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
}
allocate();
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList<ObjectTimestampPair<V>> queue = new CursorableLinkedList<ObjectTimestampPair<V>>();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair<T> implements Comparable<T> {
//CHECKSTYLE: stop VisibilityModifier
@Deprecated
T value;
@Deprecated
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(T val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(T val, long time) {
value = val;
tstamp = time;
}
@Override
public String toString() {
return value + "";"" + tstamp;
}
@SuppressWarnings(""unchecked"")
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair<T>) obj);
}
public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public T getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
@Override
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private final class Latch<LK, LV> {
private final LK _key;
private ObjectQueue _pool;
private ObjectTimestampPair<LV> _pair;
private boolean _mayCreate = false;
private Latch(LK key) {
_key = key;
}
private synchronized LK getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair<LV> getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair<LV> pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map<K, ObjectQueue> _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory<K, V> _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList<K> _poolList = null;
private CursorableLinkedList<ObjectTimesta",0,False
"} catch(Exception e) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList<SoftReference<T>>();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory<T> factory) {
_pool = new ArrayList<SoftReference<T>>();
_factory = factory;
}
@Deprecated
public SoftReferenceObjectPool(PoolableObjectFactory<T> factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList<SoftReference<T>>(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference<T> ref = _pool.remove(_pool.size() - 1);
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference<T>(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference<T>(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized void clear() {
if(null != _factory) {
Iterator<SoftReference<T>> iter = _pool.iterator();
while(iter.hasNext()) {
try {
T obj = iter.next().get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Deprecated
@Override
public synchronized void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference<? extends T> ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
public synchronized PoolableObjectFactory<T> getFactory() {
return _factory;
}
private final List<SoftReference<T>> _pool;
private PoolableObjectFactory<T> _factory = null;
private final ReferenceQueue<T> refQueue = new ReferenceQueue<T>();
private int _numActive = 0; 
",0,False
"@Deprecated
protected int _totActive = 0;",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
protected int _totIdle = 0;,0,True
"} catch (Exception e) {
",0,False
"latch.notify();
",0,False
"catch (Exception e) {
",0,False
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0,False
"latch.notify();
",0,False
private long maxWait;,0,False
private WhenExhaustedAction whenExhaustedAction;,0,False
private boolean testWhileIdle;,0,False
private boolean testOnBorrow;,0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
private boolean testOnReturn;,0,False
private boolean lifo;,0,False
private int numTestsPerEvictionRun;,0,False
private long timeBetweenEvictionRunsMillis;,0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"poolMap.get(k).getIdleObjects();
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"nsee.initCause(validationThrowable);
",0,False
"nsee.initCause(validationThrowable);
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"ObjectDeque<T> queue = poolMap.get(k);
",0,False
"} catch (Exception e) {
",0,False
"if (!idleQueue.offerFirst(this)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"boolean _valid = false;
Cursor(int index) {
super(index);
_valid = true;
registerCursor(this);
}
public int previousIndex() {
throw new UnsupportedOperationException();
}
public int nextIndex() {
throw new UnsupportedOperationException();
}
public void add(Object o) {
checkForComod();
Listable elt = insertListable(_cur.prev(),_cur.next(),o);
_cur.setPrev(elt);
_cur.setNext(elt.next());
_lastReturned = null;
_nextIndex++;
_expectedModCount++;
}
protected void listableRemoved(Listable elt) {
if(null == _head.prev()) {
_cur.setNext(null);
} else if(_cur.next() == elt) {
_cur.setNext(elt.next());
}
if(null == _head.next()) {
_cur.setPrev(null);
} else if(_cur.prev() == elt) {
_cur.setPrev(elt.prev());
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableInserted(Listable elt) {
if(null == _cur.next() && null == _cur.prev()) {
_cur.setNext(elt);
} else if(_cur.prev() == elt.prev()) {
_cur.setNext(elt);
}
if(_cur.next() == elt.next()) {
_cur.setPrev(elt);
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableChanged(Listable elt) {
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void checkForComod() {
if(!_valid) {
throw new ConcurrentModificationException();
}
}
protected void invalidate() {
_valid = false;
}
public void close() {
if(_valid) {
_valid = false;
unregisterCursor(this);
}
}
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"@Deprecated
protected int _totIdle = 0;",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"private Listable _prev = null;
private Listable _next = null;
private Object _val = null;
Listable(Listable prev, Listable next, Object val) {
_prev = prev;
_next = next;
_val = val;
}
Listable next() {
return _next;
}
Listable prev() {
return _prev;
}
Object value() {
return _val;
}
void setNext(Listable next) {
_next = next;
}
void setPrev(Listable prev) {
_prev = prev;
}
Object setValue(Object val) {
Object temp = _val;
_val = val;
return temp;
",0,False
"} catch(Exception e) {
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"latch.notify();
",0,False
"} catch (Exception ex2) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int minIdle) {
synchronized(this) {
_minIdle = minIdle;
}
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public void setConfig(GenericObjectPool.Config conf) {
synchronized (this) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
}
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
_numInternalProcessing--;
doAllocate = true;
} else {
_numInternalProcessing--;
_numActive++;
returnObject(latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
}
allocate();
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection c, PoolableObjectFactory factory) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
}
allocate();
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
final PoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList _allocationQueue = new LinkedList();
",0,False
protected int _totIdle = 0;,0,True
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory getFactory() {
return _factory;
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"scheduledFuture.cancel(false);
",0,False
"return (E) throwable;
",0,False
"} catch (final Exception ignored) {
",0,False
"scheduledFuture.cancel(false);
",0,False
"throw (Error) validationThrowable;
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy);
}
private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext();) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
for (;;) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
toDestroy.put(key, pool.queue);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
}
}
destroy(toDestroy);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
toDestroy.put(key, pool.queue);
}
destroy(toDestroy);
}
private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext();) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
toDestroy.put(key, pool.queue);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
}
}
destroy(toDestroy);
_factory = factory;
}
}
destroy(toDestroy);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDefecit(pool, false);
for (int i = 0; i < objectDeficit && calculateDefecit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
buf.append(""\t"").append(_poolMap.get(it.next())).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return _numTestsPerEvictionRun;
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDefecit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"catch (Exception e) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
_numInternalProcessing--;
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
allocate();
}
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy);
}
private void destroy(Collection c) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,False
"if (!idleQueue.offerFirst(this)) {
",0,False
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"borrowedCount++;
",0,False
"} catch (Exception e1) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"scheduledFuture.cancel(false);
",0,False
"borrowedCount++;
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
private int numActive;,0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null,DEFAULT_MAX_ACTIVE,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_ACTIVE,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory,config.maxActive,config.whenExhaustedAction,config.maxWait,config.maxIdle,config.maxTotal, config.minIdle,config.testOnBorrow,config.testOnReturn,config.timeBetweenEvictionRunsMillis,config.numTestsPerEvictionRun,config.minEvictableIdleTimeMillis,config.testWhileIdle,config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory,maxActive,whenExhaustedAction,maxWait,DEFAULT_MAX_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory,maxActive,whenExhaustedAction,maxWait,DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory,maxActive,whenExhaustedAction,maxWait,maxIdle,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory,maxActive,whenExhaustedAction,maxWait,maxIdle,testOnBorrow,testOnReturn,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle, DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
notifyAll();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
notifyAll();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
notifyAll();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
notifyAll();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
boolean newlyCreated = false;
for(;;) {
ObjectTimestampPair pair = null;
ObjectQueue pool = null;
synchronized (this) {
assertOpen();
pool = (ObjectQueue)(_poolMap.get(key));
if(null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
try {
pair = (ObjectTimestampPair)(pool.queue.removeFirst());
if(null != pair) {
_totalIdle--;
}
} catch(NoSuchElementException e) { 
}
if(null == pair) {
if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {
clearOldest();
}
if ((_maxActive < 0 || pool.activeCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
Object obj = _factory.makeObject(key);
pair = new ObjectTimestampPair(obj);
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException();
case WHEN_EXHAUSTED_BLOCK:
try {
if(_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0)
{
wait(waitTime);
}
}
} catch(InterruptedException e) {
}
if(_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + _whenExhaustedAction + "" not recognized."");
}
}
}
pool.incrementActiveCount();
}
try {
_factory.activateObject(key, pair.value);
} catch (Exception e) {
try {
_factory.destroyObject(key,pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e2) {
}
if(newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: ""
+ e.getMessage());
}
else {
continue; 
}
}
boolean invalid = true;
try {
invalid = _testOnBorrow && !_factory.validateObject(key, pair.value);
} catch (Exception e) {
}
if (invalid) {
try {
_factory.destroyObject(key,pair.value);
synchronized (this) {
pool.decrementActiveCount();
}
} catch (Exception e) {
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object"");
} 
} else {
return pair.value;
}
}
}
public synchronized void clear() {
for(Iterator entries = _poolMap.entrySet().iterator(); entries.hasNext(); ) {
final Map.Entry entry = (Map.Entry)entries.next();
final Object key = entry.getKey();
final CursorableLinkedList list = ((ObjectQueue)(entry.getValue())).queue;
for(Iterator it = list.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
}
it.remove();
}
}
_poolMap.clear();
_poolList.clear();
_totalIdle = 0;
notifyAll();
}
public synchronized void clearOldest() {
final Map map = new TreeMap();
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
try {
_factory.destroyObject(key, pairTimeStamp.value);
} catch (Exception e) {
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
itemsToRemove--;
}
notifyAll();
}
public synchronized void clear(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.remove(key));
if(null == pool) {
return;
} else {
_poolList.remove(key);
for(Iterator it = pool.queue.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
}
it.remove();
_totalIdle--;
}
}
notifyAll();
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
notifyAll();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if(_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if(null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if(_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
notifyAll();
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if(null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
notifyAll(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
synchronized (this) {
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if(null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if(null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized void evict() throws Exception {
Object key = null;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
for (int i=0,m=getNumTests(); i<m; i++) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
ObjectTimestampPair pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
boolean removeObject=false;
if((_minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
_minEvictableIdleTimeMillis)) {
removeObject=true;
}
if(_testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if(removeObject) {
try {
_evictionCursor.remove();
_totalIdle--;
_factory.destroyObject(key, pair.value);
if (_minIdle == 0) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
} catch(Exception e) {
; 
}
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue =
(CursorableLinkedList)(pool.queue);
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private synchronized void ensureMinIdle() throws Exception {
Iterator iterator = _poolMap.keySet().iterator();
if (_minIdle > 0) {
while (iterator.hasNext()) {
Object key = iterator.next();
ensureMinIdle(key);
}
}
}
private synchronized void ensureMinIdle(Object key) throws Exception {
int numberToCreate = calculateDefecit(key);
for (int i = 0; i < numberToCreate; i++) {
addObject(key);
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while(it.hasNext()) {
buf.append(""\t"").append(_poolMap.get(it.next())).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return _numTestsPerEvictionRun;
} else {
return(int)(Math.ceil((double)_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private int calculateDefecit(Object key) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - getNumIdle(key);
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - getNumActive(key) - getNumIdle(key));
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle());
objectDefecit = Math.min(objectDefecit, growLimit);
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
void incrementActiveCount() {
_totalActive++;
activeCount++;
}
void decrementActiveCount() {
_totalActive--;
if (activeCount > 0) {
activeCount--;
}
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception e2) {
",0,False
