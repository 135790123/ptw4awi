source,target,raw_preds
"@Deprecated
public static final String[] METHODHANDLE_NAMES = { """", ""getField"", ""getStatic"", ""putField"", ""putStatic"", ""invokeVirtual"", ""invokeStatic"", ""invokeSpecial"", ""newInvokeSpecial"", ""invokeInterface"" };",0,True
"public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"", ""LocalVariableTypeTable"", ""EnclosingMethod"", ""StackMapTable"", ""BootstrapMethods"", ""MethodParameters"" };",1,True
"@Deprecated
public static final String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",1,False
"return exception_index_table;
",0,False
"this.arg_types = arg_types;
",0,False
"this.local_variable_table = local_variable_table;
",0,False
"ConstantString s = (ConstantString) c;
",0,False
"return line_number_table;
",0,False
"this.line_number_table = line_number_table;
",0,False
"@Deprecated
public static final int[] CONSUME_STACK = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 3, 4, 3, 4, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 3, 4, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 2, 1, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 4, 2, 4, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 4, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 1, 2, 1, 0, 0, UNPREDICTABLE, 1, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, UNPREDICTABLE, 1, 1, 0, 0, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1,False
"this.local_variable_type_table = local_variable_table;
",0,False
"this.local_variable_type_table = local_variable_table;
",0,False
"@Deprecated
public static final String[] METHODHANDLE_NAMES = { """", ""getField"", ""getStatic"", ""putField"", ""putStatic"", ""invokeVirtual"", ""invokeStatic"", ""invokeSpecial"", ""newInvokeSpecial"", ""invokeInterface"" };",1,True
"public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",1,True
"@Deprecated
public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"", """", """", ""CONSTANT_MethodHandle"", ""CONSTANT_MethodType"", """", ""CONSTANT_InvokeDynamic"" };",0,True
"this.bootstrap_methods = bootstrap_methods;
",0,False
"@Deprecated
public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0,True
"return exception_table;
",0,False
"this(c.getStartPC(), c.getEndPC(), c.getHandlerPC(), c.getCatchType());
}
CodeException(DataInput file) throws IOException {
this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file
.readUnsignedShort());
}
public CodeException(int start_pc, int end_pc, int handler_pc, int catch_type) {
this.start_pc = start_pc;
this.end_pc = end_pc;
this.handler_pc = handler_pc;
this.catch_type = catch_type;
}
@Override
public void accept( Visitor v ) {
v.visitCodeException(this);
}
public final void dump( DataOutputStream file ) throws IOException {
file.writeShort(start_pc);
file.writeShort(end_pc);
file.writeShort(handler_pc);
file.writeShort(catch_type);
}
public final int getCatchType() {
return catch_type;
}
public final int getEndPC() {
return end_pc;
}
public final int getHandlerPC() {
return handler_pc;
}
public final int getStartPC() {
return start_pc;
}
public final void setCatchType( int catch_type ) {
this.catch_type = catch_type;
}
public final void setEndPC( int end_pc ) {
this.end_pc = end_pc;
}
public final void setHandlerPC( int handler_pc ) { 
this.handler_pc = handler_pc;
}
public final void setStartPC( int start_pc ) { 
this.start_pc = start_pc;
}
@Override
public final String toString() {
return ""CodeException(start_pc = "" + start_pc + "", end_pc = "" + end_pc + "", handler_pc = ""
+ handler_pc + "", catch_type = "" + catch_type + "")"";
}
public final String toString( ConstantPool cp, boolean verbose ) {
String str;
if (catch_type == 0) {
str = ""<Any exception>(0)"";
} else {
str = Utility.compactClassName(cp.getConstantString(catch_type, Const.CONSTANT_Class), false)
+ (verbose ? ""("" + catch_type + "")"" : """");
}
return start_pc + ""\t"" + end_pc + ""\t"" + handler_pc + ""\t"" + str;
}
public final String toString( ConstantPool cp ) {
return toString(cp, true);
}
public CodeException copy() {
try {
return (CodeException) clone();
} catch (CloneNotSupportedException e) {
}
return null;
",0,False
"return new Double(bytes);
",0,False
"return new Float(bytes);
",0,False
"this.constant_pool = constant_pool;
",0,False
"ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
",0,False
"str = constantToString(((ConstantNameAndType) c).getNameIndex(),
",0,False
"str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class)
",0,False
"str = String.valueOf(((ConstantLong) c).getBytes());
",0,False
"return bytes;
",0,False
"return annotationEntries;
",0,False
"return inner_classes;
",0,False
"this.interfaces = interfaces;
",0,False
"return attributes;
",0,False
"this.methods = methods;
",0,False
"if (debug) {
System.out.println(str);
}
}
",0,False
"this.local_variable_type_table = local_variable_table;
",0,False
"return annotation_table;
",0,False
"return new String(buf);
",0,False
"ch = in.read();
",0,False
"this.map = map;
",0,False
"return types_of_stack_items;
",0,False
"System.exit(-1);
",0,False
"buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
",0,False
"return null;
",0,False
"return addLong(((ConstantLong) c).getBytes());
",0,False
"return addUtf8(((ConstantUtf8) c).getBytes());
",0,False
"ConstantString s = (ConstantString) c;
",0,False
"return addFloat(((ConstantFloat) c).getBytes());
",0,False
"return new AnnotationElementValueGen(
",0,False
"this.arg_names = arg_names;
",0,False
"int m = match[(l + r) / 2];
",0,False
"return indices;
",0,False
"} catch (Exception e) {
",0,False
"wide = false; 
",0,False
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
",0,False
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_methods.html""));
",0,False
"if (method_nr < 0 || method_nr >= localVariablesInfos.length){
",0,False
"@Deprecated
Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = { NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR };",0,False
"return annotationTable;
",0,False
"this.annotationTable = annotationTable;
",0,False
"return elementValues;
",0,False
"this.bootstrapMethods = bootstrapMethods;
",0,False
"return attributes;
",0,False
"return code;
",0,False
"return new Float(bytes);
",0,False
"this.constantPool = constantPool;
",0,False
"str = String.valueOf(((ConstantInteger) c).getBytes());
",0,False
"str = String.valueOf(((ConstantFloat) c).getBytes());
",0,False
"this.bytes = bytes;
",0,False
"return exceptionIndexTable;
",0,False
"return attributes;
",0,False
"return innerClasses;
",0,False
"return attributes;
",0,False
"this.fields = fields;
",0,False
"return interfaceNames;
",0,False
"this.lineNumberTable = lineNumberTable;
",0,False
"return parameterAnnotationEntries;
",0,False
"return exportsTable;
",0,False
"return classes;
",0,False
"return parameterAnnotationTable;
",0,False
"return null;
",0,False
"final ConstantString s = (ConstantString) c;
",0,False
"return addInteger(((ConstantInteger) c).getBytes());
",0,False
"return addLong(((ConstantLong) c).getBytes());
",0,False
"return new ArrayElementValueGen((ArrayElementValue) value, cpool,
",0,False
"return new INSTANCEOF(cp.addClass((ObjectType) t));
",0,False
"return new CHECKCAST(cp.addClass((ObjectType) t));
",0,False
"@Deprecated
protected List<JavaClass> vec = new ArrayList<>();",0,False
"wide = false; 
",0,False
private final boolean packFrame = false;,0,False
"public static final String[] ITEM_NAMES = { ""Bogus"", ""Integer"", ""Float"", ""Double"", ""Long"", ""Null"", ""InitObject"", ""Object"", ""NewObject"" };",0,True
"public static final short[] NO_OF_OPERANDS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, UNPREDICTABLE, UNPREDICTABLE, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 1, 2, 0, 0, 2, 2, 0, 0, UNPREDICTABLE, 3, 2, 2, 4, 4, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED, RESERVED };",0,False
"public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",0,True
"public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",0,False
"// TODO: mutable public array!!
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"" };",0,True
"str = constantToString(((ConstantNameAndType) c).getNameIndex(),
",0,False
"ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
",0,False
"i = ((ConstantClass) c).getNameIndex();
",0,False
"created++;
",0,False
"this.bytes = bytes;
",0,False
"return exception_index_table;
",0,False
"return attributes;
",0,False
"return inner_classes;
",0,False
"this.methods = methods;
",0,False
"return annotations;
",0,False
"if (debug) {
System.out.println(str);
}
}
",0,False
"return line_number_table;
",0,False
"int i = (l + r) / 2;
",0,False
"return parameter_annotation_table;
",0,False
"return null;
",0,False
"return addUtf8(((ConstantUtf8) c).getBytes());
",0,False
"return addFloat(((ConstantFloat) c).getBytes());
",0,False
"return new ClassElementValueGen((ClassElementValue) value, cpool,
",0,False
"return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
",0,False
"int m = match[(l + r) / 2];
",0,False
"return targets;
",0,False
private final InstructionHandle[] targets;,0,False
"_out = new PrintWriter(out);
",0,False
"constant_pool = java_class.getConstantPool();
",0,False
"PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + "".html""));
",0,False
"public static final String[] DEFAULT_IGNORED_PACKAGES = { ""java."", ""javax."", ""sun."" };",0,False
"index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
",0,False
"wide = false; 
",0,False
"contentPane = (JPanel) this.getContentPane();
",0,False
private final IvjEventHandler ivjEventHandler = new IvjEventHandler();,0,False
"objref = GENERIC_ARRAY;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"return null;
",0,False
"return null;
",0,False
"modulus = (++modulus) % 3;
",0,False
"return new String(encodeHex(array)).getBytes();
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (modulus) {
case 2 : 
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5 : 
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6 : 
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7 : 
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; 
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; 
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0,False
"switch(symb) {
case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
if (n == 0) {
code.append(symb);
}
break ; 
case 'B' :
if ( isPreviousChar(local, n, 'M') &&
isLastChar(wdsz, n) ) { 
break;
}
code.append(symb);
break;
case 'C' : 
if ( isPreviousChar(local, n, 'S') &&
!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) {
break;
}
if (regionMatch(local, n, ""CIA"")) { 
code.append('X');
break;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break; 
}
if (isPreviousChar(local, n, 'S') &&
isNextChar(local, n, 'H') ) { 
code.append('K') ;
break ;
}
if (isNextChar(local, n, 'H')) { 
if ((n == 0) &&
(wdsz >= 3) &&
isVowel(local,2) ) { 
code.append('K');
} else {
code.append('X'); 
}
} else {
code.append('K');
}
break ;
case 'D' :
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'G') &&
(FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { 
code.append('J'); n += 2 ;
} else {
code.append('T');
}
break ;
case 'G' : 
if (isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local,n,'H') &&
!isVowel(local,n+2)) {
break;
}
if ((n > 0) &&
( regionMatch(local, n, ""GN"") ||
regionMatch(local, n, ""GNED"") ) ) {
break; 
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true ;
} else {
hard = false ;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) &&
(!hard)) {
code.append('J');
} else {
code.append('K');
}
break ;
case 'H':
if (isLastChar(wdsz, n)) {
break ; 
}
if ((n > 0) &&
(VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local,n+1)) {
code.append('H'); 
}
break;
case 'F':
case 'J' :
case 'L' :
case 'M':
case 'N' :
case 'R' :
code.append(symb);
break;
case 'K' :
if (n > 0) { 
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb); 
}
break ;
case 'P' :
if (isNextChar(local,n,'H')) {
code.append('F');
} else {
code.append(symb);
}
break ;
case 'Q' :
code.append('K');
break;
case 'S' :
if (regionMatch(local,n,""SH"") ||
regionMatch(local,n,""SIO"") ||
regionMatch(local,n,""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T' :
if (regionMatch(local,n,""TIA"") ||
regionMatch(local,n,""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local,n,""TCH"")) {
break;
}
if (regionMatch(local,n,""TH"")) {
code.append('0');
} else {
code.append('T');
}
break ;
case 'V' :
code.append('F'); break ;
case 'W' : case 'Y' : 
if (!isLastChar(wdsz,n) &&
isVowel(local,n+1)) {
code.append(symb);
}
break ;
case 'X' :
code.append('K'); code.append('S');
break ;
case 'Z' :
code.append('S'); break ;
",0,False
"return null;
",0,False
"return null;
",0,False
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
",0,False
"return sha512(data.getBytes());
",0,True
protected static byte ESCAPE_CHAR = '%';,0,True
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0,False
"if (m == null || !m.find()) {
",0,True
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0,False
"} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
",0,False
"k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
",0,False
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0,True
"return null;
",0,False
"return null;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; 
buffer[pos++] = PAD;
",0,False
"return null;
",0,False
"validateTrailingCharacters();
case 2 : 
validateCharacter(MASK_2BITS, context);
",0,False
"return null;
",0,False
"switch (length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
",0,False
"h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
",0,False
"k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
",0,False
"switch (offset + length - index) {
case 3:
k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
case 1:
k1 ^= data[index];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
",0,False
"k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
",0,False
"k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
",0,False
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; 
buffer[pos++] = PAD;
",0,False
"switch(symb) {
case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
if (n == 0) {
code.append(symb);
}
break ; 
case 'B' :
if ( isPreviousChar(local, n, 'M') &&
isLastChar(wdsz, n) ) { 
break;
}
code.append(symb);
break;
case 'C' : 
if ( isPreviousChar(local, n, 'S') &&
!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) {
break;
}
if (regionMatch(local, n, ""CIA"")) { 
code.append('X');
break;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break; 
}
if (isPreviousChar(local, n, 'S') &&
isNextChar(local, n, 'H') ) { 
code.append('K') ;
break ;
}
if (isNextChar(local, n, 'H')) { 
if ((n == 0) &&
(wdsz >= 3) &&
isVowel(local,2) ) { 
code.append('K');
} else {
code.append('X'); 
}
} else {
code.append('K');
}
break ;
case 'D' :
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'G') &&
(FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { 
code.append('J'); n += 2 ;
} else {
code.append('T');
}
break ;
case 'G' : 
if (isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local,n,'H') &&
!isVowel(local,n+2)) {
break;
}
if ((n > 0) &&
( regionMatch(local, n, ""GN"") ||
regionMatch(local, n, ""GNED"") ) ) {
break; 
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true ;
} else {
hard = false ;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) &&
(!hard)) {
code.append('J');
} else {
code.append('K');
}
break ;
case 'H':
if (isLastChar(wdsz, n)) {
break ; 
}
if ((n > 0) &&
(VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local,n+1)) {
code.append('H'); 
}
break;
case 'F':
case 'J' :
case 'L' :
case 'M':
case 'N' :
case 'R' :
code.append(symb);
break;
case 'K' :
if (n > 0) { 
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb); 
}
break ;
case 'P' :
if (isNextChar(local,n,'H')) {
code.append('F');
} else {
code.append(symb);
}
break ;
case 'Q' :
code.append('K');
break;
case 'S' :
if (regionMatch(local,n,""SH"") ||
regionMatch(local,n,""SIO"") ||
regionMatch(local,n,""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T' :
if (regionMatch(local,n,""TIA"") ||
regionMatch(local,n,""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local,n,""TCH"")) {
break;
}
if (regionMatch(local,n,""TH"")) {
code.append('0');
} else {
code.append('T');
}
break ;
case 'V' :
code.append('F'); break ;
case 'W' : case 'Y' : 
if (!isLastChar(wdsz,n) &&
isVowel(local,n+1)) {
code.append(symb);
}
break ;
case 'X' :
code.append('K'); code.append('S');
break ;
case 'Z' :
code.append('S'); break ;
",0,False
"SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (modulus) {
case 1 :
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 :
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; 
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; 
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"switch(symb) {
case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
if (n == 0) {
code.append(symb);
}
break ; 
case 'B' :
if ( isPreviousChar(local, n, 'M') &&
isLastChar(wdsz, n) ) { 
break;
}
code.append(symb);
break;
case 'C' : 
if ( isPreviousChar(local, n, 'S') &&
!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) {
break;
}
if (regionMatch(local, n, ""CIA"")) { 
code.append('X');
break;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break; 
}
if (isPreviousChar(local, n, 'S') &&
isNextChar(local, n, 'H') ) { 
code.append('K') ;
break ;
}
if (isNextChar(local, n, 'H')) { 
if ((n == 0) &&
(wdsz >= 3) &&
isVowel(local,2) ) { 
code.append('K');
} else {
code.append('X'); 
}
} else {
code.append('K');
}
break ;
case 'D' :
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'G') &&
(FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { 
code.append('J'); n += 2 ;
} else {
code.append('T');
}
break ;
case 'G' : 
if (isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local,n,'H') &&
!isVowel(local,n+2)) {
break;
}
if ((n > 0) &&
( regionMatch(local, n, ""GN"") ||
regionMatch(local, n, ""GNED"") ) ) {
break; 
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true ;
} else {
hard = false ;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) &&
(!hard)) {
code.append('J');
} else {
code.append('K');
}
break ;
case 'H':
if (isLastChar(wdsz, n)) {
break ; 
}
if ((n > 0) &&
(VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local,n+1)) {
code.append('H'); 
}
break;
case 'F':
case 'J' :
case 'L' :
case 'M':
case 'N' :
case 'R' :
code.append(symb);
break;
case 'K' :
if (n > 0) { 
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb); 
}
break ;
case 'P' :
if (isNextChar(local,n,'H')) {
code.append('F');
} else {
code.append(symb);
}
break ;
case 'Q' :
code.append('K');
break;
case 'S' :
if (regionMatch(local,n,""SH"") ||
regionMatch(local,n,""SIO"") ||
regionMatch(local,n,""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T' :
if (regionMatch(local,n,""TIA"") ||
regionMatch(local,n,""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local,n,""TCH"")) {
break;
}
if (regionMatch(local,n,""TH"")) {
code.append('0');
} else {
code.append('T');
}
break ;
case 'V' :
code.append('F'); break ;
case 'W' : case 'Y' : 
if (!isLastChar(wdsz,n) &&
isVowel(local,n+1)) {
code.append(symb);
}
break ;
case 'X' :
code.append('K'); code.append('S');
break ;
case 'Z' :
code.append('S'); break ;
",0,False
"return null;
",0,False
"return null;
",0,False
"switch (offset + length - index) {
case 3:
k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
case 1:
k1 ^= (data[index] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
hash ^= k1;
",0,False
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0,False
"switch(len) {
case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
",0,False
"final SomeLanguages someLanguages = (SomeLanguages) other;
",0,False
"return null;
",0,False
"if (m == null || !m.find()) {
",0,True
"return null;
",0,False
"return null;
",0,False
"} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
",0,False
"return null;
",0,False
"return null;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"return null;
",0,False
"if (m == null || !m.find()) {
",0,True
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0,False
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"final SomeLanguages sl = (SomeLanguages) other;
",0,False
"return null;
",0,False
"switch (modulus) {
case 2 : 
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5 : 
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6 : 
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7 : 
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0,False
"switch(symb) {
case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
if (n == 0) {
code.append(symb);
}
break ; 
case 'B' :
if ( isPreviousChar(local, n, 'M') &&
isLastChar(wdsz, n) ) { 
break;
}
code.append(symb);
break;
case 'C' : 
if ( isPreviousChar(local, n, 'S') &&
!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) {
break;
}
if (regionMatch(local, n, ""CIA"")) { 
code.append('X');
break;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break; 
}
if (isPreviousChar(local, n, 'S') &&
isNextChar(local, n, 'H') ) { 
code.append('K') ;
break ;
}
if (isNextChar(local, n, 'H')) { 
if ((n == 0) &&
(wdsz >= 3) &&
isVowel(local,2) ) { 
code.append('K');
} else {
code.append('X'); 
}
} else {
code.append('K');
}
break ;
case 'D' :
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'G') &&
(FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { 
code.append('J'); n += 2 ;
} else {
code.append('T');
}
break ;
case 'G' : 
if (isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local,n,'H') &&
!isVowel(local,n+2)) {
break;
}
if ((n > 0) &&
( regionMatch(local, n, ""GN"") ||
regionMatch(local, n, ""GNED"") ) ) {
break; 
}
if (isPreviousChar(local, n, 'G')) {
// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
hard = true ;
} else {
hard = false ;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) &&
(!hard)) {
code.append('J');
} else {
code.append('K');
}
break ;
case 'H':
if (isLastChar(wdsz, n)) {
break ; 
}
if ((n > 0) &&
(VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local,n+1)) {
code.append('H'); 
}
break;
case 'F':
case 'J' :
case 'L' :
case 'M':
case 'N' :
case 'R' :
code.append(symb);
break;
case 'K' :
if (n > 0) { 
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb); 
}
break ;
case 'P' :
if (isNextChar(local,n,'H')) {
code.append('F');
} else {
code.append(symb);
}
break ;
case 'Q' :
code.append('K');
break;
case 'S' :
if (regionMatch(local,n,""SH"") ||
regionMatch(local,n,""SIO"") ||
regionMatch(local,n,""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T' :
if (regionMatch(local,n,""TIA"") ||
regionMatch(local,n,""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local,n,""TCH"")) {
break;
}
if (regionMatch(local,n,""TH"")) {
code.append('0');
} else {
code.append('T');
}
break ;
case 'V' :
code.append('F'); break ;
case 'W' : case 'Y' : 
if (!isLastChar(wdsz,n) &&
isVowel(local,n+1)) {
code.append(symb);
}
break ;
case 'X' :
code.append('K'); code.append('S');
break ;
case 'Z' :
code.append('S'); break ;
",0,False
"return null;
",0,False
protected final byte PAD = PAD_DEFAULT;,0,False
"if (m == null || !m.find()) {
",0,True
"return null;
",0,False
"return null;
",0,False
"final SomeLanguages someLanguages = (SomeLanguages) other;
",0,False
"switch (context.modulus) { 
case 1 : 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; 
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 2 : 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; 
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 3 : 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; 
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
break;
case 4 : 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; 
context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; 
context.buffer[context.pos++] = PAD;
",0,False
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1,True
protected static byte ESCAPE_CHAR = '%';,0,True
"return null;
",0,False
"} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
",1,False
private final byte ESCAPE_CHAR = '%';,1,True
"for (; salt.length() < 2; salt = salt + ""A"") {
",0,False
"final byte[] bytes = text.getBytes();
",1,True
"modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;
",1,True
"String text = input.toLowerCase(); // todo: locale?
",1,False
"byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
",1,False
"modulus = (++modulus) % BITS_PER_ENCODED_CHAR;
",0,True
"final byte[] bytes = data.getBytes();
",1,True
"modulus = (++modulus) % 4;
",1,False
".format(""%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, modulus=%s, pos=%s, readPos=%s]"",
",0,True
protected static byte ESCAPE_CHAR = '%';,1,True
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; 
buffer[pos++] = PAD;
",0,False
"return input.toUpperCase();
",1,False
"switch (unprocessedLength) {
case 3:
k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
case 1:
k1 ^= unprocessed[0];
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
",1,False
"left &= 0xffffffff;
",1,True
"if (base64String == null) { return null; }
",1,False
"final byte[] bytes = data.getBytes();
",1,True
"this.soundexMapping = mapping;
",1,False
"return sha(data.getBytes());
",1,True
"final SomeLanguages someLanguages = (SomeLanguages) other;
",0,False
"this.keys = keys;
",0,False
"map.size();  
",1,False
"buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
",0,False
private final Predicate<? super T> iPredicate1;,0,False
private final Predicate<? super T> iPredicate2;,0,False
"this.array = array;
",0,False
"return hash;
",0,False
"if (((ReferenceEntry<K, V>) entry).purge(ref)) {
",0,False
"delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
",0,False
"return null;
",0,False
"SynchronizedBagSet(final Set<E> set, final Object lock) {
super(set, lock);
}
",0,False
"final V value = last.getValue();
",0,False
"return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
",0,False
"return this.doEquals(obj, KEY);
",0,False
"class Bits {
private long[] data = new long[16];
private int size;
boolean add(long bits) {
if (size == data.length) {
data = Arrays.copyOf(data, size * 2);
}
data[size++] = bits;
return true;
}
long[] toArray() {
return size == data.length ? data : Arrays.copyOf(data, size);
",0,False
private final Predicate<? super E> predicate;,0,False
"protected final Transformer<? super E, ? extends E> transformer;",0,False
private final Comparator<O> decorated;,0,False
"return null;
",0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
"next = next.next();
",0,False
"total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
",0,False
protected final AbstractMapMultiSet<E> parent;,0,False
"return defaultValue;
",0,False
"private final Transformer<C, K> keyTransformer;",0,False
"return null;
",0,False
"private final Transformer<? super I, ? extends O> iDefault;",0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
"entry = entry.next();
",0,False
"if (((ReferenceEntry<K, V>) entry).purge(ref)) {
",0,False
"protected Node<K, V> next;",0,False
"return (Set<E>) super.decorated();
",0,False
"if (listSize < 0) {
",0,False
"return null;
",0,False
private final Predicate<? super T> iPredicate2;,0,False
private final Closure<? super E> iFalseClosure;,0,False
private final Predicate<? super T> iPredicate2;,0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"return hash;
",0,False
"entry = entry.next();
",0,False
"protected Node<K, V> next;",0,False
"return (Set<E>) super.decorated();
",0,False
"return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
",0,False
"return this.doEquals(obj, KEY);
",0,False
"private final Transformer<C, K> keyTransformer;",0,False
"return null;
",0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
"return hash;
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"List<V> valueList = (List<V>) entry.getValue();
",0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"return null;
",0,False
private final Comparator<O> decorated;,0,False
private final Closure<? super E> iFalseClosure;,0,False
private final Predicate<? super T> iPredicate;,0,False
"return (List<E>) super.decorated();
",0,False
"private final Transformer<Integer, ? extends E> transformer;",0,False
"moveToMRU((LinkEntry<K, V>) entry);  
",0,False
"final ArrayList<V> list = (ArrayList<V>) coll;
",0,False
"return (Set<E>) super.decorated();
",0,False
"private UnmodifiableBidiMap<V, K> inverse;",0,False
private final Comparator<? super E> nonNullComparator;,0,False
"private final Transformer<? super I, ? extends O> transformer;",0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
"private final Transformer<? super I, ? extends O> iTrueTransformer;",0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
private final Factory<? extends E> factory;,0,False
"return hash;
",0,False
"total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
",0,False
"moveToMRU((LinkEntry<K, V>) entry);  
",0,False
"private final Transformer<? super K, ? extends K> keyTransformer;",0,False
"return (Set<E>) super.decorated();
",0,False
"return (SortedSet<E>) decorated();
",0,False
"return this.doEquals(obj, KEY);
",0,False
"private final Transformer<C, K> keyTransformer;",0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
"private final Transformer<? super E, ?> iTransformer;",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = (List<V>) getMapping();
",0,False
"return (UnmodifiableMultiValuedMap<K, V>) map;
",0,False
"return null;
",0,False
"private UnmodifiableBidiMap<V, K> inverse;",0,False
"return null;
",0,False
private transient Method iCloneMethod;,0,False
"private final Transformer<? super T, ? extends T> iTransformer;",0,False
"return this.array;
",0,False
"this.keys = keys;
",0,False
"if (((ReferenceEntry<K, V>) entry).purge(ref)) {
",0,False
"return hash;
",0,False
protected K key;,0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"return (UnmodifiableMultiValuedMap<K, V>) map;
",0,False
"SynchronizedBagSet(final Set<E> set, final Object lock) {
super(set, lock);
}
",0,False
"return this.doEquals(obj, KEY);
",0,False
"private final Transformer<? super T, ? extends T>[] iTransformers;",0,False
"this.array = array;
",0,False
"entry = entry.next();
",0,False
"V currentValue, nextValue;",0,False
"List<V> list = (List<V>) getMapping();
",0,False
"List<V> list = (List<V>) getMapping();
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0,False
"final List<V> list = (List<V>) getMapping();
",0,False
private transient KeysBag keysBagView;,0,False
"Set<V> valueSet = (Set<V>) entry.getValue();
",0,False
"final Set<V> set = (Set<V>) getMapping();
",0,False
"return this.doEquals(obj, KEY);
",0,False
"return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
",0,False
private final Comparator<T> comparator;,0,False
"return null;
",0,False
private transient Method iCloneMethod;,0,False
"private final Transformer<? super T, Boolean> iTransformer;",0,False
"return this.array;
",0,False
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0,False
"V currentValue, nextValue;",0,False
"file = new File(fileName);
",0,False
"value = array.length == 0 ? null : new Byte(array[0]);
",1,False
private XMLBuilderParametersImpl currentXMLParameters;,0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0,False
"return new Float(n.floatValue());
",1,False
"getConfiguration().addProperty(name, new Long(array[i]));
",1,True
"catch (Exception e)
",0,False
"file = new File(fileName);
",1,False
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_BEGIN:
case DICT_BEGIN:
case DATA:
case STRING:
case QUOTED_STRING:
element = Element();
list.add(element);
label_2:
while (true)
{
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(ARRAY_SEPARATOR);
element = Element();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
return list;
",0,False
"pstmt = conn.prepareStatement(query.toString());
",1,False
"getConfiguration().addProperty(name, new Integer(array[i]));
",1,True
"catch (Exception ex)
",1,False
"} catch (final Exception e) {
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,1,False
"throw new IllegalArgumentException(""No such property name=["" + name + ""]"");
",1,False
"return count % 2 == 1;
",1,False
"token = jj_consume_token(DATA);
return filterData(token.image);
",0,False
"initProperty(bean, propName, properties.get(propName));
",1,False
"getConfiguration().addProperty(name, new Character(array[i]));
",1,False
private CombinedBuilderParametersImpl currentParameters;,0,False
"if (configs != null)
",0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"catch (Exception ex)
",1,False
"List lst = (List) namedNodes.get(node.getName());
",1,False
"catch (Exception ex)
",0,False
"ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
private AutoSaveListener autoSaveListener;,0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
"return new Float(n.floatValue());
",0,False
"catch (Exception ex)
",0,False
private final String protocol;,0,False
private final QueryResult<T> attributeResult;,0,False
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0,False
"return getShort(key, new Short(defaultValue)).shortValue();
",0,False
"getLogger().debug(os.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, CombinedConfiguration> configs =
new ConcurrentHashMap<String, CombinedConfiguration>();
private List<ConfigData> configurations = new ArrayList<ConfigData>();
private Map<String, AbstractConfiguration> namedConfigurations =
new HashMap<String, AbstractConfiguration>();
private String keyPattern;
private NodeCombiner nodeCombiner;
private String loggerName = DynamicCombinedConfiguration.class.getName();
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public DynamicCombinedConfiguration(NodeCombiner comb)
{
super();
setNodeCombiner(comb);
setIgnoreReloadExceptions(false);
setLogger(LogFactory.getLog(DynamicCombinedConfiguration.class));
}
public DynamicCombinedConfiguration()
{
super();
setIgnoreReloadExceptions(false);
setLogger(LogFactory.getLog(DynamicCombinedConfiguration.class));
}
public void setKeyPattern(String pattern)
{
this.keyPattern = pattern;
}
public String getKeyPattern()
{
return this.keyPattern;
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
@Override
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
@Override
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidateAll();
}
@Override
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
}
@Override
public int getNumberOfConfigurations()
{
return configurations.size();
}
@Override
public Configuration getConfiguration(int index)
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
@Override
public Configuration getConfiguration(String name)
{
return namedConfigurations.get(name);
}
@Override
public Set<String> getConfigurationNames()
{
return namedConfigurations.keySet();
}
@Override
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
@Override
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
}
}
return super.removeConfiguration(config);
}
@Override
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
return super.removeConfigurationAt(index);
}
@Override
public ConfigurationNode getRootNode()
{
return getCurrentConfig().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (configs != null)
{
this.getCurrentConfig().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public void addProperty(String key, Object value)
{
this.getCurrentConfig().addProperty(key, value);
}
@Override
public void clear()
{
if (configs != null)
{
this.getCurrentConfig().clear();
}
}
@Override
public void clearProperty(String key)
{
this.getCurrentConfig().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getCurrentConfig().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getCurrentConfig().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getCurrentConfig().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getCurrentConfig().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getCurrentConfig().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getCurrentConfig().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getCurrentConfig().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getCurrentConfig().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getCurrentConfig().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getCurrentConfig().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getCurrentConfig().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getCurrentConfig().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getCurrentConfig().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getCurrentConfig().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getCurrentConfig().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getCurrentConfig().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getCurrentConfig().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getCurrentConfig().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getCurrentConfig().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getCurrentConfig().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getCurrentConfig().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getCurrentConfig().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<?> defaultValue)
{
return this.getCurrentConfig().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getCurrentConfig().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getCurrentConfig().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getCurrentConfig().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getCurrentConfig().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getCurrentConfig().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getCurrentConfig().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getCurrentConfig().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getCurrentConfig().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getCurrentConfig().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getCurrentConfig().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getCurrentConfig().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getCurrentConfig().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getCurrentConfig().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (configs != null)
{
this.getCurrentConfig().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getCurrentConfig().subset(prefix);
}
@Override
public Node getRoot()
{
return this.getCurrentConfig().getRoot();
}
@Override
public void setRoot(Node node)
{
if (configs != null)
{
this.getCurrentConfig().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getCurrentConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getCurrentConfig().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getCurrentConfig().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getCurrentConfig().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getCurrentConfig().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getCurrentConfig().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getCurrentConfig().interpolatedConfiguration();
}
@Override
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
return getCurrentConfig().getSource(key);
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
for (CombinedConfiguration cc : configs.values())
{
cc.addConfigurationListener(l);
}
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
for (CombinedConfiguration cc : configs.values())
{
cc.removeConfigurationListener(l);
}
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
for (CombinedConfiguration cc : configs.values())
{
cc.clearConfigurationListeners();
}
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
for (CombinedConfiguration cc : configs.values())
{
cc.addErrorListener(l);
}
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
for (CombinedConfiguration cc : configs.values())
{
cc.removeErrorListener(l);
}
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
for (CombinedConfiguration cc : configs.values())
{
cc.clearErrorListeners();
}
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
@Override
public Object clone()
{
return super.clone();
}
@Override
public void invalidate()
{
getCurrentConfig().invalidate();
}
public void invalidateAll()
{
if (configs == null)
{
return;
}
for (CombinedConfiguration cc : configs.values())
{
cc.invalidate();
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
private CombinedConfiguration getCurrentConfig()
{
String key = localSubst.replace(keyPattern);
CombinedConfiguration config = configs.get(key);
if (config == null)
{
synchronized (configs)
{
config = configs.get(key);
if (config == null)
{
config = new CombinedConfiguration(getNodeCombiner());
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
config.setLogger(log);
}
}
config.setIgnoreReloadExceptions(isIgnoreReloadExceptions());
config.setExpressionEngine(this.getExpressionEngine());
config.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
config.setConversionExpressionEngine(getConversionExpressionEngine());
config.setListDelimiter(getListDelimiter());
for (ConfigurationErrorListener listener : getErrorListeners())
{
config.addErrorListener(listener);
}
for (ConfigurationListener listener : getConfigurationListeners())
{
config.addConfigurationListener(listener);
}
config.setForceReloadCheck(isForceReloadCheck());
for (ConfigData data : configurations)
{
config.addConfiguration(data.getConfiguration(), data.getName(), data.getAt());
}
configs.put(key, config);
}
}
}
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Returning config for "" + key + "": "" + config);
}
return config;
",0,False
"synchronized (counterLock)
",0,False
"{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
",0,False
"return new Integer(n.intValue());
",0,False
"catch (Exception ex)
",0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"List<ConfigurationNode> lst = namedNodes.get(node.getName());
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"final PrintStream stream = new PrintStream(os);
",0,False
"return dataSource;
",0,False
"} catch (final Exception e) {
",0,False
"return src != null ? src.clone() : null;
",0,False
"return new ConfigurationNodePointer<>((ConfigurationNodePointer<Object>) parent, wrapper.getNode(), wrapper.getNodeHandler());
",0,False
"public class CombinedConfiguration extends HierarchicalReloadableConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, AbstractConfiguration> namedConfigurations;
private boolean ignoreReloadExceptions = true;
private boolean reloadRequired;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(NodeCombiner comb, Lock lock)
{
super(lock);
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(Lock lock)
{
this(null, lock);
}
public CombinedConfiguration()
{
this(null, null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Adding configuration "" + config + "" with name "" + name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return namedConfigurations.get(name);
}
public List<AbstractConfiguration> getConfigurations()
{
List<AbstractConfiguration> list = new ArrayList<AbstractConfiguration>(configurations.size());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
public List<String> getConfigurationNameList()
{
List<String> list = new ArrayList<String>(configurations.size());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
reloadRequired = true;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
@Override
public ConfigurationNode getRootNode()
{
synchronized (getReloadLock())
{
if (reloadRequired || combinedRoot == null)
{
combinedRoot = constructCombinedNode();
reloadRequired = false;
}
return combinedRoot;
}
}
@Override
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, AbstractConfiguration>();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
@Override
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (ConfigData cd : configurations)
{
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List<ConfigurationNode> nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator<ConfigurationNode> it = nodes.iterator();
Configuration source = findSourceConfiguration(it.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration(it.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
@Override
protected List<ConfigurationNode> fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
synchronized (getReloadLock())
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
}
return this;
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"private Map<String, ConfigurationProvider> providers;",0,False
"return new Short(n.shortValue());
",0,False
"return new Long(n.longValue());
",0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"if (name == null)
",0,False
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0,False
"result = namedNodes.get(name);
",0,False
"List<ConfigurationNode> lst = namedNodes.get(node.getName());
",0,False
"writer = new OutputStreamWriter(out);
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"parent.mkdirs();
",0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"if (configs != null)
",0,False
private ConfigurationNode rootNode;,0,False
"return new Double(n.doubleValue());
",0,False
"return new Byte(n.byteValue());
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"{
super(name);
setReference(elem);
}
@Override
public void setValue(Object value)
{
super.setValue(value);
if (getReference() != null && document != null)
{
if (isAttribute())
{
updateAttribute();
}
else
{
updateElement(value);
}
}
}
@Override
protected void removeReference()
{
if (getReference() != null)
{
Element element = (Element) getReference();
if (isAttribute())
{
updateAttribute();
}
else
{
org.w3c.dom.Node parentElem = element.getParentNode();
if (parentElem != null)
{
parentElem.removeChild(element);
}
}
}
}
private void updateElement(Object value)
{
Text txtNode = findTextNodeForUpdate();
if (value == null)
{
if (txtNode != null)
{
((Element) getReference()).removeChild(txtNode);
}
}
else
{
if (txtNode == null)
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode = document.createTextNode(newValue);
if (((Element) getReference()).getFirstChild() != null)
{
((Element) getReference()).insertBefore(txtNode,
((Element) getReference()).getFirstChild());
}
else
{
((Element) getReference()).appendChild(txtNode);
}
}
else
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode.setNodeValue(newValue);
}
}
}
private void updateAttribute()
{
XMLBuilderVisitor.updateAttribute(getParent(), getName(), getListDelimiter(),
isAttributeSplittingDisabled());
}
private Text findTextNodeForUpdate()
{
Text result = null;
Element elem = (Element) getReference();
NodeList children = elem.getChildNodes();
Collection<org.w3c.dom.Node> textNodes = new ArrayList<org.w3c.dom.Node>();
for (int i = 0; i < children.getLength(); i++)
{
org.w3c.dom.Node nd = children.item(i);
if (nd instanceof Text)
{
if (result == null)
{
result = (Text) nd;
}
else
{
textNodes.add(nd);
}
}
}
if (result instanceof CDATASection)
{
textNodes.add(result);
result = null;
}
for (org.w3c.dom.Node tn : textNodes)
{
elem.removeChild(tn);
}
return result;
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"List<ConfigurationNode> lst = namedNodes.get(node.getName());
",0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"catch (Exception e)
",0,False
private final ImmutableConfiguration configuration;,0,False
private AutoSaveListener autoSaveListener;,0,False
private ReloadingController reloadingController;,0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
private final QueryResult<T> attributeResult;,0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0,False
"reader = new InputStreamReader(in);
",0,False
"public class CombinedConfiguration extends HierarchicalReloadableConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private boolean ignoreReloadExceptions = true;
private boolean reloadRequired = false;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(NodeCombiner comb, Lock lock)
{
super(lock);
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(Lock lock)
{
this(null, lock);
}
public CombinedConfiguration()
{
this(null, null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Adding configuration "" + config + "" with name "" + name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public List getConfigurations()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getConfiguration());
}
return list;
}
public List getConfigurationNameList()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
reloadRequired = true;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
public ConfigurationNode getRootNode()
{
synchronized(getReloadLock())
{
if (reloadRequired || combinedRoot == null)
{
combinedRoot = constructCombinedNode();
reloadRequired = false;
}
return combinedRoot;
}
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator it = nodes.iterator();
Configuration source = findSourceConfiguration((ConfigurationNode) it
.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration((ConfigurationNode) it
.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected List fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
synchronized(getReloadLock())
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
}
return this;
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
protected Configuration configuration;,0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"private static ThreadLocal recursive = new ThreadLocal()
{
protected synchronized Object initialValue()
{
return Boolean.FALSE;
}
};
private Map configs = new HashMap();
private List configurations = new ArrayList();
private Map namedConfigurations = new HashMap();
private String keyPattern;
private NodeCombiner nodeCombiner;
private String loggerName = DynamicCombinedConfiguration.class.getName();
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public DynamicCombinedConfiguration(NodeCombiner comb)
{
super();
setNodeCombiner(comb);
setIgnoreReloadExceptions(false);
setLogger(LogFactory.getLog(DynamicCombinedConfiguration.class));
}
public DynamicCombinedConfiguration()
{
super();
setIgnoreReloadExceptions(false);
setLogger(LogFactory.getLog(DynamicCombinedConfiguration.class));
}
public void setKeyPattern(String pattern)
{
this.keyPattern = pattern;
}
public String getKeyPattern()
{
return this.keyPattern;
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidateAll();
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
}
}
return super.removeConfiguration(config);
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
return super.removeConfigurationAt(index);
}
public ConfigurationNode getRootNode()
{
return getCurrentConfig().getRootNode();
}
public void setRootNode(ConfigurationNode rootNode)
{
if (configs != null)
{
this.getCurrentConfig().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
public void addProperty(String key, Object value)
{
this.getCurrentConfig().addProperty(key, value);
}
public void clear()
{
if (configs != null)
{
this.getCurrentConfig().clear();
}
}
public void clearProperty(String key)
{
this.getCurrentConfig().clearProperty(key);
}
public boolean containsKey(String key)
{
return this.getCurrentConfig().containsKey(key);
}
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getCurrentConfig().getBigDecimal(key, defaultValue);
}
public BigDecimal getBigDecimal(String key)
{
return this.getCurrentConfig().getBigDecimal(key);
}
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getCurrentConfig().getBigInteger(key, defaultValue);
}
public BigInteger getBigInteger(String key)
{
return this.getCurrentConfig().getBigInteger(key);
}
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getCurrentConfig().getBoolean(key, defaultValue);
}
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getCurrentConfig().getBoolean(key, defaultValue);
}
public boolean getBoolean(String key)
{
return this.getCurrentConfig().getBoolean(key);
}
public byte getByte(String key, byte defaultValue)
{
return this.getCurrentConfig().getByte(key, defaultValue);
}
public Byte getByte(String key, Byte defaultValue)
{
return this.getCurrentConfig().getByte(key, defaultValue);
}
public byte getByte(String key)
{
return this.getCurrentConfig().getByte(key);
}
public double getDouble(String key, double defaultValue)
{
return this.getCurrentConfig().getDouble(key, defaultValue);
}
public Double getDouble(String key, Double defaultValue)
{
return this.getCurrentConfig().getDouble(key, defaultValue);
}
public double getDouble(String key)
{
return this.getCurrentConfig().getDouble(key);
}
public float getFloat(String key, float defaultValue)
{
return this.getCurrentConfig().getFloat(key, defaultValue);
}
public Float getFloat(String key, Float defaultValue)
{
return this.getCurrentConfig().getFloat(key, defaultValue);
}
public float getFloat(String key)
{
return this.getCurrentConfig().getFloat(key);
}
public int getInt(String key, int defaultValue)
{
return this.getCurrentConfig().getInt(key, defaultValue);
}
public int getInt(String key)
{
return this.getCurrentConfig().getInt(key);
}
public Integer getInteger(String key, Integer defaultValue)
{
return this.getCurrentConfig().getInteger(key, defaultValue);
}
public Iterator getKeys()
{
return this.getCurrentConfig().getKeys();
}
public Iterator getKeys(String prefix)
{
return this.getCurrentConfig().getKeys(prefix);
}
public List getList(String key, List defaultValue)
{
return this.getCurrentConfig().getList(key, defaultValue);
}
public List getList(String key)
{
return this.getCurrentConfig().getList(key);
}
public long getLong(String key, long defaultValue)
{
return this.getCurrentConfig().getLong(key, defaultValue);
}
public Long getLong(String key, Long defaultValue)
{
return this.getCurrentConfig().getLong(key, defaultValue);
}
public long getLong(String key)
{
return this.getCurrentConfig().getLong(key);
}
public Properties getProperties(String key)
{
return this.getCurrentConfig().getProperties(key);
}
public Object getProperty(String key)
{
return this.getCurrentConfig().getProperty(key);
}
public short getShort(String key, short defaultValue)
{
return this.getCurrentConfig().getShort(key, defaultValue);
}
public Short getShort(String key, Short defaultValue)
{
return this.getCurrentConfig().getShort(key, defaultValue);
}
public short getShort(String key)
{
return this.getCurrentConfig().getShort(key);
}
public String getString(String key, String defaultValue)
{
return this.getCurrentConfig().getString(key, defaultValue);
}
public String getString(String key)
{
return this.getCurrentConfig().getString(key);
}
public String[] getStringArray(String key)
{
return this.getCurrentConfig().getStringArray(key);
}
public boolean isEmpty()
{
return this.getCurrentConfig().isEmpty();
}
public void setProperty(String key, Object value)
{
if (configs != null)
{
this.getCurrentConfig().setProperty(key, value);
}
}
public Configuration subset(String prefix)
{
return this.getCurrentConfig().subset(prefix);
}
public Node getRoot()
{
return this.getCurrentConfig().getRoot();
}
public void setRoot(Node node)
{
if (configs != null)
{
this.getCurrentConfig().setRoot(node);
}
else
{
super.setRoot(node);
}
}
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
public void addNodes(String key, Collection nodes)
{
this.getCurrentConfig().addNodes(key, nodes);
}
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getCurrentConfig().configurationAt(key, supportUpdates);
}
public SubnodeConfiguration configurationAt(String key)
{
return this.getCurrentConfig().configurationAt(key);
}
public List configurationsAt(String key)
{
return this.getCurrentConfig().configurationsAt(key);
}
public void clearTree(String key)
{
this.getCurrentConfig().clearTree(key);
}
public int getMaxIndex(String key)
{
return this.getCurrentConfig().getMaxIndex(key);
}
public Configuration interpolatedConfiguration()
{
return this.getCurrentConfig().interpolatedConfiguration();
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
return getCurrentConfig().getSource(key);
}
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
Iterator iter = configs.values().iterator();
while (iter.hasNext())
{
CombinedConfiguration config = (CombinedConfiguration) iter.next();
config.addConfigurationListener(l);
}
}
public boolean removeConfigurationListener(ConfigurationListener l)
{
Iterator iter = configs.values().iterator();
while (iter.hasNext())
{
CombinedConfiguration config = (CombinedConfiguration) iter.next();
config.removeConfigurationListener(l);
}
return super.removeConfigurationListener(l);
}
public Collection getConfigurationListeners()
{
return super.getConfigurationListeners();
}
public void clearConfigurationListeners()
{
Iterator iter = configs.values().iterator();
while (iter.hasNext())
{
CombinedConfiguration config = (CombinedConfiguration) iter.next();
config.clearConfigurationListeners();
}
super.clearConfigurationListeners();
}
public void addErrorListener(ConfigurationErrorListener l)
{
Iterator iter = configs.values().iterator();
while (iter.hasNext())
{
CombinedConfiguration config = (CombinedConfiguration) iter.next();
config.addErrorListener(l);
}
super.addErrorListener(l);
}
public boolean removeErrorListener(ConfigurationErrorListener l)
{
Iterator iter = configs.values().iterator();
while (iter.hasNext())
{
CombinedConfiguration config = (CombinedConfiguration) iter.next();
config.removeErrorListener(l);
}
return super.removeErrorListener(l);
}
public void clearErrorListeners()
{
Iterator iter = configs.values().iterator();
while (iter.hasNext())
{
CombinedConfiguration config = (CombinedConfiguration) iter.next();
config.clearErrorListeners();
}
super.clearErrorListeners();
}
public Collection getErrorListeners()
{
return super.getErrorListeners();
}
public Object clone()
{
return super.clone();
}
public void invalidate()
{
getCurrentConfig().invalidate();
}
public void invalidateAll()
{
if (configs == null)
{
return;
}
Iterator iter = configs.values().iterator();
while (iter.hasNext())
{
CombinedConfiguration config = (CombinedConfiguration) iter.next();
config.invalidate();
}
}
protected Object resolveContainerStore(String key)
{
if (((Boolean) recursive.get()).booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
private CombinedConfiguration getCurrentConfig()
{
String key = localSubst.replace(keyPattern);
CombinedConfiguration config;
synchronized (getNodeCombiner())
{
config = (CombinedConfiguration) configs.get(key);
if (config == null)
{
config = new CombinedConfiguration(getNodeCombiner());
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
config.setLogger(log);
}
}
config.setIgnoreReloadExceptions(isIgnoreReloadExceptions());
config.setExpressionEngine(this.getExpressionEngine());
config.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
config.setConversionExpressionEngine(getConversionExpressionEngine());
config.setListDelimiter(getListDelimiter());
Iterator iter = getErrorListeners().iterator();
while (iter.hasNext())
{
ConfigurationErrorListener listener = (ConfigurationErrorListener) iter.next();
config.addErrorListener(listener);
}
iter = getConfigurationListeners().iterator();
while (iter.hasNext())
{
ConfigurationListener listener = (ConfigurationListener) iter.next();
config.addConfigurationListener(listener);
}
config.setForceReloadCheck(isForceReloadCheck());
iter = configurations.iterator();
while (iter.hasNext())
{
ConfigData data = (ConfigData) iter.next();
config.addConfiguration(data.getConfiguration(), data.getName(),
data.getAt());
}
configs.put(key, config);
}
}
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Returning config for "" + key + "": "" + config);
}
return config;
",0,False
"super();
reloadLock = new Lock(LOCK_NAME);
}
public HierarchicalReloadableConfiguration(Object lock)
{
super();
reloadLock = lock == null ? new Lock(LOCK_NAME) : lock;
}
public HierarchicalReloadableConfiguration(HierarchicalConfiguration c)
{
super(c);
reloadLock = new Lock(LOCK_NAME);
}
public Object getReloadLock()
{
return reloadLock;
",0,False
"catch (Exception ex)
",0,False
"private static ThreadLocal recursive = new ThreadLocal()
{
protected synchronized Object initialValue()
{
return Boolean.FALSE;
}
};
private final AbstractHierarchicalFileConfiguration config;
private final String path;
private final boolean trailing;
private boolean init;
public PatternSubtreeConfigurationWrapper(AbstractHierarchicalFileConfiguration config, String path)
{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
public Object getReloadLock()
{
return config.getReloadLock();
}
public void addProperty(String key, Object value)
{
config.addProperty(makePath(key), value);
}
public void clear()
{
getConfig().clear();
}
public void clearProperty(String key)
{
config.clearProperty(makePath(key));
}
public boolean containsKey(String key)
{
return config.containsKey(makePath(key));
}
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
public int getInt(String key)
{
return config.getInt(makePath(key));
}
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
public Iterator getKeys()
{
return config.getKeys(makePath());
}
public Iterator getKeys(String prefix)
{
return config.getKeys(makePath(prefix));
}
public List getList(String key, List defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
public List getList(String key)
{
return config.getList(makePath(key));
}
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
public long getLong(String key)
{
return config.getLong(makePath(key));
}
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
public Object getProperty(String key)
{
return config.getProperty(makePath(key));
}
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
public short getShort(String key)
{
return config.getShort(makePath(key));
}
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
public String getString(String key)
{
return config.getString(makePath(key));
}
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
public boolean isEmpty()
{
return getConfig().isEmpty();
}
public void setProperty(String key, Object value)
{
getConfig().setProperty(key, value);
}
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
public Node getRoot()
{
return getConfig().getRoot();
}
public void setRoot(Node node)
{
if (init)
{
getConfig().setRoot(node);
}
else
{
super.setRoot(node);
}
}
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
public void addNodes(String key, Collection nodes)
{
getConfig().addNodes(key, nodes);
}
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
public List configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
public void clearTree(String key)
{
config.clearTree(makePath(key));
}
public int getMaxIndex(String key)
{
return config.getMaxIndex(makePath(key));
}
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
public Collection getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
config.save(writer);
}
public void load(Reader reader) throws ConfigurationException
{
config.load(reader);
}
public Collection getErrorListeners()
{
return getConfig().getErrorListeners();
}
protected Object resolveContainerStore(String key)
{
if (((Boolean) recursive.get()).booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
private HierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return getSubstitutor().replace(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return getSubstitutor().replace(pathPattern) + item;
",0,False
private final String protocol;,0,False
"switch (i) {
case 0: jj_3_1(); break;
",0,False
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_BEGIN:
case DICT_BEGIN:
case DATA:
case DATE:
case STRING:
case QUOTED_STRING:
element = Element();
list.add(element);
label_2:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(ARRAY_SEPARATOR);
element = Element();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
{if (true) return list;}
",0,False
"Object value = null;
if (jj_2_1(2)) {
value = Array();
{if (true) return value;}
} else {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_BEGIN:
value = Dictionary();
{if (true) return value;}
break;
case STRING:
case QUOTED_STRING:
value = String();
{if (true) return value;}
break;
case DATA:
value = Data();
{if (true) return value;}
break;
case DATE:
value = Date();
{if (true) return value;}
break;
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"char[] ret = new char[len];
if ((bufpos + 1) >= len)
System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
else
{
System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
len - bufpos - 1);
System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
}
return ret;
",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"result = (List) namedNodes.get(name);
",0,False
private ConfigurationNode node;,0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"writer = new OutputStreamWriter(out);
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"if (file != null && file.exists())
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"return new Byte(n.byteValue());
",0,False
"return new Integer(n.intValue());
",0,False
"return new Double(n.doubleValue());
",0,False
"catch (Exception e)
",0,False
"initProperty(bean, propName, properties.get(propName));
",0,False
"token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration)
{
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
{if (true) return configuration;}
",0,False
"Object value = null;
if (jj_2_1(2)) {
value = Array();
{if (true) return value;}
} else {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_BEGIN:
value = Dictionary();
{if (true) return value;}
break;
case STRING:
case QUOTED_STRING:
value = String();
{if (true) return value;}
break;
case DATA:
value = Data();
{if (true) return value;}
break;
case DATE:
value = Date();
{if (true) return value;}
break;
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"return null;
",0,False
"jjstateSet[jjnewStateCnt++] = jjnextStates[start];
}
while (start++ != end);
}
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"char[] ret = new char[len];
if ((bufpos + 1) >= len)
System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
else
{
System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
len - bufpos - 1);
System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
}
return ret;
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (8 - (column & 07));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0,False
"addValue(new Integer(value));
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"addValue(format.parse(value));
",0,False
"List lst = (List) namedNodes.remove(name);
",0,False
".get(positionToIndex(getPosition())));
",0,False
"return getFloat(key, new Float(defaultValue)).floatValue();
",0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"getLogger().debug(os.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
private final Object reloadLock;,0,False
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<SubnodeConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"catch (Exception e)
",0,False
"if (name == null)
",0,False
private ConfigurationNode node;,0,False
private final ConversionHandler dataConversionHandler;,0,False
private NodeCombiner nodeCombiner;,0,False
"switch (event.getType())
{
case AbstractConfiguration.EVENT_ADD_PROPERTY:
boolean contained = layoutData.containsKey(event
.getPropertyName());
PropertyLayoutData data = fetchLayoutData(event
.getPropertyName());
data.setSingleLine(!contained);
break;
case AbstractConfiguration.EVENT_CLEAR_PROPERTY:
layoutData.remove(event.getPropertyName());
break;
case AbstractConfiguration.EVENT_CLEAR:
clear();
break;
case AbstractConfiguration.EVENT_SET_PROPERTY:
fetchLayoutData(event.getPropertyName());
",0,False
"catch (Exception ex)
",0,False
private ConfigurationSourceData sourceData;,0,False
private ReloadingController reloadingController;,0,False
"return new Integer(n.intValue());
",0,False
"catch (Exception e)
",0,False
"return new Long(n.longValue());
",0,False
"parent.mkdirs();
",0,False
"catch (Exception ex)
",0,False
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
"List<ConfigurationNode> lst = namedNodes.get(node.getName());
",0,False
private ConfigurationNode node;,0,False
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"catch (Exception ex)
",0,False
"return new Double(n.doubleValue());
",0,False
"catch (Exception ex)
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"getLogger().debug(os.toString());
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"if (init)
",0,False
"if (init)
",0,False
private final String protocol;,0,False
"{
super(name);
setReference(elem);
}
public void setValue(Object value)
{
super.setValue(value);
if (getReference() != null && document != null)
{
if (isAttribute())
{
updateAttribute();
}
else
{
updateElement(value);
}
}
}
protected void removeReference()
{
if (getReference() != null)
{
Element element = (Element) getReference();
if (isAttribute())
{
updateAttribute();
}
else
{
org.w3c.dom.Node parentElem = element.getParentNode();
if (parentElem != null)
{
parentElem.removeChild(element);
}
}
}
}
private void updateElement(Object value)
{
Text txtNode = findTextNodeForUpdate();
if (value == null)
{
if (txtNode != null)
{
((Element) getReference()).removeChild(txtNode);
}
}
else
{
if (txtNode == null)
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode = document.createTextNode(newValue);
if (((Element) getReference()).getFirstChild() != null)
{
((Element) getReference()).insertBefore(txtNode,
((Element) getReference()).getFirstChild());
}
else
{
((Element) getReference()).appendChild(txtNode);
}
}
else
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode.setNodeValue(newValue);
}
}
}
private void updateAttribute()
{
XMLBuilderVisitor.updateAttribute(getParent(), getName(), getListDelimiter(),
isAttributeSplittingDisabled());
}
private Text findTextNodeForUpdate()
{
Text result = null;
Element elem = (Element) getReference();
NodeList children = elem.getChildNodes();
Collection textNodes = new ArrayList();
for (int i = 0; i < children.getLength(); i++)
{
org.w3c.dom.Node nd = children.item(i);
if (nd instanceof Text)
{
if (result == null)
{
result = (Text) nd;
}
else
{
textNodes.add(nd);
}
}
}
if (result instanceof CDATASection)
{
textNodes.add(result);
result = null;
}
for (Iterator it = textNodes.iterator(); it.hasNext();)
{
elem.removeChild((org.w3c.dom.Node) it.next());
}
return result;
",0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"catch (Exception ex)
",0,False
"public static class Variables extends ArrayList
{
public Variable getVariable()
{
if (size() > 0)
{
return (Variable) get(size() - 1);
}
else
{
return null;
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"staticCatalog = catalog;
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"private Map<String, ConfigurationProvider> providers;",0,False
"catch (Exception e)
",0,False
"parent.mkdirs();
",0,False
private final Object reloadLock;,0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final AbstractHierarchicalFileConfiguration config;
private final String path;
private final boolean trailing;
private boolean init;
public PatternSubtreeConfigurationWrapper(AbstractHierarchicalFileConfiguration config, String path)
{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
@Override
public Object getReloadLock()
{
return config.getReloadLock();
}
@Override
public void addProperty(String key, Object value)
{
config.addProperty(makePath(key), value);
}
@Override
public void clear()
{
getConfig().clear();
}
@Override
public void clearProperty(String key)
{
config.clearProperty(makePath(key));
}
@Override
public boolean containsKey(String key)
{
return config.containsKey(makePath(key));
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
@Override
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
@Override
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
@Override
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
@Override
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
@Override
public int getInt(String key)
{
return config.getInt(makePath(key));
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return config.getKeys(makePath());
}
@Override
public Iterator<String> getKeys(String prefix)
{
return config.getKeys(makePath(prefix));
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
@Override
public List<Object> getList(String key)
{
return config.getList(makePath(key));
}
@Override
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public long getLong(String key)
{
return config.getLong(makePath(key));
}
@Override
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
@Override
public Object getProperty(String key)
{
return config.getProperty(makePath(key));
}
@Override
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public short getShort(String key)
{
return config.getShort(makePath(key));
}
@Override
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
@Override
public String getString(String key)
{
return config.getString(makePath(key));
}
@Override
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
@Override
public boolean isEmpty()
{
return getConfig().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
getConfig().setProperty(key, value);
}
@Override
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
@Override
public Node getRoot()
{
return getConfig().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
getConfig().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
getConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
@Override
public void clearTree(String key)
{
config.clearTree(makePath(key));
}
@Override
public int getMaxIndex(String key)
{
return config.getMaxIndex(makePath(key));
}
@Override
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
config.save(writer);
}
public void load(Reader reader) throws ConfigurationException
{
config.load(reader);
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return getConfig().getErrorListeners();
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
private HierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return getSubstitutor().replace(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return getSubstitutor().replace(pathPattern) + item;
",0,False
"return new Byte(n.byteValue());
",0,False
"return new Short(n.shortValue());
",0,False
"catch (Exception ex)
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"catch (Exception e)
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"catch (Exception e)
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"staticCatalog = catalog;
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
private final ImmutableConfiguration configuration;,0,False
"ResultSet rs = ps.executeQuery();
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"return new Byte(n.byteValue());
",0,False
private NodeHandler<T> nodeHandler;,0,False
"return new ConfigurationNodeIteratorChildren<T>(this, test, reverse,
",0,False
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
ConfigurationNode child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof AbstractHierarchicalConfiguration)
{
AbstractHierarchicalConfiguration conf = (AbstractHierarchicalConfiguration) child.getValue();
ConfigurationNode root = (ConfigurationNode) conf.getRootNode();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (ConfigurationNode) children.get(i);
configuration.getRootNode().addChild(child);
}
{if (true) return configuration;}
",0,False
public java.io.PrintStream debugStream = System.out;,0,False
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0,False
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0,False
"ReInit(dstream, encoding, startline, startcolumn, 4096);
}
",0,False
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size() - getStartOffset();
",0,False
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
protected Configuration configuration;,0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
"catch (Exception e)
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
public Token currentToken;,0,False
"switch (i) {
case 0: jj_3_1(); break;
",0,False
"if ((jjbitVec0[i2] & l2) == 0L)
{
break;
}
if (kind > 21)
{
kind = 21;
}
jjCheckNAdd(8);
break;
",0,False
"ReInit(stream);
SwitchTo(lexState);
}
",0,False
"jjCheckNAdd(jjnextStates[start]);
jjCheckNAdd(jjnextStates[start + 1]);
}
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"private StringBuffer buffer = new StringBuffer();
private List stack = new ArrayList();
public XMLPropertyListHandler(Node root)
{
push(root);
}
private Node peek()
{
if (!stack.isEmpty())
{
return (Node) stack.get(stack.size() - 1);
}
else
{
return null;
}
}
private Node pop()
{
if (!stack.isEmpty())
{
return (Node) stack.remove(stack.size() - 1);
}
else
{
return null;
}
}
private void push(Node node)
{
stack.add(node);
}
public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException
{
if (""array"".equals(qName))
{
push(new ArrayNode());
}
else if (""dict"".equals(qName))
{
if (peek() instanceof ArrayNode)
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) peek();
node.addValue(config);
push(config.getRoot());
}
}
}
public void endElement(String uri, String localName, String qName) throws SAXException
{
if (""key"".equals(qName))
{
PListNode node = new PListNode();
node.setName(buffer.toString());
peek().addChild(node);
push(node);
}
else if (""dict"".equals(qName))
{
pop();
}
else
{
if (""string"".equals(qName))
{
((PListNode) peek()).addValue(buffer.toString());
}
else if (""integer"".equals(qName))
{
((PListNode) peek()).addIntegerValue(buffer.toString());
}
else if (""real"".equals(qName))
{
((PListNode) peek()).addRealValue(buffer.toString());
}
else if (""true"".equals(qName))
{
((PListNode) peek()).addTrueValue();
}
else if (""false"".equals(qName))
{
((PListNode) peek()).addFalseValue();
}
else if (""data"".equals(qName))
{
((PListNode) peek()).addDataValue(buffer.toString());
}
else if (""date"".equals(qName))
{
((PListNode) peek()).addDateValue(buffer.toString());
}
else if (""array"".equals(qName))
{
ArrayNode array = (ArrayNode) pop();
((PListNode) peek()).addList(array);
}
if (!(peek() instanceof ArrayNode))
{
pop();
}
}
buffer.setLength(0);
}
public void characters(char[] ch, int start, int length) throws SAXException
{
buffer.append(ch, start, length);
}
",0,False
"return (configuration.getURL() != null) ? fileFromURL(configuration
",0,False
"List lst = (List) namedNodes.remove(name);
",0,False
"ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<>();
namedConfigurations = new HashMap<>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
"return (src != null) ? src.clone() : null;
",0,False
"ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if(optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"catch (Exception ex)
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
private ConfigurationSourceData sourceData;,0,False
"return new Float(n.floatValue());
",0,False
private final EventType<?> errorOperationType;,0,False
"catch (Exception e)
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
private final QueryResult<T> attributeResult;,0,False
"return getFloat(key, new Float(defaultValue)).floatValue();
",0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"public class CombinedConfiguration extends HierarchicalReloadableConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, AbstractConfiguration> namedConfigurations;
private boolean ignoreReloadExceptions = true;
private boolean reloadRequired;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(NodeCombiner comb, Lock lock)
{
super(lock);
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(Lock lock)
{
this(null, lock);
}
public CombinedConfiguration()
{
this(null, null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Adding configuration "" + config + "" with name "" + name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return namedConfigurations.get(name);
}
public List<AbstractConfiguration> getConfigurations()
{
List<AbstractConfiguration> list = new ArrayList<AbstractConfiguration>(configurations.size());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
public List<String> getConfigurationNameList()
{
List<String> list = new ArrayList<String>(configurations.size());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
reloadRequired = true;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
@Override
public ConfigurationNode getRootNode()
{
synchronized (getReloadLock())
{
if (reloadRequired || combinedRoot == null)
{
combinedRoot = constructCombinedNode();
reloadRequired = false;
}
return combinedRoot;
}
}
@Override
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, AbstractConfiguration>();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
@Override
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (ConfigData cd : configurations)
{
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List<ConfigurationNode> nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator<ConfigurationNode> it = nodes.iterator();
Configuration source = findSourceConfiguration(it.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration(it.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
@Override
protected List<ConfigurationNode> fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
synchronized (getReloadLock())
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
}
return this;
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"if (configs != null)
",0,False
"instanceId = ++counter;
",0,False
"{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"if (init)
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
private final String protocol;,0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"XMLNode nd = (XMLNode) createNode(node.getName());
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
private EntityResolver entityResolver = new DefaultEntityResolver();,0,False
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0,False
"catch (Exception ex)
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
private ReloadingController reloadingController;,0,False
"return new Double(n.doubleValue());
",0,False
"catch (Exception e)
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"return getByte(key, new Byte(defaultValue)).byteValue();
",0,False
"parent.mkdirs();
",0,False
private NodeCombiner nodeCombiner;,0,False
"return new Double(n.doubleValue());
",0,False
private Document document;,0,False
"catch (Exception e)
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"catch (Exception e)
",0,False
"initProperty(bean, propName, properties.get(propName));
",0,False
"getConfiguration().addProperty(name, new Character(array[i]));
",0,False
"Node node = new Node();
String key = String();
node.setName(key);
jj_consume_token(EQUAL);
Object value = Element();
node.setValue(value);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
return node;
",0,False
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0,False
"buffer = null;
bufline = null;
bufcolumn = null;
}
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0,False
"return(""Lexical error at line "" +
",0,False
"{
public Object createObject(Attributes attributes) throws Exception
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) getDigester().peek();
node.addValue(config);
return config.getRoot();
",0,False
"addValue(Base64.decodeBase64(value.getBytes()));
",0,False
"{
super(methodName);
}
public void end(String namespace, String name) throws Exception
{
super.end(namespace, name);
digester.pop();
}
",0,False
"} catch (final Exception ex) {
",0,False
"} catch (final Exception ex) {
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
private final NodeHandler<T> handler;,0,False
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0,False
"if (file != null && file.exists())
",0,False
protected Configuration configuration;,0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"configurationsMap.putIfAbsent(pattern, configuration);
",0,False
"writer = new OutputStreamWriter(out);
",0,False
private FlatNode root;,0,False
"catch (Exception ex)
",0,False
"return new Short(n.shortValue());
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 5; i++) jj_la1[i] = -1;
}
",0,False
"ReInit(stream);
SwitchTo(lexState);
}
",0,False
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0,False
"Token token = null;
String value = null;
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
{if (true) return unescapeQuotes(removeQuotes(token.image));}
break;
case STRING:
token = jj_consume_token(STRING);
{if (true) return token.image;}
break;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
",0,False
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
"if (init)
",0,False
"catch (Exception e)
",0,False
"catch (Exception ex)
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"catch (Exception e)
",0,False
"String name = (url == null) ? fileName : url.toString();
",0,False
private ConfigurationNode node;,0,False
"catch (Exception e)
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"catch (Exception e)
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0,False
private NodeCombiner nodeCombiner;,0,False
"catch (Exception ex)
",0,False
"catch (Exception e)
",0,False
"Object value = null;
if (jj_2_1(2)) {
value = Array();
{if (true) return value;}
} else {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_BEGIN:
value = Dictionary();
{if (true) return value;}
break;
case STRING:
case QUOTED_STRING:
value = String();
{if (true) return value;}
break;
case DATA:
value = Data();
{if (true) return value;}
break;
case DATE:
value = Date();
{if (true) return value;}
break;
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"token = jj_consume_token(DATE);
{if (true) return parseDate(token.image);}
",0,False
"ReInit(stream);
SwitchTo(lexState);
}
",0,False
"jjCheckNAdd(jjnextStates[start]);
jjCheckNAdd(jjnextStates[start + 1]);
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0,False
public Token specialToken;,0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
"final BaseHierarchicalConfiguration result = new BaseHierarchicalConfiguration() {
@Override
protected Object interpolate(final Object value) {
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator() {
return parent.getInterpolator();
",0,False
"} catch (final Exception e) {
",0,False
"addLookup(DefaultLookups.valueOf(lookupName.toUpperCase()), lookupMap);
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"staticCatalog = catalog;
",0,False
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0,False
"value = array.length == 0 ? null : new Integer(array[0]);
",0,True
"value = array.length == 0 ? null : new Long(array[0]);
",0,True
"value = array.length == 0 ? null : new Double(array[0]);
",0,True
"public class CombinedConfiguration extends HierarchicalConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
synchronized (getNodeCombiner()) 
{
combinedRoot = null;
}
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
invalidate();
}
public ConfigurationNode getRootNode()
{
synchronized (getNodeCombiner())
{
if (combinedRoot == null)
{
combinedRoot = constructCombinedNode();
}
return combinedRoot;
}
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Object getProperty(String key)
{
if (isForceReloadCheck())
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
;
}
}
}
return super.getProperty(key);
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
return node;
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
private ExpressionEngine expressionEngine;,0,False
"{
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0,False
"return new Byte(n.byteValue());
",0,False
"return new Float(n.floatValue());
",0,False
"return new Double(n.doubleValue());
",0,False
"getConfiguration().addProperty(name, new Integer(array[i]));
",0,True
"getConfiguration().addProperty(name, new Character(array[i]));
",0,False
"getConfiguration().addProperty(name, new Double(array[i]));
",0,True
"getConfiguration().addProperty(name, new Short(array[i]));
",0,True
"getConfiguration().addProperty(name, new Byte(array[i]));
",0,False
"expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
",0,False
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_BEGIN:
case DICT_BEGIN:
case DATA:
case STRING:
case QUOTED_STRING:
element = Element();
list.add(element);
label_2:
while (true)
{
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(ARRAY_SEPARATOR);
element = Element();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
return list;
",0,False
"{
public Object createObject(Attributes attributes) throws Exception
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) getDigester().peek();
node.addValue(config);
return config.getRoot();
",0,False
"addValue(new Integer(value));
",0,False
"addValue(new Double(value));
",0,False
"{
public void end() throws Exception
{
}
",0,False
"List lst = (List) namedNodes.get(node.getName());
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"catch (Exception e)
",0,False
private AutoSaveListener autoSaveListener;,0,False
"return new ConfigurationBuilderResultCreatedEvent(this,
",0,False
private ReloadingController reloadingController;,0,False
"catch (Exception ex)
",0,False
private final String protocol;,0,False
"staticCatalog = catalog;
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
private final QueryResult<T> attributeResult;,0,False
"PrintStream stream = new PrintStream(os);
",0,False
private final ConversionHandler dataConversionHandler;,0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"catch (Exception ex)
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"catch (Exception e)
",0,False
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0,False
private FileLocator locator;,0,False
"staticCatalog = catalog;
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"catch (Exception e)
",0,False
private AutoSaveListener autoSaveListener;,0,False
private ConfigurationSourceData sourceData;,0,False
"return new Float(n.floatValue());
",0,False
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0,False
"catch (Exception ex)
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"PrintStream stream = new PrintStream(os);
",0,False
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0,False
"catch (Exception e)
",0,False
private ReloadingController reloadingController;,0,False
"return new Double(n.doubleValue());
",0,False
"return new Float(n.floatValue());
",0,False
"catch (Exception ex)
",0,False
"staticCatalog = catalog;
",0,False
private final NodeHandler<T> handler;,0,False
"final ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"return dataSource;
",0,False
private ConfigurationListener changeListener;,0,False
"PrintStream stream = new PrintStream(os);
",0,False
"catch (Exception ex)
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"switch (event.getType())
{
case AbstractConfiguration.EVENT_ADD_PROPERTY:
boolean contained = layoutData.containsKey(event
.getPropertyName());
PropertyLayoutData data = fetchLayoutData(event
.getPropertyName());
data.setSingleLine(!contained);
break;
case AbstractConfiguration.EVENT_CLEAR_PROPERTY:
layoutData.remove(event.getPropertyName());
break;
case AbstractConfiguration.EVENT_CLEAR:
clear();
break;
case AbstractConfiguration.EVENT_SET_PROPERTY:
fetchLayoutData(event.getPropertyName());
",0,False
private Document document;,0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
"writer = new OutputStreamWriter(out);
",0,False
"public class CombinedConfiguration extends HierarchicalConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
combinedRoot = null;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (!event.isBeforeUpdate())
{
invalidate();
}
}
public ConfigurationNode getRootNode()
{
if (combinedRoot == null)
{
combinedRoot = constructCombinedNode();
}
return combinedRoot;
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator it = nodes.iterator();
Configuration source = findSourceConfiguration((ConfigurationNode) it
.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration((ConfigurationNode) it
.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected List fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
;
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
return this;
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0,False
"catch (Exception e)
",0,False
"catch (Exception e)
",0,False
private DocumentBuilder documentBuilder;,0,False
"catch (Exception e)
",0,False
"expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
",0,False
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0,False
"Object value = null;
if (jj_2_1(2)) {
value = Array();
{if (true) return value;}
} else {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_BEGIN:
value = Dictionary();
{if (true) return value;}
break;
case STRING:
case QUOTED_STRING:
value = String();
{if (true) return value;}
break;
case DATA:
value = Data();
{if (true) return value;}
break;
case DATE:
value = Date();
{if (true) return value;}
break;
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0,False
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0,False
"buffer = null;
bufline = null;
bufcolumn = null;
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"return (configuration.getURL() != null) ? fileFromURL(configuration
",0,False
"List lst = (List) namedNodes.remove(name);
",0,False
"return getLong(key, new Long(defaultValue)).longValue();
",0,False
"value = array.length == 0 ? null : new Double(array[0]);
",0,True
"value = array.length == 0 ? null : new Short(array[0]);
",0,True
"writer = new OutputStreamWriter(out);
",0,False
"parent.mkdirs();
",0,False
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"ResultSet rs = pstmt.executeQuery();
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
private ExpressionEngine expressionEngine;,0,False
"return new Byte(n.byteValue());
",0,False
"{
super(name);
setReference(elem);
}
public void setValue(Object value)
{
super.setValue(value);
if (getReference() != null && document != null)
{
if (isAttribute())
{
updateAttribute();
}
else
{
updateElement(value);
}
}
}
protected void removeReference()
{
if (getReference() != null)
{
Element element = (Element) getReference();
if (isAttribute())
{
updateAttribute();
}
else
{
org.w3c.dom.Node parentElem = element.getParentNode();
if (parentElem != null)
{
parentElem.removeChild(element);
}
}
}
}
private void updateElement(Object value)
{
Text txtNode = findTextNodeForUpdate();
if (value == null)
{
if (txtNode != null)
{
((Element) getReference()).removeChild(txtNode);
}
}
else
{
if (txtNode == null)
{
txtNode = document
.createTextNode(PropertyConverter.escapeDelimiters(
value.toString(), getListDelimiter()));
if (((Element) getReference()).getFirstChild() != null)
{
((Element) getReference()).insertBefore(txtNode,
((Element) getReference()).getFirstChild());
}
else
{
((Element) getReference()).appendChild(txtNode);
}
}
else
{
txtNode.setNodeValue(PropertyConverter.escapeDelimiters(
value.toString(), getListDelimiter()));
}
}
}
private void updateAttribute()
{
XMLBuilderVisitor.updateAttribute(getParent(), getName(), getListDelimiter());
}
private Text findTextNodeForUpdate()
{
Text result = null;
Element elem = (Element) getReference();
NodeList children = elem.getChildNodes();
Collection textNodes = new ArrayList();
for (int i = 0; i < children.getLength(); i++)
{
org.w3c.dom.Node nd = children.item(i);
if (nd instanceof Text)
{
if (result == null)
{
result = (Text) nd;
}
else
{
textNodes.add(nd);
}
}
}
if (result instanceof CDATASection)
{
textNodes.add(result);
result = null;
}
for (Iterator it = textNodes.iterator(); it.hasNext();)
{
elem.removeChild((org.w3c.dom.Node) it.next());
}
return result;
",0,False
"getConfiguration().addProperty(name, new Long(array[i]));
",0,True
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true)
{
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration)
{
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
return configuration;
",0,False
"buffer = null;
bufline = null;
bufcolumn = null;
}
",0,False
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0,False
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"public int beginLine, beginColumn, endLine, endColumn;",0,False
"addValue(new Integer(value));
",0,False
"{
public Object createObject(Attributes attributes) throws Exception
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) getDigester().peek();
node.addValue(config);
return config.getRoot();
",0,False
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0,False
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0,False
"dump(configuration, new PrintWriter(out));
",0,False
"pstmt = getConnection().prepareStatement(statement);
",0,False
"catch (Exception ex)
",0,False
"return new Double(n.doubleValue());
",0,False
"staticCatalog = catalog;
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0,False
"return getShort(key, new Short(defaultValue)).shortValue();
",0,False
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0,False
"public class CombinedConfiguration extends HierarchicalReloadableConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, AbstractConfiguration> namedConfigurations;
private boolean ignoreReloadExceptions = true;
private boolean reloadRequired;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(NodeCombiner comb, Lock lock)
{
super(lock);
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(Lock lock)
{
this(null, lock);
}
public CombinedConfiguration()
{
this(null, null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Adding configuration "" + config + "" with name "" + name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return namedConfigurations.get(name);
}
public List<AbstractConfiguration> getConfigurations()
{
List<AbstractConfiguration> list = new ArrayList<AbstractConfiguration>(configurations.size());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
public List<String> getConfigurationNameList()
{
List<String> list = new ArrayList<String>(configurations.size());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
reloadRequired = true;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
@Override
public ConfigurationNode getRootNode()
{
synchronized (getReloadLock())
{
if (reloadRequired || combinedRoot == null)
{
combinedRoot = constructCombinedNode();
reloadRequired = false;
}
return combinedRoot;
}
}
@Override
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, AbstractConfiguration>();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
@Override
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (ConfigData cd : configurations)
{
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List<ConfigurationNode> nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator<ConfigurationNode> it = nodes.iterator();
Configuration source = findSourceConfiguration(it.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration(it.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
@Override
protected List<ConfigurationNode> fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
synchronized (getReloadLock())
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
}
return this;
",0,False
"getLogger().debug(os.toString());
",0,False
"if (file != null && file.exists())
",0,False
"pstmt = conn.prepareStatement(query.toString());
",0,False
"parent.mkdirs();
",0,False
private final Object reloadLock;,0,False
"synchronized (counterLock)
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<?> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final AbstractHierarchicalFileConfiguration config;
private final String path;
private final boolean trailing;
private boolean init;
public PatternSubtreeConfigurationWrapper(AbstractHierarchicalFileConfiguration config, String path)
{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
@Override
public Object getReloadLock()
{
return config.getReloadLock();
}
@Override
public void addProperty(String key, Object value)
{
config.addProperty(makePath(key), value);
}
@Override
public void clear()
{
getConfig().clear();
}
@Override
public void clearProperty(String key)
{
config.clearProperty(makePath(key));
}
@Override
public boolean containsKey(String key)
{
return config.containsKey(makePath(key));
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
@Override
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
@Override
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
@Override
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
@Override
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
@Override
public int getInt(String key)
{
return config.getInt(makePath(key));
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return config.getKeys(makePath());
}
@Override
public Iterator<String> getKeys(String prefix)
{
return config.getKeys(makePath(prefix));
}
@Override
public List<Object> getList(String key, List<?> defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
@Override
public List<Object> getList(String key)
{
return config.getList(makePath(key));
}
@Override
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public long getLong(String key)
{
return config.getLong(makePath(key));
}
@Override
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
@Override
public Object getProperty(String key)
{
return config.getProperty(makePath(key));
}
@Override
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public short getShort(String key)
{
return config.getShort(makePath(key));
}
@Override
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
@Override
public String getString(String key)
{
return config.getString(makePath(key));
}
@Override
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
@Override
public boolean isEmpty()
{
return getConfig().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
getConfig().setProperty(key, value);
}
@Override
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
@Override
public Node getRoot()
{
return getConfig().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
getConfig().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
getConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
@Override
public void clearTree(String key)
{
config.clearTree(makePath(key));
}
@Override
public int getMaxIndex(String key)
{
return config.getMaxIndex(makePath(key));
}
@Override
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
config.save(writer);
}
public void load(Reader reader) throws ConfigurationException
{
config.load(reader);
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return getConfig().getErrorListeners();
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
private HierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return getSubstitutor().replace(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return getSubstitutor().replace(pathPattern) + item;
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"catch (Exception ex)
",0,False
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0,False
"result = namedNodes.get(name);
",0,False
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0,False
"getLogger().debug(os.toString());
",0,False
"catch (final Exception e)
",0,False
"catch (final Exception ex)
",0,False
"staticCatalog = catalog;
",0,False
private final QueryResult<T> attributeResult;,0,False
"public class MultiFileHierarchicalConfiguration extends AbstractHierarchicalFileConfiguration
implements ConfigurationListener, ConfigurationErrorListener, EntityResolverSupport
{
private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public <T> List<T> getList(String key, List<T> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public <T> List<T> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubConfiguration<ConfigurationNode> configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubConfiguration<ConfigurationNode> configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<SubConfiguration<ConfigurationNode>> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public ConfigurationNode getRootNode()
{
return getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
Collection<ConfigurationListener> listeners = getConfigurationListeners();
for (ConfigurationListener listener : listeners)
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
Collection<ConfigurationErrorListener> listeners = getErrorListeners();
for (ConfigurationErrorListener listener : listeners)
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractHierarchicalFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (getReloadingStrategy() == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(getReloadingStrategy());
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0,False
"catch (Exception ex)
",0,False
"reader = new InputStreamReader(in);
",0,False
"writer = new OutputStreamWriter(out);
",0,False
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0,False
"catch (Exception ex)
",0,False
"getLogger().debug(os.toString());
",0,False
"catch (Exception ex)
",0,False
private final String protocol;,0,False
"ReInit(stream, null);
}
",0,False
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 5; i++) jj_la1[i] = -1;
}
",0,False
"Token token = null;
token = jj_consume_token(STRING);
{if (true) return StringEscapeUtils.unescapeJava(removeQuotes(token.image));}
",0,False
"try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 5; i++) jj_la1[i] = -1;
}
",0,False
"ReInit(stream);
SwitchTo(lexState);
}
",0,False
"if (lexState >= 1 || lexState < 0)
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
else
curLexState = lexState;
}
",0,False
"ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
",0,False
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0,False
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0,False
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0,False
"return(""Lexical error at line "" +
",0,False
"retval += "" \"""";
",0,False
public Token currentToken;,0,False
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0,False
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0,False
"ReInit(dstream, startline, startcolumn, 4096);
}
",0,False
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
}
",0,False
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0,False
public int endLine;,0,False
"return(""Lexical error at line "" +
",0,False
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0,False
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0,False
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0,False
"List<ConfigurationNode> nodes = namedNodes.get(node.getName());
",0,False
private AutoSaveListener autoSaveListener;,0,False
"getLogger().debug(os.toString());
",0,False
"catch (Exception e)
",0,False
private ReloadingController reloadingController;,0,False
"catch (Exception ex)
",0,False
private final String protocol;,0,False
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0,False
"return this.url;
",0,False
"return null;
",0,False
"return statement.execute(sql);
",0,False
"statement.addBatch(sql);
",0,False
"return statement.executeLargeUpdate(sql, autoGeneratedKeys);
",0,False
"return statement.execute(sql, columnIndexes);
",0,False
"} catch (final Exception ie) {
",0,False
"conn.validate(validationQuery, validationQueryTimeoutSeconds);
",0,False
"} catch (final Exception e) {
",0,False
"return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnNames));
",0,False
"return connection.prepareStatement(sql, columnNames);
",0,False
"if (!this.currentXid.equals(xid)) {
",0,False
"if (!this.currentXid.equals(xid)) {
",0,False
"} catch (final Exception ignore) {
",0,False
"} catch (final Exception t) {
",0,False
"return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnNames)));
",0,False
"connection.prepareStatement(sql, resultSetType, resultSetConcurrency)));
",0,False
"return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnIndexes)));
",0,False
"return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, autoGeneratedKeys));
",0,False
"return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnIndexes));
",0,False
"rset = stmt.executeQuery(validationQuery);
",0,False
"closeDueToException(info);
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"if (userName == null || !userName.equals(this.userName)) {
",1,False
"connection.prepareStatement(sql, resultSetType, resultSetConcurrency));
",0,False
"return connection.prepareStatement(sql, autoGeneratedKeys);
",0,False
"return columnNames;
",1,False
"rset = stmt.executeQuery(validationQuery);
",0,False
"return statement.executeLargeUpdate(sql, autoGeneratedKeys);
",0,False
"return statement.executeUpdate(sql, columnNames);
",0,False
"} catch (final Exception e) {
",0,False
"return statement.execute(sql, columnNames);
",0,False
private UserPassKey userPassKey;,0,False
"return null;
",0,False
"return connection.prepareStatement(sql, autoGeneratedKeys);
",0,False
"return ( null );
",0,False
"{
public Field[] run()
{
return type.getDeclaredFields();
",0,False
"{
public Constructor<?>[] run()
{
return type.getDeclaredConstructors();
",0,False
"if ( paramTypes.length == 0 )
",0,False
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"if (paramTypes.length == 0) {
",0,False
"protected String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
protected static float version;,0,False
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0,False
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"invokeExactMethod( parent, methodName, new Object[] { child }, paramTypes );
",0,False
"return ( null );
",0,False
"{
public Field[] run()
{
return type.getDeclaredFields();
",0,False
protected String namespaceURI = null;,0,False
"private final Map<Class<?>, FromAnnotationsRuleSet> data = new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
}
};",0,False
"new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
",0,False
private final float loadFactor = 0.75f;,0,False
"return null;
",0,False
protected static float version;,0,False
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0,False
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
private final List<ErrorMessage> errors;,0,False
"if (paramTypes.length == 0) {
",0,False
"} catch (Exception e) {
",0,False
"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
private FromXmlRuleSet ruleSet;,0,False
"Object paramValues[] = new Object[paramTypes.length];
",0,False
protected String namespaceURI = null;,0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0,False
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"return ( null );
",0,False
private String currChildNamespaceURI = null;,0,False
private final int cacheSize = 255;,0,False
private final float loadFactor = 0.75f;,0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
",0,False
"return null;
",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
protected static String versionNumber = null;,0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
"public static String DFLT_METHOD_ATTR = ""method"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"if ( paramTypes.length == 0 )
",0,False
"rulesBinder.addError( e );
",0,False
"|| rulesBinder.isAlreadyBound( type ) )
",0,False
"{
public Method[] run()
{
return type.getDeclaredMethods();
",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"Object paramValues[] = new Object[this.paramTypes.length];
",0,False
"return this.memoryRulesBinder.forPattern(pattern);
",0,False
"} catch (Exception e) {
",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"version = new Float( versionNumber ).floatValue();
",0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"public static String DFLT_FALSEVAL = ""false"";",0,False
"log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
",0,False
"} catch (Exception e) {
",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0,False
"public final String DFLT_PLUGIN_ID_ATTR = ""plugin-id"";",0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
private FromXmlRuleSet ruleSet;,0,False
"return ( null );
",0,False
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0,False
"final String address = emails.get( type );
",0,False
"return new java.io.StringReader( baos.toString() );
",0,False
private final Connection conn;,0,False
"this.updated = updated;
",0,False
"return s.toLowerCase();
",0,False
"final BufferedReader in = new BufferedReader( inRaw );
",0,False
"{
public Constructor<?>[] run()
{
return type.getDeclaredConstructors();
",0,False
"return null;
",0,False
"return updated;
",0,False
"return updated;
",0,False
"java.io.FileInputStream fis = new java.io.FileInputStream( srcfile );
",0,False
private Connection conn;,0,False
"this.updated = updated;
",0,False
"FileReader inRaw = new FileReader( source );
",0,False
"if (paramTypes.length == 0) {
",0,False
"} catch (Exception e) {
",0,False
"log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
",0,False
protected String namespaceURI = null;,0,False
private String currChildNamespaceURI = null;,0,False
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0,False
"version = new Float( versionNumber ).floatValue();
",0,False
"// TODO: Consider making following four constants static in 2.0
public final String DFLT_PLUGIN_CLASS_ATTR_NS = null;",0,False
"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0,False
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0,False
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"Object paramValues[] = new Object[paramTypes.length];
",0,False
"return ( null );
",0,False
"return ( null );
",0,False
"return null;
",0,False
"public static String DFLT_METHOD_NAME = ""addRules"";",0,False
"rulesBinder.addError( e );
",0,False
"|| rulesBinder.isAlreadyBound( type ) )
",0,False
"return memoryRulesBinder.forPattern( pattern );
",0,False
"{
public Method[] run()
{
return type.getDeclaredMethods();
",0,False
"|| rulesBinder.isAlreadyBound( type ) )
",0,False
"rulesBinder.addError( e );
",0,False
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0,False
"{
@Override
protected void loadRules()
{
loadXMLRules( xmlRulesResource );
}
",0,False
"return memoryRulesBinder.forPattern( pattern );
",0,False
"if ( paramTypes.length == 0 )
",0,False
"return ( null );
",0,False
"{
public Method[] run()
{
return type.getDeclaredMethods();
",0,False
"return null;
",0,False
"return memoryRulesBinder.forPattern( pattern );
",0,False
"Object paramValues[] = new Object[paramTypes.length];
",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0,False
"public static String DFLT_FILENAME_ATTR = ""file"";",0,False
"if ( paramTypes.length == 0 )
",0,False
"{
public Method[] run()
{
return type.getDeclaredMethods();
",0,False
"{
public Field[] run()
{
return type.getDeclaredFields();
",0,False
"} catch (Exception e) {
",0,False
private final ClassLoader classLoader;,0,False
"invokeMethod( parent, methodName, new Object[] { child }, paramTypes );
",0,False
private String namespaceURI;,1,False
"this.rulesBinder.install( rulesModule );
",0,False
"throw new SAXException( format( ""[ObjectCreateRule]{%s} Class '%s' does not have a construcor with types"",
",1,False
"this.rulesBinder.addError( t );
",0,False
"this.classLoader = new BinderClassLoader( classLoader );
",1,False
private boolean useContextClassLoader;,1,False
"if (this.paramTypes.length > 0) {
",0,False
"return String.format(""ObjectCreateRule[className=%s, attributeName=%s]"", this.type.getClasses(), this.attributeName);
",0,False
"invokeMethod( parent, methodName, new Object[] { child }, paramTypes );
",0,False
"return (null);
",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"boundary = boundaryStr.getBytes(); 
",1,False
"throw new IOFileUploadException(format(""Processing of %s request failed. "",
",1,False
"if (fileItem instanceof FileItemHeadersSupport) {
",1,False
"String nameLower = name.toLowerCase();
",0,False
"boundary = boundaryStr.getBytes(); 
",1,False
"this(null, null, null);
",0,False
"this.chars = charArray;
",1,False
"FileInputStream input = new FileInputStream(dfosFile);
",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"return new String(rawdata);
",0,False
protected boolean lastCR = false;,1,False
"boundary = boundaryStr.getBytes(); 
",0,False
"throw (FileUploadException) e.getCause();
",1,False
private boolean opened;,0,False
"if (fileItem instanceof FileItemHeadersSupport) {
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"&&  subContentType.toLowerCase()
",0,False
"&& pContentDisposition.toLowerCase().startsWith(FORM_DATA)) {
",0,False
"return headers.get(name.toLowerCase());
",0,False
"boundary = boundaryStr.getBytes();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"skip(av);
",0,False
"headers = baos.toString();
",0,False
"return new String(rawdata);
",0,False
"&&  subContentType.toLowerCase()
",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"return cachedContent;
",0,False
"private static final String UID =
new java.rmi.server.UID().toString()
.replace(':', '_').replace('-', '_');
private static int counter = 0;
private String fieldName;
private String contentType;
private boolean isFormField;
private String fileName;
private long size = -1;
private int sizeThreshold;
private File repository;
private byte[] cachedContent;
private transient DeferredFileOutputStream dfos;
private File dfosFile;
public DiskFileItem(String fieldName, String contentType,
boolean isFormField, String fileName, int sizeThreshold,
File repository) {
this.fieldName = fieldName;
this.contentType = contentType;
this.isFormField = isFormField;
this.fileName = fileName;
this.sizeThreshold = sizeThreshold;
this.repository = repository;
}
public InputStream getInputStream()
throws IOException {
if (!isInMemory()) {
return new FileInputStream(dfos.getFile());
}
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return new ByteArrayInputStream(cachedContent);
}
public String getContentType() {
return contentType;
}
public String getCharSet() {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(getContentType(), ';');
return (String) params.get(""charset"");
}
public String getName() {
return fileName;
}
public boolean isInMemory() {
if (cachedContent != null) {
return true;
}
return dfos.isInMemory();
}
public long getSize() {
if (size >= 0) {
return size;
} else if (cachedContent != null) {
return cachedContent.length;
} else if (dfos.isInMemory()) {
return dfos.getData().length;
} else {
return dfos.getFile().length();
}
}
public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}
public String getString(final String charset)
throws UnsupportedEncodingException {
return new String(get(), charset);
}
public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}
public void write(File file) throws Exception {
if (isInMemory()) {
FileOutputStream fout = null;
try {
fout = new FileOutputStream(file);
fout.write(get());
} finally {
if (fout != null) {
fout.close();
}
}
} else {
File outputFile = getStoreLocation();
if (outputFile != null) {
size = outputFile.length();
if (!outputFile.renameTo(file)) {
BufferedInputStream in = null;
BufferedOutputStream out = null;
try {
in = new BufferedInputStream(
new FileInputStream(outputFile));
out = new BufferedOutputStream(
new FileOutputStream(file));
IOUtils.copy(in, out);
} finally {
if (in != null) {
try {
in.close();
} catch (IOException e) {
}
}
if (out != null) {
try {
out.close();
} catch (IOException e) {
}
}
}
}
} else {
throw new FileUploadException(
""Cannot write uploaded file to disk!"");
}
}
}
public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
public String getFieldName() {
return fieldName;
}
public void setFieldName(String fieldName) {
this.fieldName = fieldName;
}
public boolean isFormField() {
return isFormField;
}
public void setFormField(boolean state) {
isFormField = state;
}
public OutputStream getOutputStream()
throws IOException {
if (dfos == null) {
File outputFile = getTempFile();
dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);
}
return dfos;
}
public File getStoreLocation() {
return dfos.getFile();
}
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
protected File getTempFile() {
File tempDir = repository;
if (tempDir == null) {
tempDir = new File(System.getProperty(""java.io.tmpdir""));
}
String tempFileName = ""upload_"" + UID + ""_"" + getUniqueId() + "".tmp"";
File f = new File(tempDir, tempFileName);
FileCleaner.track(f, this);
return f;
}
private static String getUniqueId() {
final int limit = 100000000;
int current;
synchronized (DiskFileItem.class) {
current = counter++;
}
String id = Integer.toString(current);
if (current < limit) {
id = (""00000000"" + id).substring(id.length());
}
return id;
}
public String toString() {
return ""name="" + this.getName()
+ "", StoreLocation=""
+ String.valueOf(this.getStoreLocation())
+ "", size=""
+ this.getSize()
+ ""bytes, ""
+ ""isFormField="" + isFormField()
+ "", FieldName=""
+ this.getFieldName();
}
private void writeObject(ObjectOutputStream out) throws IOException {
if (dfos.isInMemory()) {
cachedContent = get();
} else {
cachedContent = null;
dfosFile = dfos.getFile();
}
out.defaultWriteObject();
}
private void readObject(ObjectInputStream in)
throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}
",0,False
"return new String(rawdata);
",0,False
"return baos.toString();
",0,False
"outputFile.delete();
",0,False
"dfosFile.delete();
",0,False
"return cachedContent;
",0,False
"return new String(rawdata);
",0,False
"if (!""post"".equals(request.getMethod().toLowerCase())) {
",0,False
"boundary = boundaryStr.getBytes();
",0,False
"return null;
",0,False
"&&  subContentType.toLowerCase()
",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"outputFile.delete();
",0,False
"throw (FileUploadException) e.getCause();
",0,False
private boolean opened;,0,False
"if (contentType.toLowerCase().startsWith(MULTIPART)) {
",0,False
"headerValue += "","" + iter2.next();
",0,False
"String nameLower = name.toLowerCase();
",0,False
"String nameLower = name.toLowerCase();
",0,False
"if (contentType.toLowerCase().startsWith(MULTIPART)) {
",0,False
"headerValue += "","" + iter2.next();
",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"skip(av);
",0,False
"return cachedContent;
",0,False
"return new String(rawdata);
",0,False
"boundary = boundaryStr.getBytes();
",0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"fis.read(fileData);
",0,False
"String cdl = pContentDisposition.toLowerCase();
",0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"String nameLower = name.toLowerCase();
",0,False
"return baos.toString();
",0,False
"if (contentType.toLowerCase().startsWith(MULTIPART)) {
",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"fis.read(fileData);
",0,False
"return new String(rawdata);
",0,False
"IOUtils.copy(input, output);
",0,False
"}
",0,False
"&&  subContentType.toLowerCase()
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"if (contentType.toLowerCase().startsWith(MULTIPART)) {
",0,False
private boolean opened;,0,False
"skip(av);
",0,False
"paramName = paramName.toLowerCase();
",0,False
"return cachedContent;
",0,False
"return (String) headers.get(name.toLowerCase());
",0,False
"header += "" "" + headerPart.substring(nonWs, end);
",0,False
"return null;
",0,False
"String cdl = pContentDisposition.toLowerCase();
",0,False
"if (contentType.toLowerCase().startsWith(MULTIPART)) {
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"String nameLower = name.toLowerCase();
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0,False
"skip(av);
",0,False
"this.chars = charArray;
",0,False
"return new String(rawdata);
",0,False
"return parseRequest(new JakSrvltRequestContext(request));
",0,False
"subContentType.toLowerCase().startsWith(MULTIPART_MIXED)) {
",0,False
"return null;
",0,False
private boolean opened;,0,False
"boundary = boundaryStr.getBytes();
",0,False
"return (String) headers.get(name.toLowerCase());
",0,False
"headers = baos.toString();
",0,False
"outputFile.delete();
",0,False
"private static final String UID =
new UID().toString().replace(':', '_').replace('-', '_');
private static int counter = 0;
private String fieldName;
private String contentType;
private boolean isFormField;
private String fileName;
private long size = -1;
private int sizeThreshold;
private File repository;
private byte[] cachedContent;
private transient DeferredFileOutputStream dfos;
private File dfosFile;
public DiskFileItem(String fieldName, String contentType,
boolean isFormField, String fileName, int sizeThreshold,
File repository) {
this.fieldName = fieldName;
this.contentType = contentType;
this.isFormField = isFormField;
this.fileName = fileName;
this.sizeThreshold = sizeThreshold;
this.repository = repository;
}
public InputStream getInputStream()
throws IOException {
if (!isInMemory()) {
return new FileInputStream(dfos.getFile());
}
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return new ByteArrayInputStream(cachedContent);
}
public String getContentType() {
return contentType;
}
public String getCharSet() {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(getContentType(), ';');
return (String) params.get(""charset"");
}
public String getName() {
return fileName;
}
public boolean isInMemory() {
if (cachedContent != null) {
return true;
} else {
return dfos.isInMemory();
}
}
public long getSize() {
if (size >= 0) {
return size;
} else if (cachedContent != null) {
return cachedContent.length;
} else if (dfos.isInMemory()) {
return dfos.getData().length;
} else {
return dfos.getFile().length();
}
}
public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}
public String getString(final String charset)
throws UnsupportedEncodingException {
return new String(get(), charset);
}
public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}
public void write(File file) throws Exception {
if (isInMemory()) {
FileOutputStream fout = null;
try {
fout = new FileOutputStream(file);
fout.write(get());
} finally {
if (fout != null) {
fout.close();
}
}
} else {
File outputFile = getStoreLocation();
if (outputFile != null) {
size = outputFile.length();
if (!outputFile.renameTo(file)) {
BufferedInputStream in = null;
BufferedOutputStream out = null;
try {
in = new BufferedInputStream(
new FileInputStream(outputFile));
out = new BufferedOutputStream(
new FileOutputStream(file));
IOUtils.copy(in, out);
} finally {
if (in != null) {
try {
in.close();
} catch (IOException e) {
}
}
if (out != null) {
try {
out.close();
} catch (IOException e) {
}
}
}
}
} else {
throw new FileUploadException(
""Cannot write uploaded file to disk!"");
}
}
}
public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
public String getFieldName() {
return fieldName;
}
public void setFieldName(String fieldName) {
this.fieldName = fieldName;
}
public boolean isFormField() {
return isFormField;
}
public void setFormField(boolean state) {
isFormField = state;
}
public OutputStream getOutputStream()
throws IOException {
if (dfos == null) {
File outputFile = getTempFile();
dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);
}
return dfos;
}
public File getStoreLocation() {
return dfos.getFile();
}
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
protected File getTempFile() {
File tempDir = repository;
if (tempDir == null) {
tempDir = new File(System.getProperty(""java.io.tmpdir""));
}
String fileName = ""upload_"" + UID + ""_"" + getUniqueId() + "".tmp"";
File f = new File(tempDir, fileName);
FileCleaner.track(f, this);
return f;
}
private static String getUniqueId() {
final int limit = 100000000;
int current;
synchronized (DiskFileItem.class) {
current = counter++;
}
String id = Integer.toString(current);
if (current < limit) {
id = (""00000000"" + id).substring(id.length());
}
return id;
}
public String toString() {
return ""name="" + this.getName()
+ "", StoreLocation=""
+ String.valueOf(this.getStoreLocation())
+ "", size=""
+ this.getSize()
+ ""bytes, ""
+ ""isFormField="" + isFormField()
+ "", FieldName=""
+ this.getFieldName();
}
private void writeObject(ObjectOutputStream out) throws IOException {
if (dfos.isInMemory()) {
cachedContent = get();
} else {
cachedContent = null;
dfosFile = dfos.getFile();
}
out.defaultWriteObject();
}
private void readObject(ObjectInputStream in)
throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}
",0,False
"return new String(rawdata);
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0,False
"return cachedContent;
",0,False
"outputFile.delete();
",0,False
"dfosFile.delete();
",0,False
"String charset = word.substring(2, charsetPos).toLowerCase();
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"boundary = boundaryStr.getBytes(); 
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"this.chars = charArray;
",0,False
"return new String(rawdata);
",0,False
"dfosFile.delete();
",0,False
"String charset = word.substring(2, charsetPos).toLowerCase();
",0,False
"outputFile.delete();
",0,False
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0,False
"boundary = boundaryStr.getBytes(); 
",0,False
"throw (FileUploadException) e.getCause();
",0,False
"return null;
",0,False
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0,False
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0,False
"this.chars = charArray;
",0,False
"outputFile.delete();
",0,False
"return baos.toString();
",0,False
"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.getLocal() );
",0,False
"analysis = analyzer.analyze( project );
",0,False
"getLog().info( outputDirectory.toString() );
",0,False
private MavenProject project;,0,False
"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
",0,False
boolean attach;,0,False
"public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator
{
private boolean stripVersion = false;
private String prefix;
private File cpFile;
private File outputFile;
private boolean regenerateFile;
private String fileSeparator;
private String pathSeparator;
private String localRepoProperty;
boolean attach;
boolean outputFilterFile;
private MavenProjectHelper projectHelper;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
public void execute()
throws MojoExecutionException
{
if (cpFile != null)
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
if ( StringUtils.isEmpty( fileSeparator ) )
{
isFileSepSet = false;
}
else
{
isFileSepSet = true;
}
if ( StringUtils.isEmpty( pathSeparator ) )
{
isPathSepSet = false;
}
else
{
isPathSepSet = true;
}
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List artList = new ArrayList( artifacts );
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( (Artifact) i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
String separator = File.separator;
if ( File.separator.equals( ""\\"" ) )
{
separator = ""\\\\"";
}
cpString = cpString.replaceAll( separator, fileSeparator );
}
if (outputFilterFile)
{
cpString = ""classpath=""+ cpString;
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuffer sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
try
{
Writer w = new BufferedWriter( new FileWriter( out ) );
try
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': "" +
ex.toString(), ex );
}
finally
{
w.close();
}
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while opening/closing classpath file '"" + out + ""': "" +
ex.toString(), ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader( new FileReader( outputFile ) );
try
{
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
r.close();
}
}
public int compare( Object arg1, Object arg2 )
{
if ( arg1 instanceof Artifact && arg2 instanceof Artifact )
{
if ( arg1 == arg2 )
{
return 0;
}
else if ( arg1 == null )
{
return -1;
}
else if ( arg2 == null )
{
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
else
{
return 0;
}
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
",0,False
private MavenProjectHelper projectHelper;,0,False
"installer.install( artifact.getFile(), artifact, targetRepository );
",0,False
protected ArtifactInstaller installer;,0,False
"this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(
",0,False
protected boolean outputScope;,0,False
protected List<MavenProject> reactorProjects;,0,False
protected MavenProject project;,0,False
"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
",0,False
boolean attach;,0,False
private MavenProjectHelper projectHelper;,0,False
"(ArtifactRepositoryLayout) repositoryLayouts.get( ""default"" ),
",0,False
protected ArtifactInstaller installer;,0,False
"installer.install( artifact.getFile(), artifact, targetRepository );
",0,False
"project.getProperties().setProperty( artifact.getDependencyConflictId(),
",0,False
private ArtifactRepositoryFactory artifactRepositoryManager;,0,False
"outputWriter = new FileWriter( outputFile );
",0,False
"marker.createNewFile();
",0,False
"marker.createNewFile();
",0,False
public boolean silent;,0,False
protected boolean outputAbsoluteArtifactFilename;,0,False
protected boolean outputAbsoluteArtifactFilename;,0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
private String groupId;,0,False
"clearMarker.delete();
",0,False
"catch ( Exception e )
",0,False
"r = new BufferedReader( new FileReader( outputFile ) );
",0,False
".mkdirs();
",0,False
"writer = new FileWriter( file, append );
",0,False
"marker.createNewFile();
",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.setLastModified( ts );
",0,False
"marker.createNewFile();
",0,False
"clearMarker.delete();
",0,False
"catch ( Exception e )
",0,False
"catch ( Exception e )
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"this.fileMappers = fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"return this.fileMappers;
",0,False
"if ( plugins == null || plugins.isEmpty() )
",0,False
"catch ( Exception e )
",0,False
"catch ( Exception e )
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"return this.fileMappers;
",0,False
"return this.fileMappers;
",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"return this.fileMappers;
",0,False
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0,False
"marker.getParentFile().mkdirs();
",0,False
"location.mkdirs();
",0,False
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0,False
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0,False
"return this.fileMappers;
",0,False
"this.fileMappers = fileMappers;
",0,False
"return this.fileMappers;
",0,False
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0,False
"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
",0,False
"marker.createNewFile();
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"this.fileMappers = fileMappers;
",0,False
"this.fileMappers = fileMappers;
",0,False
"return this.fileMappers;
",0,False
"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
",0,False
"marker.getParentFile().mkdirs();
",0,False
"marker.getParentFile().mkdirs();
",0,False
protected boolean outputAbsoluteArtifactFilename;,0,False
private ProjectDependencyAnalyzer analyzer;,0,False
"if ( ""pom"".equals( project.getPackaging() ) )
",0,False
"deleteTarget.delete();
",0,False
private List remotePluginRepositories;,0,False
"marker.getParentFile().mkdirs();
",0,False
"catch ( Exception e )
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"return this.fileMappers;
",0,False
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0,False
"if ( plugins == null || plugins.isEmpty() )
",0,False
"marker.getParentFile().mkdirs();
",0,False
"UnArchiver unArchiver;
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
private List remotePluginRepositories;,0,False
"marker.createNewFile();
",0,False
"location.mkdirs();
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"if ( artifact != null )
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"marker.getParentFile().mkdirs();
",0,False
protected boolean outputAbsoluteArtifactFilename;,0,False
"catch ( Exception e )
",0,False
"w = new BufferedWriter( new FileWriter( out ) );
",0,False
"message += ""  "" + missingArtifact.getId() + ""\n"";
",0,False
"outputWriter = new FileWriter( outputFile );
",0,False
"marker.createNewFile();
",0,False
protected List reactorProjects;,0,False
protected File outputDirectory;,0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0,False
"return this.fileMappers;
",0,False
"List<Artifact> artList = new ArrayList<>( artifacts );
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"this.fileMappers = fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
",0,False
"catch ( Exception e )
",0,False
"this.fileMappers = fileMappers;
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"this.fileMappers = fileMappers;
",0,False
"if ( plugins == null || plugins.isEmpty() )
",0,False
"file.getParentFile().mkdirs();
",0,False
"catch ( Exception e )
",0,False
"location.mkdirs();
",0,False
"Dependency depMgtDependency = (Dependency) mismatch.get( resolvedArtifact );
",0,False
"else if ( arg1 == null )
",0,False
private MavenProjectHelper projectHelper;,0,False
"message += ""  "" + missingArtifact.getId() + ""\n"";
",0,False
"file.getParentFile().mkdirs();
",0,False
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
"return this.fileMappers;
",0,False
"this.fileMappers = fileMappers;
",0,False
"file.getParentFile().mkdirs();
",0,False
"marker.getParentFile().mkdirs();
",0,False
"location.mkdirs();
",0,False
"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
",0,False
"message += ""  "" + missingArtifact.getId() + ""\n"";
",0,False
"deleteTarget.delete();
",0,False
"unArchiver = archiverManager.getUnArchiver( file );
",0,False
"catch ( Exception e )
",0,False
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0,False
"return this.fileMappers;
",0,False
"return this.fileMappers;
",0,False
"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
",0,False
"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
",0,False
protected MavenProject project;,0,False
"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
",0,False
protected MavenProjectBuilder mavenProjectBuilder;,0,False
"deleteTarget.delete();
",0,False
private boolean excludeTransitive;,0,False
private List remotePluginRepositories;,0,False
"marker.createNewFile();
",0,False
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0,False
"this.fileMappers = fileMappers;
",0,False
"marker.getParentFile().mkdirs();
",0,False
"catch ( Exception e )
",0,False
"private class SnapshotsFilter
implements ArtifactFilter
{
public boolean include( Artifact artifact )
{
return artifact.isSnapshot();
",0,False
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST,
defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.cpFile"" )
private File cpFile;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
protected boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Parameter
protected boolean useJvmChmod = true;
@Parameter
protected boolean ignorePermissions;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
protected void doExecute()
throws MojoExecutionException
{
if ( cpFile != null )
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<Artifact>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath(i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
project.getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
else if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId, this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn(
""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
Writer w = null;
try
{
w = new BufferedWriter( new FileWriter( out ) );
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
finally
{
IOUtil.close( w );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try
{
r = new BufferedReader( new FileReader( outputFile ) );
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
IOUtil.close( r );
}
}
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getOutputProperty()
{
return this.outputProperty;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
",0,False
"@Parameter
protected boolean useJvmChmod = true;",0,False
"w = new BufferedWriter( new FileWriter( out ) );
",0,False
"r = new BufferedReader( new FileReader( outputFile ) );
",0,False
".mkdirs();
",0,False
"outputWriter = new FileWriter( outputFile );
",0,False
"return recommendedVersion.compareTo( theVersion ) <= 0;
",0,False
"file.getParentFile().mkdirs();
",0,False
"marker.createNewFile();
",0,False
protected File outputDirectory;,0,False
private ArrayList artifactItems;,0,False
protected boolean overWriteReleases;,0,False
"artifactItem.getOutputDirectory().mkdirs();
",0,False
private File markersDirectory;,0,False
"marker.getParentFile().mkdirs();
",0,False
"Artifact newArtifact = factory.createArtifactWithClassifier( artifact.getGroupId(), artifact
",0,False
private ArtifactFactory factory;,0,False
"this.fileMappers = fileMappers;
",0,False
"return this.fileMappers;
",0,False
"out.getParentFile().mkdirs();
",0,False
"this.fileMappers = fileMappers;
",0,False
"marker.createNewFile();
",0,False
"try ( FileWriter writer = new FileWriter( file, append ) )
",1,False
"Writer w = new BufferedWriter( new FileWriter( out ) );
",0,False
"Set<Artifact> results = artifacts;
",1,False
"@Parameter(property = ""mdep.useBaseVersion"", defaultValue = ""true"")
private final boolean useBaseVersion = true;",0,False
"@Parameter(property = ""mdep.stripClassifier"", defaultValue = ""false"")
private final boolean stripClassifier = false;",0,False
"model = pomReader.read( new FileReader( project.getFile() ) );
",1,False
"this(new PrintWriter(stream));
",0,False
"output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
",0,False
"return null;
",0,False
"return null;
",0,False
"if (messages == null) {
return null;
}
HashMap<String,ThreadContainer> idTable = new HashMap<String,ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t, idTable);
}
}
if (idTable.isEmpty()) {
return null;
}
ThreadContainer root = findRootSet(idTable);
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects(root);
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
return result;
",0,False
"num = size = 0;
",0,False
"__queue.notify();
",0,False
"return null;
",0,False
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",0,True
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0,False
"modulus = (++modulus) % 3;
",0,False
"return null;
",0,False
"long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int)countLong;
",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())
",0,False
"return null;
",0,False
"return null;
",0,False
"aytMonitor.wait(timeout);
",0,False
"__queue.notify();
",0,False
"return null;
",0,False
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",0,True
"final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) { 
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
"" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
"" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(
""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(
""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"") 
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for(String s : l) {
System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[]{args.getClass()});
String[] args2 = new String[args.length-1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object)args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}
",0,False
"return null;
",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION, true);
break;
",0,False
"file.setGroup(grp);
",0,False
"file.setUser(usr);
",0,False
"createCommandSupport();
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(
""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
",0,False
"computeDetails();
",0,False
"__queue.wait(100);
",0,False
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0,False
"return null;
",0,False
"long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int)countLong;
",0,False
"(SSLSocket) ssf.createSocket(_socket_, host, port, false);
",0,False
"@Deprecated
public static String PROVIDER;",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"file.setGroup(grp);
",0,False
"(SSLSocket) ssf.createSocket(_socket_, host, port, true);
",0,False
"return null;
",0,False
"return null;
",0,False
"if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}
",0,False
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
bogusIdCount++ ; 
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0,False
"computeDetails();
",0,False
"return null;
",0,False
"aytMonitor.wait(timeout);
",0,False
"return null;
",0,False
"return null;
",0,False
"this(new PrintWriter(stream), suppressLogin);
",0,False
"output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
",0,False
"return null;
",0,False
"return null;
",0,False
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
bogusIdCount++ ; 
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0,False
"return null;
",0,False
"return null;
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"modulus = (++modulus) % 3;
",0,False
"modulus = (++modulus) % 4;
",0,False
"return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker);
",0,False
"_output_.write(Integer.toString(server.getLocalPort()).getBytes());
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"Iterator<String> iter = idTable.keySet().iterator();
",0,False
"Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"return null;
",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"file.setUser(usr);
",0,False
"computeDetails();
",0,False
"num = size = 0;
",0,False
"return null;
",0,False
"(SSLSocket) ssf.createSocket(_socket_, host, port, true);
",0,False
"__queue.wait(100);
",0,False
"return null;
",0,False
"System.arraycopy(_fileName.getBytes(), 0, data, 2, fileLength);
",0,False
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0,False
"if (setEndpointIdentificationAlgorithm != null && getSSLParameters != null && setSSLParameters != null) {
",0,False
"final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) { 
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
"" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
"" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(
""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(
""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"") 
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for(String s : l) {
System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[]{args.getClass()});
String[] args2 = new String[args.length-1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object)args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}
",0,False
"return null;
",0,False
"@Deprecated
public static String STORE_TYPE;",0,False
"return null;
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"return null;
",0,False
"id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
",0,True
"computeDetails();
",0,False
"num = size = 0;
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"__queue.notify();
",0,False
"__queue.wait(100);
",0,False
"__queue.notify();
",0,False
"return null;
",0,False
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0,False
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0,False
"modulus = (++modulus) % 3;
",0,False
private final CopyOnWriteArrayList<EventListener> __listeners;,0,False
"this(new PrintWriter(stream), suppressLogin);
",0,False
"return null;
",0,False
"@Deprecated
public static String TRUSTSTORE_ALGORITHM;",0,False
"file.setPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION, true);
break;
",0,False
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0,False
"pointer.articleId = tokens[i++];
",0,False
"return null;
",0,False
"return null;
",0,False
"return null;
",0,False
"__queue.wait(100);
",0,False
"modulus = (++modulus) % 4;
",0,False
"return null;
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker);
",0,False
"this(new PrintWriter(stream));
",0,False
"this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
",0,False
"_output_.write(username.getBytes());
",0,False
"return null;
",0,False
"reader = new BufferedReader(new InputStreamReader(stream));
",0,False
"return sendCommand(CMD_ENC, new String(Base64.encodeBase64(data)));
",0,False
"return null;
",0,False
"Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())
",0,False
"return null;
",0,False
"if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}
",0,False
"if (messages == null) {
return null;
}
idTable = new HashMap<String,ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t);
}
}
root = findRootSet();
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects();
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
root = null;
return result;
",0,False
"computeDetails();
",0,False
"num = size = 0;
",0,False
public String identifier;,0,False
"__queue.wait(100);
",0,False
"__queue.notify();
",0,False
"for (ThreadContainer c = root.child; c != null; c = c.next)
",1,False
"BufferedReader reader = new BufferedReader(
",0,False
"(SSLSocket) ssf.createSocket(_socket_, host, port, false);
",1,False
"catch (IllegalMonitorStateException e)
",1,False
"ThreadContainer container = idTable.get(id);
",1,False
"if (subj == null || subj == """")
",0,False
"for (ThreadContainer c = root.child; c != null; c = c.next) {
",1,False
"this.rootCause = rootCause;
",1,False
"Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())
",0,False
"return initiateListParsing(key, pathname);
",1,False
"} catch (Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception e1) {
",0,False
"nsee.initCause(validationThrowable);
",0,False
private int _minIdle = DEFAULT_MIN_IDLE;,0,True
"if (!idleQueue.offerFirst(this)) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"ObjectQueue pool = _poolMap.get(key);
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
private int _maxSleeping = StackKeyedObjectPool.DEFAULT_MAX_SLEEPING;,0,False
"} catch(Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"} catch (Exception e2) {
",0,False
"} catch (final Exception e1) {
",0,False
"} catch (Exception ex2) {
",0,False
"final long lastActiveDiff =
this.getLastReturnTime() - other.getLastReturnTime();
if (lastActiveDiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
}
return (int)Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"writeLock.tryLock();
",0,True
"} catch(Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"nsee.initCause(validationThrowable);
",0,False
private int initIdleCapacity;,0,True
"if (!idleQueue.offerFirst(this)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"if(newlyCreated) {
",0,False
"} catch(Exception e) {
",0,False
private int initIdleCapacity;,0,True
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception e) {
",0,False
private int initIdleCapacity;,0,True
"writeLock.tryLock();
",0,True
"} catch(Exception e) {
",0,False
"readLock.tryLock();
",0,True
"writeLock.tryLock();
",0,True
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"latch.notify();
",0,False
"if (!underTest.endEvictionTest()) {
",0,False
"writeLock.tryLock();
",0,True
"} catch (Exception e2) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",1,False
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1,True
"writeLock.tryLock();
",1,True
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;,1,True
"readLock.tryLock();
",1,True
private PoolableObjectFactory _factory = null;,1,True
"final ObjectDeque<T> queue = poolMap.get(key);
",1,True
"_activeCount.put(key, new Integer(active.intValue() - 1));
",1,True
"writeLock.tryLock();
",1,True
private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1,True
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1,True
"writeLock.tryLock();
",1,True
private int initIdleCapacity;,1,True
"final ObjectDeque<T> deque = poolMap.get(k);
",1,True
protected int _totIdle = 0;,1,True
"writeLock.tryLock();
",1,True
"} catch (Exception e) {
",1,False
private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1,True
"writeLock.tryLock();
",1,True
"if (p == null && objectDeque != null) {
",1,True
"return ((IdentityWrapper) other).instance == instance;
",1,False
"this.interfaces = interfaces;
",1,False
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;,1,True
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;,1,True
"} catch (Exception e) {
",1,False
"if (objectDeque != null) {
",1,True
"ObjectDeque<T> queue = poolMap.get(k);
",1,True
"} catch (Exception e2) {
",1,False
private int initIdleCapacity;,1,True
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",1,False
"} catch (Exception e) {
",1,False
"} catch (Exception e) {
",1,False
"final ObjectDeque<T> deque = poolMap.get(k);
",1,True
private SoftReference<T> reference;,1,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,True
"if (!idleQueue.offerFirst(this)) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,True
"ObjectDeque<T> queue = poolMap.get(k);
",0,True
"ObjectDeque<T> queue = poolMap.get(key);
",0,True
"} catch (Exception e1) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,True
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception ex2) {
",0,False
"this(null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this(null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this(null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap<K, Stack<V>>();
_activeCount = new HashMap<K, Integer>();
}
@Override
public synchronized V borrowObject(K key) throws Exception {
assertOpen();
Stack<V> stack = (_pools.get(key));
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
V obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
@Override
public synchronized void invalidateObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
@Override
public synchronized int getNumIdle() {
return _totIdle;
}
@Override
public synchronized int getNumActive() {
return _totActive;
}
@Override
public synchronized int getNumActive(K key) {
return getActiveCount(key);
}
@Override
public synchronized int getNumIdle(K key) {
try {
return(_pools.get(key)).size();
} catch(Exception e) {
return 0;
}
}
@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while(it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
@Override
public synchronized void clear(K key) {
Stack<V> stack = _pools.remove(key);
destroyStack(key,stack);
}
private synchronized void destroyStack(K key, Stack<V> stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator<V> it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while(it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Deprecated
@Override
public synchronized void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory<K, V> getFactory() {
return _factory;
}
private int getActiveCount(K key) {
try {
return _activeCount.get(key).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map<K, Stack<V>> getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map<K, Integer> getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
@Deprecated
protected HashMap<K, Stack<V>> _pools = null;
@Deprecated
protected KeyedPoolableObjectFactory<K, V> _factory = null;
@Deprecated
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
@Deprecated
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
@Deprecated
protected int _totActive = 0;
@Deprecated
protected int _totIdle = 0;
@Deprecated
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"latch.notify();
",0,False
"catch (Exception e) {
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"} catch(Exception e) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0,False
"} catch(Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"this((PoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle) {
this((PoolableObjectFactory)null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this((PoolableObjectFactory)null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized int getNumIdle() {
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected Stack _pool = null;
protected PoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _numActive = 0;
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"latch.notify();
",0,False
"l.notify();
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"latch.notify();
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int minIdle) {
synchronized(this) {
_minIdle = minIdle;
}
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public void setConfig(GenericObjectPool.Config conf) {
synchronized (this) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
}
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
_numInternalProcessing--;
doAllocate = true;
} else {
_numInternalProcessing--;
_numActive++;
returnObject(latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
}
allocate();
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection c, PoolableObjectFactory factory) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
}
allocate();
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
boolean doAllocate = false;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
}
allocate();
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.remove();
synchronized (l) {
l.notify();
}
}
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
final PoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
allocate();
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
}
allocate();
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"latch.notify();
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory getFactory() {
return _factory;
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"latch.notify();
",0,False
"l.notify();
",0,False
"} catch (Exception ex2) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"latch.notify();
",0,False
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0,False
"} catch(Exception e) {
",0,False
"latch.notify();
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"if (!idleQueue.offerFirst(this)) {
",0,False
"ObjectDeque<T> queue = poolMap.get(k);
",0,True
"} catch (Exception e) {
",0,False
"borrowedCount++;
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,True
"final ObjectDeque<T> deque = poolMap.get(k);
",0,True
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
_numInternalProcessing--;
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
allocate();
}
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy);
}
private void destroy(Collection c) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"borrowedCount++;
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,True
"ObjectDeque<T> queue = poolMap.get(k);
",0,True
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,True
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0,False
"this((PoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle) {
this((PoolableObjectFactory)null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this((PoolableObjectFactory)null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized int getNumIdle() {
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected Stack _pool = null;
protected PoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _numActive = 0;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator entries = m.entrySet().iterator(); entries.hasNext();) {
Map.Entry entry = (Entry) entries.next();
Object key = entry.getKey();
Collection c = (Collection) entry.getValue();
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
//CHECKSTYLE: stop VisibilityModifier
Object value;
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public Object getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"catch (Exception e) {
",0,False
"latch.notify();
",0,False
protected int _totActive = 0;,0,True
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory getFactory() {
return _factory;
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,True
"} catch (Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class Cursor extends ListIter implements ListIterator<E> {
boolean _valid = false;
Cursor(int index) {
super(index);
_valid = true;
registerCursor(this);
}
@Override
public int previousIndex() {
throw new UnsupportedOperationException();
}
@Override
public int nextIndex() {
throw new UnsupportedOperationException();
}
@Override
public void add(E o) {
checkForComod();
Listable<E> elt = insertListable(_cur.prev(),_cur.next(),o);
_cur.setPrev(elt);
_cur.setNext(elt.next());
_lastReturned = null;
_nextIndex++;
_expectedModCount++;
}
protected void listableRemoved(Listable<E> elt) {
if(null == _head.prev()) {
_cur.setNext(null);
} else if(_cur.next() == elt) {
_cur.setNext(elt.next());
}
if(null == _head.next()) {
_cur.setPrev(null);
} else if(_cur.prev() == elt) {
_cur.setPrev(elt.prev());
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableInserted(Listable<E> elt) {
if(null == _cur.next() && null == _cur.prev()) {
_cur.setNext(elt);
} else if(_cur.prev() == elt.prev()) {
_cur.setNext(elt);
}
if(_cur.next() == elt.next()) {
_cur.setPrev(elt);
}
if(_lastReturned == elt) {
_lastReturned = null;
}
}
protected void listableChanged(Listable<E> elt) {
if(_lastReturned == elt) {
_lastReturned = null;
}
}
@Override
protected void checkForComod() {
if(!_valid) {
throw new ConcurrentModificationException();
}
}
protected void invalidate() {
_valid = false;
}
public void close() {
if(_valid) {
_valid = false;
unregisterCursor(this);
}
}
",0,False
"} catch(Exception e) {
",0,False
"latch.notify();
",0,False
"ObjectQueue pool = _poolMap.get(key);
",0,False
"latch.notify();
",0,False
"l.notify();
",0,False
"} catch(Exception e) {
",0,False
"_activeCount.put(key, new Integer(active.intValue() - 1));
",0,True
"Stack<V> stack = _pools.get(key);
",0,False
"this(null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
@Deprecated
public StackObjectPool(int maxIdle) {
this(null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
@Deprecated
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this(null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory<T> factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory<T> factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory<T> factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack<T>();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
@Override
public synchronized int getNumIdle() {
return _pool.size();
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized void clear() {
if(null != _factory) {
Iterator<T> it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Deprecated
@Override
public synchronized void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
@Deprecated
protected Stack<T> _pool = null;
@Deprecated
protected PoolableObjectFactory<T> _factory = null;
@Deprecated
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
@Deprecated
protected int _numActive = 0;
public synchronized PoolableObjectFactory<T> getFactory() {
return _factory;
}
public int getMaxSleeping() {
return _maxSleeping;
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public void setMaxTotal(int maxTotal) {
synchronized(this) {
_maxTotal = maxTotal;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
int maxIdle = getMaxIdle();
if (_minIdle > maxIdle) {
return maxIdle;
} else {
return _minIdle;
}
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
latch.getPool().decrementInternalProcessingCount();
doAllocate = true;
} else {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
returnObject(latch.getkey(), latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
}
allocate();
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if (newlyCreated) {
NoSuchElementException nsee = new NoSuchElementException(
""Unable to validate object"");
nsee.initCause(e);
throw nsee;
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue)_poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator entries = m.entrySet().iterator(); entries.hasNext();) {
Map.Entry entry = (Entry) entries.next();
Object key = entry.getKey();
Collection c = (Collection) entry.getValue();
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
ObjectQueue objectQueue =
(ObjectQueue) _poolMap.get(key);
if (objectQueue != null) {
objectQueue.decrementInternalProcessingCount();
if (objectQueue.internalProcessingCount == 0 &&
objectQueue.activeCount == 0 &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_totalInternalProcessing--;
}
}
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
}
allocate(); 
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() &&
objectQueue.activeCount == 0 &&
objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (getMinIdle() > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
}
allocate();
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
//CHECKSTYLE: stop VisibilityModifier
Object value;
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public Object getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
public void run() {
ClassLoader savedClassLoader =
Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(
_factoryClassLoader);
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private ClassLoader _factoryClassLoader = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0,False
"} catch (Exception ex2) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0,False
"latch.notify();
",0,False
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory getFactory() {
return _factory;
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception ex2) {
",0,False
private boolean testOnReturn;,0,False
private int maxTotal;,0,False
private boolean lifo;,0,False
private int numTestsPerEvictionRun;,0,False
"latch.notify();
",0,False
private boolean testOnBorrow;,0,False
private long maxWait;,0,False
private int maxTotal;,0,False
private long softMinEvictableIdleTimeMillis;,0,True
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception e2) {
",0,False
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"if (p == null && objectDeque != null) {
",0,True
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"public class GenericObjectPool<T> extends BaseObjectPool<T> implements ObjectPool<T>, GenericObjectPoolMBean<T> {
public GenericObjectPool(PoolableObjectFactory<T> factory) {
this(factory, new GenericObjectPoolConfig.Builder().createConfig());
}
public GenericObjectPool(PoolableObjectFactory<T> factory, GenericObjectPoolConfig config) {
if (factory == null) {
throw new IllegalArgumentException(""factory must not be null"");
}
if (config == null) {
throw new IllegalArgumentException(""config must not be null"");
}
this._factory = factory;
this.maxIdle = config.getMaxIdle();
this.minIdle = config.getMinIdle();
this.maxTotal = config.getMaxTotal();
this.maxWait = config.getMaxWait();
this.whenExhaustedAction = config.getWhenExhaustedAction();
this.testOnBorrow = config.getTestOnBorrow();
this.testOnReturn = config.getTestOnReturn();
this.testWhileIdle = config.getTestWhileIdle();
this.timeBetweenEvictionRunsMillis = config.getTimeBetweenEvictionRunsMillis();
this.numTestsPerEvictionRun = config.getNumTestsPerEvictionRun();
this.minEvictableIdleTimeMillis = config.getMinEvictableIdleTimeMillis();
this.lifo = config.getLifo();
this.softMinEvictableIdleTimeMillis = config.getSoftMinEvictableIdleTimeMillis();
_pool = new CursorableLinkedList<ObjectTimestampPair<T>>();
startEvictor(config.getTimeBetweenEvictionRunsMillis());
}
public synchronized int getMaxTotal() {
return this.maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
this.maxTotal = maxTotal;
allocate();
}
public synchronized WhenExhaustedAction getWhenExhaustedAction() {
return this.whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(WhenExhaustedAction whenExhaustedAction) {
this.whenExhaustedAction = whenExhaustedAction;
allocate();
}
public synchronized long getMaxWait() {
return this.maxWait;
}
public synchronized void setMaxWait(long maxWait) {
this.maxWait = maxWait;
allocate();
}
public synchronized int getMaxIdle() {
return this.maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
this.maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int minIdle) {
this.minIdle = minIdle;
allocate();
}
public synchronized int getMinIdle() {
return this.minIdle;
}
public synchronized boolean getTestOnBorrow() {
return this.testOnBorrow;
}
public synchronized void setTestOnBorrow(boolean testOnBorrow) {
this.testOnBorrow = testOnBorrow;
}
public synchronized boolean getTestOnReturn() {
return this.testOnReturn;
}
public synchronized void setTestOnReturn(boolean testOnReturn) {
this.testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return this.timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(this.timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return this.numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
this.numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return this.minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return this.softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
this.softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return this.testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
this.testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return this.lifo;
}
public synchronized void setLifo(boolean lifo) {
this.lifo = lifo;
}
@Override
public T borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
WhenExhaustedAction whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = this.whenExhaustedAction;
maxWait = this.maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
T obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair<T>(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
try {
_factory.activateObject(latch.getPair().getValue());
if(testOnBorrow &&
!_factory.validateObject(latch.getPair().getValue())) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().getValue();
}
catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(latch.getPair().getValue());
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
_numInternalProcessing--;
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
allocate();
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = _allocationQueue.removeFirst();
latch.setPair(_pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (this.maxTotal < 0 || (_numActive + _numInternalProcessing) < this.maxTotal)) {
Latch latch = _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
@Override
public void invalidateObject(T obj) throws Exception {
try {
_factory.destroyObject(obj);
} finally {
synchronized (this) {
_numActive--;
allocate();
}
}
}
@Override
public void clear() {
List<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Collection<ObjectTimestampPair<T>> c, PoolableObjectFactory<T> factory) {
for (ObjectTimestampPair<T> pair : c) {
try {
factory.destroyObject(pair.getValue());
} catch (Exception e) {
} finally {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized int getNumIdle() {
return _pool.size();
}
@Override
public void returnObject(T obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
allocate();
}
}
}
private void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(this.testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((this.maxIdle >= 0) && (_pool.size() >= this.maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (this.getLifo()) {
_pool.addFirst(new ObjectTimestampPair<T>(obj));
} else {
_pool.addLast(new ObjectTimestampPair<T>(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(this.lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair<T> pair;
synchronized (this) {
if ((this.lifo && !_evictionCursor.hasPrevious()) ||
!this.lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(this.lifo ? _pool.size() : 0);
}
pair = this.lifo ? _evictionCursor.previous() : _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.getTstamp();
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.getValue());
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.getValue())) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.getValue());
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.getValue());
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (this.lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (this.maxTotal > 0) {
int growLimit = Math.max(0,
maxTotal - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
@Override
public void addObject() throws Exception {
assertOpen();
T obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
long time = System.currentTimeMillis();
for (ObjectTimestampPair<T> pair  : _pool) {
buf.append(""\t"").append(pair.getValue()).append(""\t"").append(time - pair.getTstamp()).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
int numTestsPerEvictionRun = this.numTestsPerEvictionRun;
if(numTestsPerEvictionRun >= 0) {
return Math.min(numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
@Override
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
private final class Latch {
private ObjectTimestampPair<T> _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair<T> getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair<T> pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int maxIdle; 
private int minIdle; 
private int maxTotal; 
private long maxWait; 
private WhenExhaustedAction whenExhaustedAction; 
private boolean testOnBorrow; 
private boolean testOnReturn; 
private boolean testWhileIdle; 
private long timeBetweenEvictionRunsMillis; 
private int numTestsPerEvictionRun; 
private long minEvictableIdleTimeMillis; 
private boolean lifo; 
private long softMinEvictableIdleTimeMillis; 
private CursorableLinkedList<ObjectTimestampPair<T>> _pool = null;
private CursorableLinkedList<ObjectTimestampPair<T>>.Cursor _evictionCursor = null;
private final PoolableObjectFactory<T> _factory;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private final LinkedList<Latch> _allocationQueue = new LinkedList<Latch>();
",0,False
"latch.notify();
",0,False
"} catch (Exception e2) {
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"// XXX: Add better handling of when this instance is not Serializable
private final ObjectPoolFactory poolFactory;",0,False
"} catch (Exception e) {
",0,False
private Object referant;,0,False
"} catch (Exception e) {
",0,False
"active++; 
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"} catch(Exception e) {
",0,False
"if(newlyCreated) {
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = true;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null,DEFAULT_MAX_ACTIVE,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_ACTIVE,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory,config.maxActive,config.whenExhaustedAction,config.maxWait,config.maxIdle,config.minIdle,config.testOnBorrow,config.testOnReturn,config.timeBetweenEvictionRunsMillis,config.numTestsPerEvictionRun,config.minEvictableIdleTimeMillis,config.testWhileIdle,config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory,maxActive,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory,maxActive,whenExhaustedAction,maxWait,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory,maxActive,whenExhaustedAction,maxWait,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,testOnBorrow,testOnReturn,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory,maxActive,whenExhaustedAction,maxWait,maxIdle,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory,maxActive,whenExhaustedAction,maxWait,maxIdle,DEFAULT_MIN_IDLE,testOnBorrow,testOnReturn,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle, DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle, long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle, softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle, long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
notifyAll();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
notifyAll();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
notifyAll();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
notifyAll();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
notifyAll();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
notifyAll();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
for(;;) {
ObjectTimestampPair pair = null;
synchronized (this) {
assertOpen();
try {
pair = (ObjectTimestampPair)(_pool.removeFirst());
} catch(NoSuchElementException e) {
; 
}
if(null == pair) {
if(_maxActive < 0 || _numActive < _maxActive) {
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
if(_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0)
{
wait(waitTime);
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if(_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + _whenExhaustedAction + "" not recognized."");
}
}
}
_numActive++;
}
boolean newlyCreated = false;
if(null == pair) {
try {
Object obj = _factory.makeObject();
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
return pair.value;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numActive--;
notifyAll();
}
}
}
}
try {
_factory.activateObject(pair.value);
if(_testOnBorrow && !_factory.validateObject(pair.value)) {
throw new Exception(""ValidateObject failed"");
}
return pair.value;
}
catch (Throwable e) {
synchronized (this) {
_numActive--;
notifyAll();
}
try {
_factory.destroyObject(pair.value);
}
catch (Throwable e2) {
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} catch (Exception e) {
} finally {
synchronized (this) {
_numActive--;
notifyAll(); 
}
}
}
public synchronized void clear() {
for(Iterator it = _pool.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
}
it.remove();
}
_pool.clear();
notifyAll(); 
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = false;
synchronized (this) {
if (decrementNumActive) {
_numActive--;
}
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
}
}
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized void evict() throws Exception {
assertOpen();
if(!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i=0,m=getNumTests();i<m;i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0)
&& (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0)
&& (idleTimeMilis > _softMinEvictableIdleTimeMillis)
&& (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if(_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if(removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
}
} 
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit();
for ( int j = 0 ; j < objectDeficit && calculateDeficit() > 0 ; j++ ) {
addObject();
}
}
private synchronized int calculateDeficit() {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0, getMaxActive() - getNumActive() - getNumIdle());
objectDeficit = Math.min(objectDeficit, growLimit);
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil((double)_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if(!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
try {
_factory.destroyObject(key,obj);
} catch (Exception e) {
}
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"private Listable<E> _prev = null;
private Listable<E> _next = null;
private E _val = null;
Listable(Listable<E> prev, Listable<E> next, E val) {
_prev = prev;
_next = next;
_val = val;
}
Listable<E> next() {
return _next;
}
Listable<E> prev() {
return _prev;
}
E value() {
return _val;
}
void setNext(Listable<E> next) {
_next = next;
}
void setPrev(Listable<E> prev) {
_prev = prev;
}
E setValue(E val) {
E temp = _val;
_val = val;
return temp;
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"this(null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this(null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this(null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap<K, Stack<V>>();
_activeCount = new HashMap<K, Integer>();
}
@Override
public synchronized V borrowObject(K key) throws Exception {
assertOpen();
Stack<V> stack = (_pools.get(key));
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
V obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
@Override
public synchronized void invalidateObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
@Override
public synchronized int getNumIdle() {
return _totIdle;
}
@Override
public synchronized int getNumActive() {
return _totActive;
}
@Override
public synchronized int getNumActive(K key) {
return getActiveCount(key);
}
@Override
public synchronized int getNumIdle(K key) {
try {
return(_pools.get(key)).size();
} catch(Exception e) {
return 0;
}
}
@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while(it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
@Override
public synchronized void clear(K key) {
Stack<V> stack = _pools.remove(key);
destroyStack(key,stack);
}
private synchronized void destroyStack(K key, Stack<V> stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator<V> it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while(it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Deprecated
@Override
public synchronized void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory<K, V> getFactory() {
return _factory;
}
private int getActiveCount(K key) {
try {
return _activeCount.get(key).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map<K, Stack<V>> getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map<K, Integer> getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
@Deprecated
protected HashMap<K, Stack<V>> _pools = null;
@Deprecated
protected KeyedPoolableObjectFactory<K, V> _factory = null;
@Deprecated
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
@Deprecated
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
@Deprecated
protected int _totActive = 0;
@Deprecated
protected int _totIdle = 0;
@Deprecated
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0,False
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0,False
"latch.notify();
",0,False
"} catch (Exception ex2) {
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory getFactory() {
return _factory;
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0,False
"} catch(Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"scheduledFuture.cancel(false);
",0,False
"borrowedCount++;
",0,False
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"latch.notify();
",0,False
"} catch(Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"Stack stack = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"if (!idleQueue.offerFirst(this)) {
",0,False
"borrowedCount++;
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,True
private long createCount = 0;,0,False
"} catch (final Exception ignored) {
",0,False
"borrowedCount++;
",0,False
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0,False
"throw (Error) validationThrowable;
",0,False
"} catch (final Exception e) {
",0,False
"} catch (final Exception e) {
",0,False
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"Collection c = (Collection) m.get(key);
",0,True
"latch.notify();
",0,False
"latch.notify();
",0,False
"} catch (Exception ex2) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"final ObjectDeque<T> deque = poolMap.get(k);
",0,True
"} catch (Exception e) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,True
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0,False
"ObjectDeque<T> queue = poolMap.get(k);
",0,True
"ObjectDeque<T> queue = poolMap.get(key);
",0,True
"} catch (Exception e1) {
",0,False
"} catch (Exception e) {
",0,False
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"} catch (Exception e2) {
",0,False
"} catch(Exception e) {
",0,False
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null,DEFAULT_MAX_ACTIVE,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_ACTIVE,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory,config.maxActive,config.whenExhaustedAction,config.maxWait,config.maxIdle,config.minIdle,config.testOnBorrow,config.testOnReturn,config.timeBetweenEvictionRunsMillis,config.numTestsPerEvictionRun,config.minEvictableIdleTimeMillis,config.testWhileIdle,config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory,maxActive,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory,maxActive,whenExhaustedAction,maxWait,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory,maxActive,whenExhaustedAction,maxWait,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,testOnBorrow,testOnReturn,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory,maxActive,whenExhaustedAction,maxWait,maxIdle,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory,maxActive,whenExhaustedAction,maxWait,maxIdle,DEFAULT_MIN_IDLE,testOnBorrow,testOnReturn,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle, DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle, long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle, softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle, long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
notifyAll();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
notifyAll();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
notifyAll();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
notifyAll();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
notifyAll();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
notifyAll();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
for(;;) {
ObjectTimestampPair pair = null;
synchronized (this) {
assertOpen();
try {
pair = (ObjectTimestampPair)(_pool.removeFirst());
} catch(NoSuchElementException e) {
; 
}
if(null == pair) {
if(_maxActive < 0 || _numActive < _maxActive) {
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
if(_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0)
{
wait(waitTime);
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if(_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + _whenExhaustedAction + "" not recognized."");
}
}
}
_numActive++;
}
boolean newlyCreated = false;
if(null == pair) {
try {
Object obj = _factory.makeObject();
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numActive--;
notifyAll();
}
}
}
}
try {
_factory.activateObject(pair.value);
if(_testOnBorrow && !_factory.validateObject(pair.value)) {
throw new Exception(""ValidateObject failed"");
}
return pair.value;
}
catch (Throwable e) {
try {
_factory.destroyObject(pair.value);
} catch (Throwable e2) {
}
synchronized (this) {
_numActive--;
notifyAll();
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
notifyAll(); 
}
}
}
public synchronized void clear() {
for(Iterator it = _pool.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
}
it.remove();
}
_pool.clear();
notifyAll(); 
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
notifyAll();
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
notifyAll();
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized void evict() throws Exception {
assertOpen();
if(!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i=0,m=getNumTests();i<m;i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0)
&& (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0)
&& (idleTimeMilis > _softMinEvictableIdleTimeMillis)
&& (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if(_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if(removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
}
} 
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit();
for ( int j = 0 ; j < objectDeficit && calculateDeficit() > 0 ; j++ ) {
addObject();
}
}
private synchronized int calculateDeficit() {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0, getMaxActive() - getNumActive() - getNumIdle());
objectDeficit = Math.min(objectDeficit, growLimit);
}
return objectDeficit;
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil((double)_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
",0,False
"} catch(Exception e) {
",0,False
"Stack s = (Stack)(_pools.get(key));
",0,False
"} catch(Exception e) {
",0,False
"} catch (Exception e) {
",0,False
"ObjectDeque<T> queue = poolMap.get(key);
",0,True
"if (!underTest.endEvictionTest(idleObjects)) {
",0,False
